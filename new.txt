 "_recipe_10846" : "{
 "desc" : "Banding helises one by one  and make them more  ideal.  Options at end."
 "hidden" : "0"
 "mid" : "5888"
 "mrid" : "28941"
 "name" : "Helix  Curler 1.5"
 "parent" : "5769"
 "parent_mrid" : "4936"
 "player_id" : "174969"
 "script" : "--Helise Cure by Marie Suchard
--modded by rav3n_pl v1.5 02-2011

p=print --a short

function Score()
    return get_score(true)
end

function bandstr(str)
    for ib=1, get_band_count() do
        band_set_strength(ib, str)
    end
end

function delBands()
    band_delete()
end

function round(x)--cut all afer 3-rd place
    return x-x%0.001
end

function Wiggle(how, iters, minppi)
    if how==nil then how="wa" end
    if iters==nil then iters=3 end
    if minppi==nil then minppi=0.1 end
    if iters>0 then
        iters=iters-1
        sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2)
        end
        ep = Score()
        ig=ep-sp
        if how~="s" then
            if ig > minppi then return Wiggle(how, iters, minppi) end
        end
    end
end

function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    p("Fuzing...")
    reset_recent_best()
    quicksave(4)
    Fuze1(0.1,0.7)
    quickload(4)
    Fuze1(0.3,0.6)
    quickload(4)
    Fuze2(0.5,0.7)
    quickload(4)
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end
bestScore=Score()
function SaveBest()
    local s=Score()
    local g=s-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=s
        quicksave(3)
    end
end
function qStab()
    p("qStab...")
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    if fastStab==false then
        set_behavior_clash_importance(0.6)
        Wiggle()
        set_behavior_clash_importance(1)
        Wiggle("s",1)
    end
    set_behavior_clash_importance(1)
    Wiggle()
    SaveBest()
end

-- put band on helix number "helix" each segment with the segment "step" segments away
function band_helix(hstart, hend, step)
    p("Banding from ",hstart," to ",hend," every ",step," segment.")
    local bands=get_band_count()
    for segmt=hstart, hend-step do
        band_add_segment_segment(segmt, segmt+step)
    end
    local len=0
    if step==4 then len=6.3 else len=8.6 end --"ideal" distance beteween segments
    for i=bands+1, get_band_count() do
        band_set_length(i,len)
    end
    --Wiggle("ws")--locking bands
end
function abs(x)
    if x>0 then return x else return -x end
end
function SaveRB(slot)
    quicksave(slot)
    restore_recent_best()
    SaveBest()
    quickload(slot)
end
-- wiggle, delete bands, wiggle, shake,wiggle
function pull(h, s, b,strfactor,hs,he)--helise, steps, bands, str factor
    p('Pulling helix no ',h,'; band every ',b,' sgs; ',s," steps")
    quicksave(3)
    reset_recent_best()
    for force=1,s do
        band_enable()
        bandstr((force/s)*strfactor)
        if partialPull==true then
            deselect_all()
            select_index_range(hs,he)
        else
            select_all()
        end
        local ss=Score()
        set_behavior_clash_importance(pullingCI)
        do_global_wiggle_backbone(3)
        SaveRB(4)
        band_disable()
        select_all()
        set_behavior_clash_importance(1)
        if abs(Score()-ss)>1 then
            qStab()
            if Score()-bestScore<pfThreshold then
                PinkFuse()
            end
        else --no need if no score change
            Wiggle()
        end
        SaveBest()
        if Score()>ss then
            p('Step ', force, ' finished at score: ',round(Score()))
        else
            quickload(3)
        end
    end
    p("Pulling finished at:",round(Score()))
end

function doBondage(hstart,hend,hno,steps,strfactor)
    delBands()
    band_helix(hstart,hend,4)
    pull(hno,steps,4,strfactor,hstart,hend)
    
    delBands()
    band_helix(hstart,hend,5)
    pull(hno,steps,5,strfactor,hstart,hend)

    delBands()
    band_helix(hstart,hend,4)
    band_helix(hstart,hend,5)
    pull(hno,steps,"4 and 5",strfactor,hstart,hend)
end

function CureHelises()
    set_behavior_clash_importance(1)
    do_unfreeze_all()
    select_all()

    reset_recent_best()
    sScore=Score()
    p('Starting score: ',round(sScore))
    nbsegtot=get_segment_count()
    nbhelix =0 -- number of helices
    beghelix ={} -- first segment of each helices longer than 4
    endhelix ={} -- last segment

    -- search number of helices, first and last segment of each
    noseg=1
    if get_ss(1)=='H' then nbhelix=1  beghelix[1]=noseg  end -- if it begin by an helix
    for noseg =2,nbsegtot do
        if get_ss(noseg)=='H' and (get_ss(noseg-1)=='L' or get_ss(noseg-1)=='E' )
            then nbhelix=nbhelix+1 beghelix[nbhelix]=noseg
        end -- of if begin of an helix
        if (get_ss(noseg)=='E' or get_ss(noseg)=='L')  and get_ss(noseg-1)=='H'
            then endhelix[nbhelix]=noseg - 1
                if endhelix[nbhelix]<beghelix[nbhelix]+5 then nbhelix=nbhelix-1 end -- of helix too short
        -- helix of less than 5 segments don't count
        end -- of if end of helix
    end -- on loop on segment
    p("Found ",nbhelix," usable helises.")
    -- helix by helix (more effective than all togethers)
    for h=1,nbhelix do
        hs=beghelix[h]
        he=endhelix[h]
        if he-hs>maxln then
            p("Helix too long, doing banding every ",stepln," segments.")
            for hstart=hs, he-maxln, stepln do
                doBondage(hstart,hstart+maxln,h,steps,strfactor)
            end
        else
            doBondage(hs,he,h,steps,strfactor)
        end
    end -- of loop on helices

    eScore=Score() gain=eScore-sScore
    p("End score: ",round(eScore)," Gained: ",round(gain))
end

--steps=how many times strengh should be changed (2 to 10), default (slowest)=10
--maxln=maximum lenght of cured helise (default=entire helise at once, min 6)
--stepln=if helise is longer than maxln how many segment should be skipped beterrn bandings (default-1 seg)
--strfactor=maximum str for bands, default 1.1
steps=10 --default: 10 steps
maxln=500--default: all helise at once
stepln=1 --default: every 1 segment
strfactor=1.3 --maximum str of bands

pullingCI=0.7 --clash importance during pull
partialPull=true --only helix selected when pull

fastStab=false --if true only 1 shake and 1 wiggle as qstab
doPF=true --PinkFuze (quadriple release)
pfThreshold=5 --run PF only if close to best score

CureHelises()






"
 "type" : "script"
 "uses" : "4"
 "ver" : "0.3"
}
"
 "_recipe_12058" : "{
 "desc" : "variable distance local wiggle walker. Create a local wiggle stride pattern that is not uniform. Grind out the points. See comments in script."
 "hidden" : "0"
 "mid" : "2472"
 "mrid" : "865"
 "name" : "pi_walker"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "167300"
 "script" : "--  pi_walker

-- A variable distance walker
--
-- author srssmith92 19 May 2010
--
-- Find  seg_list, a list of numbers. This list sets the variable local wiggle distance. If there is just one number you get the normal
--    local wiggle stride x. If you add a number, the striding is alternated by the list of numbers instead of being uniform.
--  The list is rotated and wiggled again.  The script can take awhile to run with even 3 or 4 numbers.
--   It will slowly grind out points
--
--  Progress output is displayed.
--
g_segments = get_segment_count()

function mynextmod(number,maximum)
    number = number + 1
    if number > maximum then
        number = 1
    end
    return number
end

function rotate_pattern(pattern_list)
    local last = # pattern_list
    if # pattern_list > 1 then
        local pattern_save = pattern_list[1]
        for i=1, last-1 do
            pattern_list[i] = pattern_list[i+1]
        end
        pattern_list[last] = pattern_save
    end
    return pattern_list
end

function unfreeze_protein()
    do_unfreeze_all()
end

function freeze_segments(start_index, pattern_list)
    unfreeze_protein()
    local pattern_length = # pattern_list
    local current_segment = start_index
    local pattern_count = 1
    deselect_all()
    while current_segment < g_segments  do
        select_index(current_segment)
        current_segment =  current_segment + pattern_list[pattern_count]
        pattern_count = mynextmod(pattern_count, pattern_length)
    end
    do_freeze(true,true)
end

function do_a_local_wiggle(first,last,count)
    deselect_all()
    print("wiggling from ", first, " to ", last, " of ", g_segments)
    select_index_range(first,last)
    do_local_wiggle(count)
    restore_recent_best()
end

function local_wiggle_segments(first_frozen_segment, pattern_list, wiggle_count)
    local  current_segment = 0
    local end_segment = 0
    local current_pattern = 1
    local pattern_length = # pattern_list
    if first_frozen_segment == 1 then
        current_segment =  2
        end_segment = current_segment + pattern_list[1]-2
        current_pattern = mynextmod(current_pattern,pattern_length)
    else
        current_segment = 1
        end_segment = first_frozen_segment-1
    end
    repeat
        do_a_local_wiggle(current_segment,end_segment,wiggle_count)
        current_segment = end_segment + 2
        end_segment = current_segment + pattern_list[current_pattern]-2
        current_pattern = mynextmod(current_pattern,pattern_length)
    until end_segment > g_segments
    if current_segment <= g_segments then
        do_a_local_wiggle(current_segment,g_segments,wiggle_count)
    end
end

function freeze_wiggle(pattern_list, wiggle_count)
    local i=0
    for  i=1, pattern_list[1] do
        freeze_segments(i, pattern_list)
        reset_recent_best()
        local_wiggle_segments(i, pattern_list, wiggle_count)
    end
end

function verify_list(pattern_list)
    result = true
    pattern_length = # pattern_list
    local count = 0
    for count=1, pattern_length do
        if pattern_list[count] == 1 or pattern_list[count] >= g_segments then
             result = false
             break
        end
    end
    return result
end

pattern_list = {8,7,9} --{2,2,9} -- distance between frozen segments. Change this to what you want. Experiment. 2,2,3; 3,3,2,4; whatever
pattern_length = # pattern_list
pattern_list_ok = verify_list(pattern_list)
if pattern_list_ok then
    wiggle_count = 12
    for pattern_count=1,pattern_length do
        freeze_wiggle(pattern_list,wiggle_count)
        pattern_list = rotate_pattern(pattern_list)
    end

    unfreeze_protein()
else
    print("Pattern list contains a 1, or an element greater than ", g_segments, " quiiting")
end

"
 "type" : "script"
 "uses" : "1"
 "ver" : "0.3"
}
"
 "_recipe_12489" : "{
 "desc" : "Rebuilding areas found by worst reaction on LWS test. Partial score only Backbone and Sidechain."
 "hidden" : "1"
 "mid" : "15178"
 "mrid" : "30413"
 "name" : "Rav3n_pl LWS PhD v2.7"
 "parent" : "13441"
 "parent_mrid" : "15549"
 "player_id" : "174969"
 "script" : "--[[
Rebuilder - LWS PhD v2
Rebuilding worst scoring areas by LWS check
]]--

p=print
segCnt=get_segment_count()
areas={} --define global table

function Score()
    return get_score(true)
end 
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function getPartScore(segments)--using partial scoring
    local attr = {'backbone','sidechain'}--,'clashing','reference','disulfides','packing','hiding','other','bonding',}
    local score = 0
    for i=1,#attr do
        score =  score + get_segment_score_part(attr[i], segments)
    end
    return score
end
function getAreaScore(ss,se)
    local s=0
    for i=ss,se do
        s=s+getPartScore(i)
    end
    return s
end
function abs(x)
    if x<0 then x=-x end
    return x
end

function Wiggle(how, iters, minppi)
    if how==nil then how="wa" end
    if iters==nil then iters=3 end
    if minppi==nil then minppi=0.1 end
    
    if iters>0 then
        iters=iters-1
        sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2) 
        end
        ep = Score()
        ig=ep-sp
        if how~="s" then
            if ig > minppi then return Wiggle(how, iters, minppi) end --tail call
        end
    end
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then 
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end

bestScore=Score()
startScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end
function SaveRB()
    quicksave(4)
    restore_recent_best()
    SaveBest()
    quickload(4)
end
function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    reset_recent_best()
    quicksave(4) -- store state before fuse
    Fuze1(0.1,0.7)
    quickload(4) -- load state before fuse
    Fuze1(0.3,0.6)
    quickload(4) -- load state before fuse
    Fuze2(0.5,0.7)
    quickload(4) -- load state before fuse
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end
function qStab()
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    if fastQstab==false then
        set_behavior_clash_importance(0.4)
        Wiggle()
        set_behavior_clash_importance(1)
        Wiggle("s",1)
    end
    set_behavior_clash_importance(1)
    Wiggle()
	if doPF and Score()>bestScore-PFthresh then
	\	SaveBest()
	\	PinkFuse()
	end
	SaveBest()
end

function Sort(tab,items) --BACWARD bubble sorting - lowest on top, only needed items
    for x=1,items do --items do
        for y=x+1,#tab do
            if tab[x][1]>tab[y][1] then
                tab[x],tab[y]=tab[y],tab[x]
            end
        end
    end
    return tab
end

uncuredScore={}
function KillCheck(len)
    local kill=false
    local w=areas[1][1] --worst score
    uncuredScore[len]=w
    local cured=0
    for i=minL, maxL do
        if uncuredScore[i]==nil then 
            kill=false
            break 
        else
            if uncuredScore[i]>killPont then cured=cured+1 end
        end
    end    
    if cured==(maxL-minL+1) then kill=true end
    
    if kill then 
        p("Its over! Nothing to cure!")
        p("Total gain: ",round(Score()-startScore))
        killPhd() --kicking out script
    end
end
function FindWorst()
    reset_recent_best()
    p("Detecting worst LWSing areas on len ",len)
    areas={} --clear table
    quicksave(8)
    local idx=0
    for i=sStart, sEnd-len do
        idx=idx+1
        local ss=i
        local se=i+len-1
        deselect_all()
        select_index_range(ss,se)
        local s=Score()
        do_local_wiggle(1)
        s=Score()-s
        areas[#areas+1]={s,i}
        if keepLWS==true then
            if s<0 then restore_recent_best() end
        else
            quickload(8)
        end
    end
    areas=Sort(areas,reBuild)
    for i=1,reBuild do
        p(areas[i][2]," : ",round(areas[i][1]))
    end
    KillCheck(len)
end

partial=0
function savePartial(ss,se)
    local part2=getPartScore(ss,se)
    if part2>partial then
        quicksave(7)--save best partial score
        partial=part2
    end
    return partial
end
function localRebuild(maxiters)
    if maxiters==nil then maxiters=3 end
    local s=Score()
    local i=0
    repeat
        i=i+1
        if i>maxiters then break end
        do_local_rebuild(i)
    until Score()~=s 
    if Score()~=s then return false else return true end
end
function Rebuild(ss,se,tries)
    if ss>se then ss,se=se,ss end --switch if needed
    p("Rebuilding area ",ss,"-",se," ",tries," times. Wait...")
    local sSc=Score()
    local done=false
    deselect_all()
    select_index_range(ss,se)
    repeat
        done = localRebuild() --searching until score changes
    until done~=true
    reset_recent_best() -- first global "best"
    partial=getPartScore(ss,se)
    quicksave(7) --save first best partial score
    for try=1,tries do -- perform loop for number of tries
        deselect_all()
        select_index_range(ss,se)
        localRebuild()
        if doShake then
            Wiggle("s",1)
        end
        savePartial(ss,se)
    end
    restore_recent_best()--restore best total score
end

function LwsPhD()
    if sEnd==nil then sEnd=segCnt end
    AllLoop()
    set_behavior_clash_importance(1)
    FindWorst()
    quicksave(3)
    for i=1,reBuild do
        if areas[i][1]<rebuildPoint then --not rebuilding if it is not so bad
            local ss=areas[i][2]
            local se=ss+len-1
            local s1=Score()
            Rebuild(ss,se,tries)
            p("Stabilizing best total score...")
            qStab()
            p("Stabilizing best partial score...")
            quickload(7)
            qStab()
            quickload(3)
            local g=Score()-s1
            if g>0 then 
                p("Rebuld gain: ",round(g)," ,current score: ",round(Score()))
            end
        end
    end
    
    load_structure()
end

sStart=1 --from segment
sEnd=nil --to segment, nil=end

reBuild=5 --how many worst areas to rebuild
tries=35 --how many tries each rebuild; more- more chances to rebuild it for good

fastQstab=true --only 1 shake and wiggle when true
keepLWS=false --if true keep points gained by LWS check, NOT recommended!
doShake=false --true --shake rebuilded area every rebuild, false will speed things up

doPF=true --PinkFuze after stabilize, recomended on high scored puzzles
PFthresh=-1 --run PF only if we close to best score (-1 is after incerase)

minL=2 --minimum search len
maxL=5 --maximim search len
rebuildPoint=-0.1 --if LWS score is more negative it will be rebuilded
killPont=-0.1 --if all areas have better score script ends

len=0 --set global var
while true do  --running until cure all places
    for l=minL,maxL do --search pattern
        len=l
        LwsPhD()
    end
end




"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_12509" : "{
 "desc" : "Fixed a bug  dealing with length of bands.
Now with herdsize  maximum limiting."
 "hidden" : "0"
 "mid" : "23759"
 "mrid" : "30807"
 "name" : "CG303 GAB-III V2.5"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "119022"
 "script" : "--[[
Genetic Bands III by Crashguard303

Inspired by cartoon Villain's Script, I created this one, including freezing.
This script also works on not-very-best puzzle-states.

DESCRIPTION for default parameters:

Random Creating:
 It creates a set of clusters (herd). Each cluster has a random set of bands,freezes and a drift value.
 There is a random list, which segments have already been banded or frozen, so it is guaranteed that all are tried.
 If all have been tried, this list is shuffled, all segments are tried again.
 The drift shows, in which directions banding or freezing segments can move.
 (-1 will increase current segment number by, +1 will increase segment number by 1, 0 won't exist)

Then, for this puzzle state, all clusters are tried.
This means:

Pulling:
 Bands and freezes are applied (plus constant bands, if you want), the puzzle is wiggled for one iteration.

Releasing:
 Bands and freezes are removed.
 4 different subroutines similar to blue fuse run.
 They test different clashing-importance shake/wiggle combinations.
The best result of the fuse is stored to the cluster score.

Sorting:
 If all clusters were tried, they are sorted by the scores they created, double score results are moved to the end of the list.
 The best cluster is on top, the worst or and equal cluster is on bottom at the list.

Breeding:
 All clusters from BreedFirst to BreedLast are breeded, first best  with other random clusters, preferring good ones
 The cluster with the most bands is mom, cluster with fewer bands is dad.
 Bands of mom and drift value are copied at first,
 then a random crossover point is generated within the length of dad's bands.
 Bands from 1 to inclusive crossover point from the new cluster are replaced by bands of dad, rest of mom
 The same happens to freezes.

Mutating:
 For each band or freeze:
  A random flag (Drift flag or multiplicator) (either 0 or 1)  is created, depending on mutation probability.
  If this flag is 1, drift value (-1 or +1) is added to the segment index, in other case, the segment index stays the same.
  Band length and strength are randomly changed between an amount of -0.1 to 0.1
  When mutating, all values are checked after they are changed, to guarantee that they don't leave a legal value range.

Inverting:
 For each band or freeze:
  A random flag (inversion flag) (either o or 1) is created, depending on inverting probability.
  If this flag is 1, segment values are inverted, which means multiplying them by -1
  Negative segment values results banding or freezing skip, they are deactivated.
  If a segment has a negative value and is inverted, the value is positive and activated again

Filling:
 The rest of the herd (BreedLast+1 to HerdSize) is replaced by new random clusters, as described in Random Creating.

Restart:
  When new clusters have been breeded or replaced, the recent best puzzle state is loaded.
  and pulling is performed again.

END OF MAIN DESCRIPTION
P.S.: If you find typos, you can keep them ;)
]]--

-- Random Number Generator

-- Author: tlaloc (aka Greg Reddick)

-- This is a substitute for the math.random() and math.randomseed()
-- functions in the lua standard library. If they ever become available
-- this code can be removed and the standard functionality should work with
-- by only prefixing all the function names with 'math.'.


------------------------------------------------------------------------
-- random ([m [, n]])

-- When called without arguments, returns a uniform pseudo-random real number in the
-- range [0,1). When called with an integer number m, math.random returns a uniform
-- pseudo-random integer in the range [1, m]. When called with two integer numbers
-- m and n, math.random returns a uniform pseudo-random integer in the range [m, n].
------------------------------------------------------------------------
-- randomseed (x)

-- Sets x as the "seed" for the pseudo-random generator: equal seeds produce
-- equal sequences of numbers.
------------------------------------------------------------------------
-- getseed ()

-- This is a substitute for the os.time() lua function that is commonly
-- used to seed a random number generator.

-- It generates it from the least significant
-- digits of the current score. So if the score
-- doesn't change, then the number sequence will
-- be the same. However, *any* change to the score
-- will cause a different sequence.
-- If the score is 0, it performas a WiggleAll until a non-zero score
-- is generated, then restore the structure.
------------------------------------------------------------------------

-- This implementation uses the Multiply with Carry random number generator
-- Translated into Lua from the VBScript published at
-- http://www.rlmueller.net/Programs/MWC32.txt

------------------------------------------------------------------------
-- The original script has the following notices:
-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007
-- You have a royalty-free right to use, modify, reproduce, and
-- distribute this script file in any way you find useful, provided that
-- you agree that the copyright owner above has no warranty, obligations,
-- or liability for such use.
------------------------------------------------------------------------

function abs(x)
 local y=x
 if y<0 then y=-y end
 return y
end -- function

function floor(value)
    return value - (value % 1)
end

function getseed()
    local score = abs(get_score(true)+RNDoffset)
    if score == 0 then
        quicksave(9)
        do_global_wiggle_all(1)
        score = abs(get_score(true)+RNDoffset)
        quickload(9)
    end
    local fraction = (score - floor(score)) * 1000
    local least = fraction - floor(fraction)
    local seed = floor(least * 100000)
    print("Random seed is: ",seed)
    return seed
end

-- lngX = 1000 -- Don't needed, as we use getseed
lngC = 48313

function MWC()

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = floor((F2 / H) + F1)

    return lngX
end

function randomseed(x)
    lngX = x
end

function random(m,n)
    local m=m
    local n=n

    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return floor((MWC() / 4294967296) * (n - m + 1)) + m
    end
end

function frandom(m,n,e)
 -- float random, e is number of remainin decimal digits
 local e2=10^e
 return random(m*e2,n*e2)/e2
end -- function

function sgn(x)
 -- Signum function

 if x==nil then
   return nil
  elseif x>0 then
   return 1
  elseif x<-0 then
   return -1
  else
   return x
 end -- if
end -- function

function CutOff(x,y)
 -- Keep only y digits after decimal point from x
 return floor(x*10^y)/10^y
end -- function

BoolString={}
BoolString[true]="In"
BoolString[false]="Ex"

function UseSegIRange(UseList,A,B,StepSize,bool)
 -- In table "UseList", append or remove segment range A to B
 local UseList=UseList
 local A=A -- range start
 local B=B -- range end
 if A>B then A,B=B,A end -- Swap range start and end, if values are not okay
 local StepSize=StepSize
 local bool=bool -- True=append, false=remove

 local k=A
 repeat
  UseList=UseList_AR(UseList,k,bool)
  k=k+StepSize -- increase k by StepSize
 until k>B -- until k exceeds B
 return UseList
end -- function

function UseSegIValues(UseList,field,bool)
 -- In table "UseList", append or remove segments listed in table "field"
 local UseList=UseList
 local field=field  -- table to add
 local bool=bool -- True=append, false=remove

 local k
 if #field>0 then -- If table to add is not empty
   for k=1,#field do -- cycle through all elements from table
    UseList=UseList_AR(UseList,field[k],bool)
   end -- k loop
 end -- if #field
 return UseList
end -- function

function Use_ss(UseList,SSLetter,bool)
 -- In table "UseList", append or remove segments with secondary structure "SSLetter"
 local UseList=UseList
 local SSLetter=SSLetter
 local bool=bool -- True=append, false=remove

 local k
 for k=1,NumSegs do -- Cycle through all segment indices
  if get_ss(k)==SSLetter then -- If current segment index has same ss as given
    UseList=UseList_AR(UseList,k,bool)
  end -- if get_ss
 end -- k loop
 return UseList
end -- function

function Use_aa(UseList,AALetters,bool)
 -- In table "UseList", append or remove segments with amino-acid in table "AALetters"
 local UseList=UseList
 local AALetters=AALetters
 local bool=bool -- add or  remove

 if #AALetters>0 then -- Is there minimum one aa letter given?

  local k
  for k=1,NumSegs do -- Cycle through all segments
   local aa=get_aa(k) -- get current aa of segment index k

   local exit_condition=false
   local l=0
   repeat
    l=l+1 -- Cycle through all given aa letters
    if aa==AALetters[l] then -- If current segment k's aa is equal to AALetters[l]
     UseList=UseList_AR(UseList,k,bool)
     exit_condition=true -- l loop can end here
    end -- if aa
    if l==#AALetters then exit_condition=true end
   until exit_condition==true
  end -- k loop
 end -- if AALetters
 return UseList
end -- function

function Use_distance(UseList,MinDist,MaxDist,MinQuantity,MaxQuantity,bool)
 -- In table "UseList", append or remove segments which have
 -- MinQuantity to MaxQuantity neighbours within distance MinDist to MaxDist
 local MinDist=MinDist
 local MaxDist=MaxDist
 local MinQuantity=MinQuantity
 local MaxQuantity=MaxQuantity
 local bool=bool -- True=append, false=remove

 for k=1, NumSegs do -- Cycle through all segments
  local QCount=0
  for l=1,NumSegs do -- compare index k with all around
   if l~=k then -- Don't count segment itself, only neighbours
    local Distance=get_segment_distance(k,l) -- Measure distance from segment k to segment l
    if Distance>=MinDist then -- If equal or above min distance
     if Distance<=MaxDist then -- If equal or below max distance
      QCount=QCount+1 -- count this segment
     end -- if Distance
    end -- if Distance
   end -- if l
  end -- l loop
  if QCount<=MaxQuantity then -- If count is equal or below max quantity
   if QCount>=MinQuantity then -- If count is equal or above min quantity
    UseList=UseList_AR(UseList,k,bool) -- add or remove from list
   end -- if QCount
  end -- if QCount
 end -- k loop
 return UseList
end -- function

function Use_close_ligand(UseList,MaxDist,bool)
 -- In table "UseList", append or remove segments which have
 -- a spatial distance of MaxDist or closer to ligand.
 local UseList=UseList
 local MaxDist=MaxDist
 local bool=bool -- True=append, false=remove
 local LigandIdx=NumSegs+1 -- Ligand Index

 local k
 for k=1,NumSegs do -- Cycle with k through all segments but not ligand
  local Distance=get_segment_distance(k,LigandIdx) -- Check spatial distance of segment k to ligand
  if Distance<=MaxDist then -- If equal or below MaxDist
   UseList=UseList_AR(UseList,k,bool) -- add or remove from list
  end -- if
 end -- k loop
 return UseList
end -- function

function UseList_AR(UseList,value,bool)
 -- Append value "value" to UseList
 -- or remove all value's out of UseList, depending on bool
 local UseList=UseList
 local value=value
 local bool=bool -- True=append, false=remove
 -- print(BoolString[bool],"cluding segment index ",value)
   if bool==true then
      UseList=UseList_Append(UseList,value)
    else
      UseList=UseList_Remove(UseList,value)
    end -- if bool
 return UseList
end -- function

function UseList_Append(UseList,value)
 -- Adds content of "value" at end of UseList
 local UseList=UseList
 local value=value
 UseList[#UseList+1]=value
 return UseList
end -- function

function UseList_Remove(UseList,value)
 -- Creates new use list "UseList2" out of "UseList", but without all content of "value"
 local UseList=UseList
 local value=value
 local UseList2={} -- Initialize new uselist
 if #UseList>0 then -- if old
  for k=1,#UseList do -- Scan UseList
   if UseList[k]~=value then -- If "value" is not found
    UseList2[#UseList2+1]=UseList[k] -- append this content to new use list
   end -- if UseList
  end -- k loop
 end -- if UseList
 return UseList2
end -- function

function CompactContent(OS,E,AS)
 --[[
 Adds string AS to temporary output string OS and counts number of added AS in E.
 If OS contents 10 elements, line is printed out

 I only had to write this sub because there Lua standard library is not included.
 We neither can do some string manipulation nor use a print command without linebreaks at the moment :/
 ]]--

 local OS=OS -- Temporal string for output
 local AS=AS  -- String to add
 local E=E -- Element counter, how often AS was added

 E=E+1
 if AS<10 then -- Sorry for this, but there are no string operations possible at the moment
   OS=OS.."00"..AS
  elseif AS<100 then
   OS=OS.."0"..AS
  else
   OS=OS..AS
 end -- if AS

 if E<10 then -- If there are not 10 elements per line
   OS=OS.."   " -- add space
  else -- If there are 10 elements per line
   print(OS) -- print line out
   OS="" -- clear output string
   E=0 -- reset element counter
 end -- if E
 return OS,E
end -- function

function CheckUselist(UseList)
 -- If there are fewer than 3 specific segments to work on given, take all
 local UseList=UseList
 if #UseList<=3 then
  print("No or too few specific segments to work on given.")
  print("Banding and freezing will now manipulate all puzzle segments.")
  UseList={}
  local k
  for k=1,NumSegs do -- Cycle through all segments
   UseList[#UseList+1]=k -- extend UseList by 1 and add segment index
  end -- k loop
 end -- if UseList
 print("Segment list is now:")
 local OS="" -- Initialize output string
 local E=0 -- Initialize element counter
 local k
 for k=1,#UseList do
   OS,E=CompactContent(OS,E,UseList[k])
 end -- k
 if E>0 then
  print(OS)
 end
 return UseList
end -- function

function shuffle2(ShuffleProb)
 -- Scrambles segment use list depending on ShuffleProb
 print("Shuffling segment list")

 kend=#UseList-1
 local k
 for k=1,kend do -- Cycle through all UseList entries
  if random()<ShuffleProb then -- If random value<probability
  -- same as: if random_flag(ShuffleProb)==1 then
   local l=random(k+1,#UseList) -- pick random list entry behind k
   UseList[k],UseList[l]=UseList[l],UseList[k] -- swap values of UseList index k with UseList index l
  end -- if random
 end -- k loop
 UsedSegments=0 -- After Shuffling, set list pointer to 0
end

function random_segment()
 -- Gets a random segment index out of UseList which has not been used so far

 UsedSegments=UsedSegments+1 -- Increase UseList pointer
 local Seg_result=UseList[UsedSegments] -- fetch segment index
 if UsedSegments==#UseList then shuffle2(ShuffleProb) end
 -- If this was the last value of UseList, shuffle list and reset pointer

 return Seg_result -- return random segment number
end -- function

function FillHerd(StartAt,EndAt,TimeStamp)
 local StartAt=StartAt -- First cluster index to generate (not cluster slot)
 if StartAt<=HerdSize then
  local EndAt=EndAt -- Last cluster index to generate (not cluster slot)
  local TimeStamp=TimeStamp -- "birth date"
  print("Generating Herd from ",StartAt," to ",EndAt)

  local k2
  for k2=StartAt,EndAt do
   print("Cluster: ",k2)
   local k=ClusterPointer[k2] -- Fetch cluster slot by cluster index
   ClusterScore[k]=0
   ClusterDrift[k]=random_direction() -- Create value -1 or 1

   if k2==1 and Mimic then
     ClusterType[k]="mimic"
    else
     ClusterType[k]="random"
   end -- if k2
   ClusterType[k]=ClusterType[k].."-"..TimeStamp

   if ClusterBands>0 then
   ClusterSegA[k]={}
   ClusterSegB[k]={}
   ClusterLength[k]={}
   ClusterStrength[k]={}

    local l
    for l=1,ClusterBands do
     if puzzle_is_ligand==false then -- If this is no ligand puzzle
       ClusterSegA[k][l]=random_segment() -- get random segment number
      else -- If this is a ligand puzzle
       ClusterSegA[k][l]=NumSegs+1 -- Segment A is always ligand
     end -- if puzzle_is_ligand

     if k2~=1 or Mimic==false then
      if random_flag(InvBProb)==1 then
       ClusterSegA[k][l]=-ClusterSegA[k][l]
      end -- if random_flag
     end -- if k2

     repeat
      ClusterSegB[k][l]=random_segment()
      local Distance=index_distance(ClusterSegA[k][l],ClusterSegB[k][l])
     until Distance>=MID_Game -- Segments must have a minimum index distance

     if k2==1 and Mimic then
       ClusterLength[k][l]=FactorByLength(ClusterSegA[k][l],ClusterSegB[k][l])
      else -- if k2
       ClusterLength[k][l]=frandom(MinBF,MaxBF,6)
     end -- if k2

     if k2==1 and Mimic then
      ClusterStrength[k][l]=MaxBS
      else
       ClusterStrength[k][l]=frandom(MinBS,MaxBS,3)
     end -- if k2

    end  -- l loop
   end -- if ClusterBands

   if ClusterFreezes>0 then
    ClusterFreeze[k]={}
    local l
    for l=1,ClusterFreezes do
     ClusterFreeze[k][l]=random_segment()
     if (k2==1 and Mimic) or random_flag(InvFProb)==1 then
      ClusterFreeze[k][l]=-ClusterFreeze[k][l]
     end -- if random_flag
    end -- l loop
   end -- if
  end -- k loop
 end -- if StartAt
end -- function

function ShowHerd()
 local k2
 local l

 print("Clusters are:")
 for k2=1,HerdSize do
  local k=ClusterPointer[k2]
  print("Cluster:",k2," score:",ClusterScore[k]," drift:",ClusterDrift[k])
  if ClusterBands>0 then
   local l
   for l=1,ClusterBands do
    print("Band ",l,": ",ClusterSegA[k][l]," to ",ClusterSegB[k][l])
   end
  end -- if ClusterBands

  if ClusterFreezes>0 then
   local l
   for l=1,ClusterFreezes do
   print("Freeze ",l,": ",ClusterFreeze[k][l])
   end -- l
  end -- if
 end -- k loop
end -- function

function ShowHerdShort()
 print("Clusters are:")

 local k2
 for k2=1,HerdSize do
  local k=ClusterPointer[k2]
  print("Cluster:",k2,"(",k,") score:",ClusterScore[k])
  print("Drift:",ClusterDrift[k])
 end -- k loop
end -- function

function ShowScoreList()
 local k2
 for k2=1,HerdSize do
  local k=ClusterPointer[k2]
  print("Cluster:",k2,"(",k,") delta:",ClusterScore[k])
 end -- k
end -- function

function SortHerd()
 -- As we use pointers, we only have to swap the cluster "adresses" instead of copying all band/freeze values
 local Finish=HerdSize-1
 local k
 for k=1,Finish do
  local start=k+1
  local l
  for l=start,HerdSize do
   if ClusterScore[ClusterPointer[l]]>ClusterScore[ClusterPointer[k]] then
    -- print("Swapping cluster ",k,"(",ClusterPointer[k],"):",l,"(",ClusterPointer[l],")")
    ClusterPointer[l],ClusterPointer[k]=ClusterPointer[k],ClusterPointer[l]
   end -- if
  end -- l
 end -- k
end -- function

function CreateCrossoverPoint(x)
 -- create random crossover point

  if x==0 then
    return 0
   else -- if x ~=0
    -- return random(0,x) -- create random value between 0 and x
    return random(1,x-1) -- create random value between 1 and x-1
  end -- if x
end -- function

function Breed(TimeStamp)
  -- Copy all clusters to another bank, same name for all cluster tables but with 2 at end
  -- Breed two clusters from bank 2 back to old bank to prevent breeding collision.
  -- If this wouldn't be done, and (for example) cluster 1 and 2 would be breeded to cluster 3,
  -- cluster 3 couldn't be used as breeding source again, as it would be overwritten already.

  local TimeStamp=TimeStamp -- "birth date"

  ClusterScore2={}
  -- ClusterType2={}
  ClusterDrift2={}

  ClusterSegA2={}
  ClusterSegB2={}
  ClusterLength2={}
  ClusterStrength2={}

  ClusterFreeze2={}

   local k
   for k=1,HerdSize do
    ClusterScore2[k]=ClusterScore[k]
    ClusterDrift2[k]=ClusterDrift[k]

    if ClusterBands>0 then
     ClusterSegA2[k]={}
     ClusterSegB2[k]={}
     ClusterLength2[k]={}
     ClusterStrength2[k]={}
     local l
     for l=1,ClusterBands do
       ClusterSegA2[k][l]=ClusterSegA[k][l]
       ClusterSegB2[k][l]=ClusterSegB[k][l]
       ClusterLength2[k][l]=ClusterLength[k][l]
       ClusterStrength2[k][l]=ClusterStrength[k][l]
     end -- l loop
    end -- if ClusterBands

     if ClusterFreezes>0 then
     ClusterFreeze2[k]={}
     local l
     for l=1,ClusterFreezes do
       ClusterFreeze2[k][l]=ClusterFreeze[k][l]
     end -- l loop
    end -- if ClusterFreezes
   end -- k loop

   FitnessOffset=ClusterScore[ClusterPointer[HerdSize]]
   -- Take worst cluster score as fitness offset reference
   -- By subtracting this score offset from each cluster score and adding 1,
   -- it is guaranteed that worst cluster score is always 1, all other scores are better.
   -- This will shift all cluster scores up, if worst cluster score is below 1, so there will be no values<1 for fitness calculation.
   -- It will pull all scores down, if worst cluster score is above 1, to guarantee maximum privilege by fitness.
   -- If all clusters would have similar big score values, they would be choosen equally.
   -- By shifting the scores making the last score be 1, other scores are always x-times higher than 1.

   Fitness=0
   local k
   for k=1,HerdSize do
    ClusterScore2[k]=ClusterScore2[k]-FitnessOffset+1 -- Shift cluster score copy by offset to met condition
   -- We can overwrite this table, because it is only needed for breeding, and it won't affect the original table.
   -- Original score will remain untouched.
    Fitness=Fitness+ClusterScore2[k] -- Calculate fitness by adding all scores (offset included)

   end -- k loop

   local k
   for k=BreedFirst,BreedLast do
    ClusterBreed(k,TimeStamp)
   end -- k loop
end -- function

function Roulette()
 -- Returns a random cluster index (not slot), the better their score, the more often they will appear
 local TValue=random()*(Fitness+1) -- Target fitness value, which will stop the wheel
 local CValue=0 -- Current value, where single cluster points will be added
 local Wheel=random(1,HerdSize) -- Random initial wheel position
 repeat
  Wheel=Wheel+1 -- Spin Wheel
  if Wheel>HerdSize then Wheel=1 end -- If Wheel made a full turn, it starts at 1 again
  CValue=CValue+ClusterScore2[ClusterPointer[Wheel]]
  -- Increase current value by score of cluster at wheel position
 until CValue>TValue
 return Wheel
end -- function

function ClusterBreed(indexClusterB,TimeStamp)
 local indexClusterB=indexClusterB -- Target cluster
 local TimeStamp=TimeStamp -- "birth date"

 local indexClusterA1 -- Source cluster 1
 if Parent1isRoulette==false then
   indexClusterA1=indexClusterB-BreedFirst+1 -- Choose best, starting with 1
  else
   indexClusterA1=Roulette() -- Choose one by fitness roulette, the better the score, the more often it can be chosen
 end -- if Parent1isRoulette

 local indexClusterA2 -- Source cluster 2
 if Parent2isRoulette==true then
   repeat
    indexClusterA2=Roulette() -- Choose one by fitness roulette, the better the score, the more often it can be chosen
   until indexClusterA2~=indexClusterA1 -- clusters must be different
  else
   indexClusterA2=indexClusterA1+1 -- Take next to Parent 1
   if indexClusterA2>HerdSize then indexClusterA2=1 end
 end -- if Parent2isRoulette

 local ClusterB=ClusterPointer[indexClusterB] -- Fetch save slot for target cluster
 local ClusterA1=ClusterPointer[indexClusterA1] -- Fetch load slot for source cluster 1
 local ClusterA2=ClusterPointer[indexClusterA2] -- Fetch load slot for source cluster 2

 print("Breeding ",indexClusterA1,"(",ClusterA1,") and ",indexClusterA2,"(",ClusterA2,") to ",indexClusterB,"(",ClusterB,")")

 ClusterType[ClusterB]="breeded".."-"..TimeStamp

 ClusterDrift[ClusterB]=ClusterDrift2[ClusterA1]

  if ClusterBands>0 then -- We only need to copy if there are any bands
   local CrossoverEnd
   if MultiCrossOver== false then
    CrossoverEnd=CreateCrossoverPoint(ClusterBands) -- Create
    print("Band crossover point: ",CrossoverEnd) -- and show crossover point
   end -- if MultiCrossOver

   ClusterSegA[ClusterB]={}
   ClusterSegB[ClusterB]={}
   ClusterLength[ClusterB]={}
   ClusterStrength[ClusterB]={}

   local BandsChild
   local l
   for l=1,ClusterBands do -- Is crossover point reached?
    if CrossOverCheck(CrossoverEnd,l) then
      BandsChild=ClusterA2 -- Take mom after crossover point
     else
      BandsChild=ClusterA1 -- Take dad until crossover point
    end -- if CrossoverEnd
    ClusterSegA[ClusterB][l]=ClusterSegA2[BandsChild][l]
    ClusterSegB[ClusterB][l]=ClusterSegB2[BandsChild][l]
    ClusterLength[ClusterB][l]=ClusterLength2[BandsChild][l]
    ClusterStrength[ClusterB][l]=ClusterStrength2[BandsChild][l]
   end -- l loop
  end -- if ClusterBands

  if ClusterFreezes>0 then -- We only need to copy if there are any freezes
  local CrossoverEnd
   if MultiCrossOver== false then
    CrossoverEnd=CreateCrossoverPoint(ClusterFreezes) -- Create
    print("Freeze crossover point: ",CrossoverEnd) -- and show crossover point
   end -- if MultiCrossOver

   ClusterFreeze[ClusterB]={}

   local FreezesChild
   local l
   for l=1,ClusterFreezes do -- For all freezes
    if CrossOverCheck(CrossoverEnd,l) then -- Is crossover point reached?
      FreezesChild=ClusterA2 -- Take mom after crossover point
     else
      FreezesChild=ClusterA1 -- Take dad until crossover point
    end -- if CrossoverEnd
    ClusterFreeze[ClusterB][l]=ClusterFreeze2[FreezesChild][l]
   end -- l loop
  end -- if ClusterFreezes

  -- Cluster mutating starts here
  -- Secondary cluster set not needed anymore
  -- Mutation is directly performed on target cluster

  if ClusterBands>0 then
  local l
   for l=1,ClusterBands do
    if puzzle_is_ligand==false then -- only on non-ligand-puzzles mutate segment A
     if random_flag(DriftProb)==1 then
      ClusterSegA[ClusterB][l]=add_drift(ClusterSegA[ClusterB][l],ClusterDrift[ClusterB])
     end -- if random_flag
    end -- if puzzle_is_ligand

    if random_flag(InvBProb)==1 then
     ClusterSegA[ClusterB][l]=-ClusterSegA[ClusterB][l] -- invert
    end -- if random_flag

    repeat
     if random_flag(DriftProb)==1 then
      ClusterSegB[ClusterB][l]=add_drift(ClusterSegB[ClusterB][l],ClusterDrift[ClusterB])
     end -- if random_flag
     local Distance=index_distance(ClusterSegA[ClusterB][l],ClusterSegB[ClusterB][l])
    until Distance>=MID_Game -- Segments must have a minimum index distance

    if random_flag(DriftProb)==1 then -- mutation allowed
     local Change=random_direction()*10^-random(1,3) -- generate random drift
     ClusterLength[ClusterB][l]=ClusterLength[ClusterB][l]+Change -- and add it
     if ClusterLength[ClusterB][l]<MinBF then ClusterLength[ClusterB][l]=ClusterLength[ClusterB][l]-2*Change end
     -- if too small, take opposite drift
     if ClusterLength[ClusterB][l]>MaxBF then ClusterLength[ClusterB][l]=ClusterLength[ClusterB][l]-2*Change end
     -- if too big, take opposite drift
     if ClusterLength[ClusterB][l]<MinBF then ClusterLength[ClusterB][l]=frandom(MinBF,MaxBF,6) end
     -- if still to small, take new random value
     if ClusterLength[ClusterB][l]>MaxBF then ClusterLength[ClusterB][l]=frandom(MinBF,MaxBF,6) end
     -- if still to big, take new random value
    end -- if random_flag

    if random_flag(DriftProb)==1 then
     local Change=random_direction()*10^-random(1,3) -- generate random drift
     ClusterStrength[ClusterB][l]=ClusterStrength[ClusterB][l]+Change
     if ClusterStrength[ClusterB][l]<MinBS then ClusterStrength[ClusterB][l]=ClusterStrength[ClusterB][l]-2*Change end
     if ClusterStrength[ClusterB][l]>MaxBS then ClusterStrength[ClusterB][l]=ClusterStrength[ClusterB][l]-2*Change end
     if ClusterStrength[ClusterB][l]<MinBS then ClusterStrength[ClusterB][l]=frandom(MinBS,MaxBS,3) end
     if ClusterStrength[ClusterB][l]>MaxBS then ClusterStrength[ClusterB][l]=frandom(MinBS,MaxBS,3) end
    end -- if random_flag
   end  -- l loop
  end -- if ClusterBands

  if ClusterFreezes>0 then
   local l
   for l=1,ClusterFreezes do
    if random_flag(DriftProb)==1 then
    ClusterFreeze[ClusterB][l]=add_drift(ClusterFreeze[ClusterB][l],ClusterDrift[ClusterB])
    end -- if random_flag

    if random_flag(InvFProb)==1 then
     ClusterFreeze[ClusterB][l]=-ClusterFreeze[ClusterB][l] -- invert
    end -- if random_flag
   end -- l loop
  end -- if
end -- function

function CrossOverCheck(CrossoverEnd,Pos)
 local CrossoverEnd=CrossoverEnd
 local Pos=Pos

 if MultiCrossOver then
   if random_flag(0.5)==1 then
     return true
    else
     return false
   end -- if random_flag
  else -- if MultiCrossOver is false
   if Pos>CrossoverEnd then
     return true
    else
     return false
   end -- if Pos
 end -- if
end -- function

function random_flag(Prob)
 -- Returns a random value; either 0 or 1, depending on probability Prob
 local Prob=Prob
 if Prob<=0 then
   return 0
  else -- If Prob~=0
   if random()<Prob then
     return 1
    else
     return 0
   end -- if random
 end -- if Prob
end -- function

function random_direction()
 return random_flag(0.5)*2-1
end -- function

function add_drift(Segment,Drift)
 local Seg1=Segment
 local Seg1sgn=sgn(Seg1)
 local Drift=Drift

 local Seg2=Seg1+Drift*Seg1sgn
 local Seg2abs=abs(Seg2)

 if Seg2abs<1 then
   Seg2=NumSegs*Seg1sgn
  elseif Seg2abs>NumSegs then
   Seg2=Seg1sgn
 end -- if Seg2abs
 return Seg2
end -- function

function band_delete_all()
 while get_band_count()>0 do band_delete(1) end
end -- function

function xtool(method,iter,tL2)
  -- unifies score-conditional shake and wiggle into one function
  local OS=""
  local iter=iter
  local tL2=tL2
  if iter>0 then
    OS="max iter:"..iter
  end -- if
  -- print("Method:",method," ",OS," threshold:",tL2)
  local curr_iter=0
  local exit_condition=false
  repeat
   curr_iter=curr_iter+1
   -- print(" Testing with iterations: ",curr_iter)
   local tempScore=get_score(true)
   if method=="s" then
     do_shake(curr_iter)
    elseif method=="wb" then
     do_global_wiggle_backbone(curr_iter)
    elseif method=="ws" then
     do_global_wiggle_sidechains(curr_iter)
    else
     do_global_wiggle_all(curr_iter)
   end -- if method
   local tempScore2=get_score(true)
   local rDelta=(tempScore2-tempScore)/curr_iter
   -- print(" Rel. change: ",rDelta," pts/iteration")
   if curr_iter==iter then exit_condition=true end
   if abs(rDelta)<tL2 then exit_condition=true end
  until exit_condition==true
end -- function

-- Inspired by vertex's blue fuse script
-- You may want to tweak this function

function PinkFuse()
    quicksave(3) -- store state before fuse
     print("Release 1")
     set_behavior_clash_importance(0.1)
     xtool("s",Shakes,ScoreThreshold)
     BestScoreCheck()
      set_behavior_clash_importance(0.7)
      xtool("wa",Wiggles,ScoreThreshold)
      BestScoreCheck()
    FuseEnd()

    quickload(3) -- load state before fuse
     print("Release 2")
     set_behavior_clash_importance(0.3)
     xtool("s",Shakes,ScoreThreshold)
     BestScoreCheck()
      set_behavior_clash_importance(0.6)
      xtool("wa",Wiggles,ScoreThreshold)
      BestScoreCheck()
    FuseEnd()

    quickload(3) -- load state before fuse
     print("Release 3")
     set_behavior_clash_importance(0.5)
     xtool("wa",Wiggles,ScoreThreshold)
     BestScoreCheck()
      set_behavior_clash_importance(1)
      xtool("wa",Wiggles,ScoreThreshold)
      BestScoreCheck()
       set_behavior_clash_importance(0.7)
       xtool("wa",Wiggles,ScoreThreshold)
       BestScoreCheck()
    FuseEnd()

    quickload(3) -- load state before fuse
     print("Release 4")
     set_behavior_clash_importance(0.7)
     xtool("wa",Wiggles,ScoreThreshold)
     BestScoreCheck()
      set_behavior_clash_importance(1)
      xtool("wa",Wiggles,ScoreThreshold)
      BestScoreCheck()
       set_behavior_clash_importance(0.5)
       xtool("wa",Wiggles,ScoreThreshold)
       BestScoreCheck()
    FuseEnd()
end

function FuseEnd()
    -- Fuse try finishing with CI=1
    set_behavior_clash_importance(1)
    xtool("wa",Wiggles,ScoreThreshold)
    xtool("s",Shakes,ScoreThreshold)
    xtool("wa",Wiggles,ScoreThreshold)
    BestScoreCheck()
end -- function

function BestScoreCheck()
   local TempScore=get_score(true)

   if LastBest then
    if TempScore>ACS5 then
     quicksave(5) -- Set best cluster result for this generation
     ACS5=TempScore
     -- print("ACS5 is ",ACS5)
    end -- if TempScore
   end -- if LastBest

    if TempScore>ACS4 then
     quicksave(4) -- Set best cluster result for current cluster
     ACS4=TempScore
    end -- if TempScore

   if TempScore>BestScore then
    -- reset_recent_best()
    BestScore=TempScore
    print("New best total score: ",BestScore)
    BSChange=true
   end -- if
end -- function

function PullDownEqualResults()
 print("Checking for double results...")
 -- Compare all cluster points with next in list
 -- If next has the same score, move this cluster to end.

 local kEnd=HerdSize-1
 local k
 for k=1,kEnd do
  while ClusterScore[ClusterPointer[k]]==ClusterScore[ClusterPointer[k+1]] do
  -- If next has the same score
   ClusterScore[ClusterPointer[k+1]]=ClusterScore[ClusterPointer[HerdSize]]-1
   -- make its score more worse then the baddest cluster
   SortHerd() -- so it is placed at the end when sorting by score
  end -- while ClusterScore
 end -- k
end -- function

function InitializeClusterData()
 ClusterScore={}
 ClusterType={}
 ClusterDrift={}

  ClusterSegA={}
  ClusterSegB={}
  ClusterLength={}
  ClusterStrength={}

  ClusterFreeze={}

 ClusterPointer={}
 local k
 for k=1,HerdSize do
  ClusterPointer[k]=k
 end -- k
end -- function

function PrintStartingTests()
 print()
 local OS=" "
 if Runs==1 then
   OS=OS.."1 run"
  else
   if Runs>1 then
     OS=OS..Runs
    else
     OS=OS.."infinite"
   end -- if
   OS=OS.." runs"
 end -- if
 print("Starting cluster tests for ",OS,"...")
end -- function

function select_close_ligand()
 local LigandSegment=NumSegs+1
 local k
 for k=1,NumSegs do
  if get_segment_distance(k,LigandSegment)<=MutateLigandDistance then
   select_index(k)
   -- print(k," is close enough to ligand for mutating.")
  end -- if get_segment_distance
 end -- k loop
end -- function

function SetRebuildWorst()
 -- Acitvate rebuild worst if forced or condidtions are met
 if RebuildForce==nil then
   --[[
   if BSChange then
     RebuildWorst=false
    else
     RebuildWorst=true
   end -- if BSChange
   ]]--
   RebuildWorst=BSValueCheck()
  else
   RebuildWorst=RebuildForce
 end -- if RebuildForce
end -- function

function BSValueCheck()
 -- Returns true if current generation's best cluster didn't do much
 local ChangeTooSmall=false
 if BSValue>=0 then -- If last generation's best cluster score is better than at generation start
   if BSValue<SCPT then -- but below limit
    ChangeTooSmall=true
   end -- if BSValue
  else -- if BSValue<0  -- If last generation's best cluster score is not better than at generation start
   if BSValue>SCNT then  -- but above limit
    ChangeTooSmall=true
   end -- if BSValue
 end -- if BSValue
 return ChangeTooSmall
end -- function

function SetLSC(LSC)
 -- Changes first cluster to trest if forced or conditions are met
 local LSC=LSC
 if LSCForce==nil then
   if BSChange or BSValueCheck()==false then -- If there was a considerable change
     LSC=1 -- check all clusters again in next generation
    else -- If there was no considerable change
     LSC=LSC+1 -- increase start cluster for this generation (don't test best again)
     if LSC>BreedFirst then LSC=BreedFirst end -- but not further than BreedFirst
   end -- if BSChange
  else -- if LSCForce not nil
   LSC=LSCForce
 end -- if LSCForce
 return LSC
end -- function

function GAB()
 -- quickload(1): Puzzle state at GAB Start
 -- quickload(2): Puzzle state at generation start
 -- quickload(3): Puzzle state at fuse start
 -- quickload(4): Best result for current cluster
 -- quickload(5): Best result for current generation

 print("Starting GAB-III...")
 randomseed(getseed())  -- initialize random seed

 UseList=CheckUselist(UseList)
 shuffle2(ShuffleProb) -- Shuffle UseList and reset pointer

 InitializeClusterData()

 FillHerd(1,HerdSize,1) -- From 1 to HerdSize

 -- ShowHerd()

 band_delete_all() -- clean bands
 do_unfreeze_all() -- and freezes
 set_behavior_clash_importance(1)
 reset_recent_best() -- before storing
 select_all()
 xtool("s",2,1) -- adjust sidechains
 deselect_all()
 restore_recent_best()

 quicksave(1) -- Save initial puzzle state
 BestScore=get_score(true) -- initialize best score (ACS1)

 PrintStartingTests(Runs)

 local LSC=1
 CRun=0 -- set CRun to 0, counting up after each cluster generation
 repeat
  CRun=CRun+1 -- Increase current run value
  if CRun>1 then
    if RecentHybrid>0 then -- If RecentHybrid>0, tweak RecentUse
     if (CRun-1)%RecentHybrid==0 then -- Each RecentHybrid runs
       RecentUse=true -- use recent best
      else -- If not
       RecentUse=false -- don't use recent best
     end -- if CRun
    end -- if RecentHybrid
    if LastBest==false then
      if RecentUse then
        print("Loaded recent best.")
        restore_recent_best() -- Load best result so far
       else
        print("Loaded initial state.")
        quickload(1) -- Load initial state
      end -- if RecentUse
     else -- if LastBest is true
      print("Loaded last generation's best.")
      quickload(5) -- Load best cluster result of last generation
    end -- if LastBest
    SetRebuildWorst()
    LSC=SetLSC(LSC)
  end -- if CRun

  if RebuildWorstGen then -- If rebuild is requestet at geneartion start
   rebuild_worst() -- do it
  end

  BSChange=false -- Reset improvement information

  quicksave(2) -- Set this state as start state for current generation
  ACS2=get_score(true) -- Get score at start for this generation
  print()
  print("Score now: ",ACS2)

  local k2
  for k2=LSC,HerdSize do
   local k=ClusterPointer[k2] -- fetch content of cluster slot from pointer
   print()
   print("Gen.:",CRun," cluster:",k2,"(",k,")/",HerdSize," drift:",ClusterDrift[k]," type:",ClusterType[k])

   if k2>LSC then
      -- print("Loaded Quicksave 1.")
      quickload(2)
   end -- if k2

   band_delete_all() -- remove all bands, because recent best can contain some
   do_unfreeze_all() -- and freezing to apply others

   if ClusterBands>0 then
    local l
    for l=1,ClusterBands do
     if ClusterSegA[k][l]>0 then
       band_add_segment_segment(ClusterSegA[k][l],ClusterSegB[k][l])
       local TempBandCount=get_band_count()
       -- fetch current band number index to make setting its length and strength possible

       local Length=LengthWithFactor(ClusterSegA[k][l],ClusterSegB[k][l],ClusterLength[k][l])

       local BandDisabled=false
       if Length>MaxBL_Game then
         Length=MaxBL_Game
         band_disable(TempBandCount)
         BandDisabled=true
        elseif Length<MinBL_Game then
         Length=MinBL_Game
         band_disable(TempBandCount)
       end

       local Length1R=CutOff(ClusterLength[k][l],3) -- Cut after 3 decimal digits before displaying
       local Length2R=CutOff(Length,3) -- Cut after 3 decimal digits before displaying

       local OS="Band "..l..": "..ClusterSegA[k][l]..":"..ClusterSegB[k][l]
       OS=OS.." L:"..Length1R.."="..Length2R
       if ShowBF then
        print(OS," S:",ClusterStrength[k][l])
       end -- if
       if BandDisabled then
        print("Band disabled because of length limit ",MaxBL_Game)
       end -- if BandDisabled

       band_set_length(TempBandCount,Length) -- Set current band length
       band_set_strength(TempBandCount,ClusterStrength[k][l]) -- Set current band strength

      else -- if ClusterSegA[k][l] is <0, which means band is deactivated
      if ShowBF then
       print("Band ",l,": off")
      end -- if
     end -- if ClusterSegA
    end -- l loop
   end -- if ClusterBands

   if RebuildWorstGen==false then rebuild_worst() end

   deselect_all() -- Before freezing, so we can select segments to freeze

   if ClusterFreezes>0 then -- if there are segments to freeze
    local l
    for l=1,ClusterFreezes do  -- select all segments to freeze
     if ClusterFreeze[k][l]>0 then
       if ShowBF then
        print("Freeze ",l,": ",ClusterFreeze[k][l])
       end -- if
       select_index(ClusterFreeze[k][l])
      else
      if ShowBF then
       print("Freeze ",l,": off")
      end -- if
     end -- if ClusterFreez
    end -- l loop
   end -- if ClusterFreezes

   if puzzle_is_ligand then -- if this is a ligand puzzle
     select_index(NumSegs+1) --  select ligand for freezing
     do_freeze(true,true) -- freeze backbone and sidechains
    else -- if this is not a ligand puzzle
      if ClusterFreezes>0 then -- but there are segments to freeze
       do_freeze(true,false) -- freeze backbone only
      end -- if ClusterFreezes
   end -- if puzzle_is_ligand

   if ConstantBands==true then
    add_constant_bands() -- You can add some bands or freezes in this routine, which should appear each try
   end -- if

   print("Pulling...")
   set_behavior_clash_importance(CI_pull)
   select_all() -- Select all segments to wiggle
   do_global_wiggle_all(PWiggles) -- Just a small pull

   band_delete_all() -- clean up bands before saving
   do_unfreeze_all() -- clean up freezes before saving

   if LastBest then -- If LastBest Mode
    if k2==LSC then -- and this is the first try of current generation
     ACS5=get_score(true)
     -- initialize current generation best score
    end -- if k2
   end -- if LastBest

   quicksave(4) -- Initialize this state as reference for current cluster best score
   ACS4=get_score(true) -- and initialize current cluster best score
   BestScoreCheck() -- raise BestScore ACS4, if result is better

   xMutate(Mutating1) -- including BestScoreCheck

   Release() -- including Fuse and BestScoreCheck

   xMutate(Mutating2) -- including BestScoreCheck

   ClusterScore[k]=ACS4-ACS2 -- Store best score minus start score for this try as cluster score
   print("Difference to start: ",ClusterScore[k])
  end -- k loop, take next cluster

  print()
  print("Sorting Cluster list by score...")
  SortHerd() -- Sort herd by score difference
  ShowScoreList()

  BSValue=ClusterScore[ClusterPointer[1]] -- Fetch best score difference

  PullDownEqualResults() -- Move duplicate results to end of herd

  Breed(CRun+1) -- Range: BreedFirst to BreedLast

  if BSValueCheck() or BSValue<=0 then -- If generation's best cluster has low or negative score difference
   print("No or few improvement for this generation.")
   if HerdSize<IncHerdSize then -- and herd size increasing is allowed
    print("Increasing herd size.")
    local k
    for k=1,2 do -- Increase herd size by 2 individuums
     HerdSize=HerdSize+1 -- Increase herd size
     ClusterPointer[HerdSize]=HerdSize -- and number of cluster save slots; set them to its own value
    end -- k loop
    BreedLast=BreedLast+1 -- Increase breed slots by 1
   end -- if incHerdSize
  end -- if BSChange

  FillHerd(BreedLast+1,HerdSize,CRun+1)
  -- generate random clustes behind breeded ones
  -- ShowHerdShort()

 until CRun==Runs
end -- function GAB

function FactorByLength(SegA,SegB)
 -- Fetch factor for band length by dividing (spatial distance from segment A to B minus minmum allowed band length)
 -- by (maximum allowed band length minus minimum allowed band length)

 local SegA=SegA
 local SegB=SegB

 return (get_segment_distance(SegA,SegB)-MinBL_Game)/(SpatMax(SegA,SegB)-MinBL_Game)
end -- function

function LengthWithFactor(SegA,SegB,Factor)
 -- Apply length factor to range between minimum allowed band length and maximum allowed band length
 -- Factor=0 results minimum allowed band length
 -- Factor=1 results maximum allowed band length

 local SegA=SegA
 local SegB=SegB
 local Factor=Factor

 return Factor*(SpatMax(SegA,SegB)-MinBL_Game)+MinBL_Game
end -- function

function SpatMax(SegA,SegB)
 -- Fetch maximum allowed band length
 -- If this is a ligand puzzle, fetch it by MaxBL_Game
 -- If this is no ligand puzzle, fetch it by segment index distance
   -- shorter index distances result shorter maximum lengths to prevent excessive stretching

 local SegA=SegA
 local SegB=SegB

 local TIDistance

 if puzzle_is_ligand==false then -- if this is no ligand puzzle
    TIDistance=3.8*index_distance(SegA,SegB)+.1 -- fetch segment index distance and multiply it with 3.8
    -- take this maximum length value depending on index distance to prevent excessive puzzle stretching
    if TIDistance>MaxBL_Game then TIDistance=MaxBL_Game end
	-- if the calculated value exceeds, set it to maximum
   else -- if this is a ligand puzzle
    TIDistance=MaxBL_Game -- default value for maximum band length
 end -- if puzzle_is_ligand

 return TIDistance
end -- function

function index_distance(SegA,SegB)
 -- Fetch segment index distance
 
 local SegA=SegA
 local SegB=SegB
 
 return abs(abs(SegA)-SegB)
end -- function

function Release()
  if Releasing then
    -- print("Score after pulling: ",ACS4)
    print("Releasing...")
    quickload(4) -- load best cluster result so far
    select_all()
    if Fuse then
      PinkFuse() -- quicksave(4), raise BestScore and ACS4, if result is better
     else
      set_behavior_clash_importance(1)
      do_shake(1)
      do_global_wiggle_all(12)
      BestScoreCheck() -- quicksave(4), raise BestScore and ACS4, if result is better
    end -- if fuse
   end -- if Releasing
end -- function

function rebuild_worst()
 if RebuildWorst then
  print("Rebuilding worst...")
  deselect_all()
  local WorstScore
  local SegmentIndex
  local k
  for k=1,NumSegs do
   local SegmentScore=get_segment_score(k)
   if k==1 or SegmentScore<WorstScore then
    WorstScore=SegmentScore
    SegmentIndex=k
   end -- if SegmentScore
  end -- k
  local SegA=SegmentIndex-RebuildRange
  local SegB=SegmentIndex+RebuildRange
  while SegA<1 do
   SegA=SegA+1
   SegB=SegB+1
  end -- while SegA
  while SegB>NumSegs do
   SegA=SegA-1
   SegB=SegB-1
  end -- while SegA
  for k=SegA,SegB do
   select_index(k)
  end -- k loop
  do_local_rebuild(RebuildIter)
 end -- if RebuildWorst
end -- function

function xMutate(Mutating)
   if Mutating then
    quickload(4) -- load best result for this cluster so far
    print("Mutating...")
    if puzzle_is_ligand then
      deselect_all() -- clear selection
      select_close_ligand() -- select all segments close as MutateLigandDistance or less to ligand
     else
      select_all()
    end -- if puzzle_is_ligand
    do_mutate(1)
    BestScoreCheck() -- Check if it made an improvement
   end -- if Mutating
end -- function

function detect_ligand(flag)
 --[[
 ligand puzzle detection
 normally, segments have a secondary structure of "E", "H" or "L"
 and they always have a spatial distance of about 3.75 to 3.85 to their next index neighbour.
 a ligand is more far away.

 this function should respond true if this is a ligand puzzle, and false if it is not.
 if flag is nil, ligand auto-detection is enabled, distance of last two segments is checked
 if flag is not nil, ligand auto-detection is disabled, result is flag

 It also returns the last segment index which is no ligand
 ]]--

 local flag=flag

 local LastPos=get_segment_count() -- fetch very last segment index number

 if flag==nil then -- Only if flag is nil, detect if there is a ligand and change flag
   print("Detecting if there is a ligand.")
   local ss=get_ss(LastPos)
   flag=not(ss=="L" or ss=="H" or ss=="E" )
   -- if last segment's ss is neither "l" nor "h" nor "e"
   flag=flag or (get_segment_distance(LastPos-1,LastPos)>=3.9)
   -- or distance to second last segment is bigger or equal than 3.9
 end -- if

 local os="This should be "
 if flag then
   os=os.."a"
   LastPos=LastPos-1
  else
   os=os.."no"
 end -- if flag
 print(os," ligand puzzle.")

 return flag,LastPos
end -- function

function create_UseList(flag)
 -- Creates segment use list depending on which puzzle-type is there

 local flag=flag

 UseList={}
                      -- Initialize list of segments to use
                      -- UseList extensions (true) are applied to list, so multiple selected segments will appear more often
 if flag==false then -- If this is no ligand puzzle
   UseList=UseSegIRange(UseList,1,NumSegs,1,true)
                      -- Set every segment index from 1 to puzzle size as bandable
   UseList=Use_distance(UseList,0,8,10,1200,false)
                      -- Consider all segments which have min 10 to max 1200 neighbours
                      -- over a distance of 0 to 8 as non-solitary and remove them from list
   UseList=UseSegIRange(UseList,1,NumSegs,1,true)
                      -- Add a complete segment set again to make sure that distance check didn't erase all
   UseList=Use_ss(UseList,"L",true)
                      -- Add segments with this secondary structure
                        -- "L"=loop
                        -- "H"=helix
                        -- "E"=sheet
   -- UseList=UseSegIRange(UseList,1,NumSegs,2,false)
                      -- Set every 2nd segment index between 1 to puzzle size as not bandable, example
   -- UseList=UseSegIValues(UseList,{1;3;9},true)
                      -- Include these single segments as bandable, example
   -- UseList=UseSegIValues(UseList,{2;5;10},false)
                      -- Exclude these single segments as bandable, example
   -- UseList=Use_aa(UseList,{"g";"a"},true)
                      -- Set this amino acid as bandable, example
  else -- If this is a ligand puzzle
   UseList=Use_close_ligand(UseList,20,true)
                      -- Set segments which have a maximum spatial distance of 20 to ligand as bandable
 end -- if flag
end -- function

function LastBandLengthStrength(Length,Strength)
 -- sets length and strength of the very last band to default values
 local TempBandCount=get_band_count()
 band_set_length(TempBandCount,Length)
 band_set_strength(TempBandCount,Strength)
end -- function

function add_constant_bands()
 -- Add some constant bands to fix parts of the puzzle here
 -- and/or freeze some parts

 band_add_segment_segment(40,15)
 LastBandLengthStrength(5,0.1)

 --[[
 deselect_all()
 for k=10,11 do
  select_index(k)
 end -- k
 do_freeze(true,false)
 ]]--
end -- function

 Runs=0
                     -- Number of runs (generations), integer value
                       -- Set to <1 to run infinitely
 puzzle_is_ligand,NumSegs=detect_ligand()
                     -- puzzle_is_ligand: Ligand flag, boolean value
                       -- true for ligand puzzle
                       -- false for non-ligand-puzzle
                     -- NumSegs: Last segment index which is no ligand, integer value
                     -- detect_ligand(): Ligand auto detection.
                       -- If it fails, use detect_ligand(true) to declare that this is a ligand puzzle
                       -- and detect_ligand(false) to declare that this is a no ligand puzzle
 create_UseList(puzzle_is_ligand)
                      -- Initialize segment working list
                      -- Depending on puzzle type
 MID_Game=3
                       -- Minimum index distance of segment indices, integer value >=2
                       -- As the game doesn't allow banding the segments with themselves or the nearest neighbour,
                       -- This value is needed to prevent game errors,
                       -- but you can also use it to prevent sharp backbone turns.
 MinBL_Game=3.8
                       -- Minimum band length, integer value >=0 and <=MaxBL_Game
                       -- Opposite of MaxBL_Game
                       -- Prevents bands getting too short
 MaxBL_Game=20
                       -- Maximum band length, integer value <=20
                       -- Another restriction by the game itself.
                       -- This value is needed to prevent game errors.
 BreedFirst=3
                      -- First cluster to change by breeding, integer value
                      -- All clusters before this index will be kept as good solution and as potential parents for breeding new solutions
                        -- Setting this to 1 is not a good idea, because you will loose good clusters
 BreedLast=5
                      -- Last cluster to change by breeding, integer value >=BreedFirst and <=HerdSize
                        -- Will be increased if no better solution was found
 HerdSize=8
                      -- Number of clusters, integer value >=BreedLast
                        -- Will be increased if no better solution was found
 IncHerdSize=16
                      -- Increase herdsize, integer value
	\	\	\	\	    -- Allows increasing the herdsize if no better solution was found (will generate more clusters)
                        -- if >HerdSize, allow increasing herdsize until this amount
	\	\	\	\	\	-- if <=HerdSize, no increasing
 ShowBF=true
                      -- Shows band and freeze details, boolean value
                        -- if true (default), segments which are banded or frozen are shown by text
 ClusterBands=4
                      -- Maximum Bands to create per cluster, integer value >=0
 ClusterFreezes=3
                      -- Maximum segments to freeze by random, integer value >=0
 MinBS=0.8
                      -- Minimum strength per (random chosen) band, float value
                        -- Use decimal number between .1 and 10
 MaxBS=1.2
                      -- Minimum strength per (random chosen) band, float value
                        -- Use decimal number between .1 and 10 and >=MinBS
 MinBF=0
                      -- Minimum length factor per random band, float value >=0 <=1
 MaxBF=1
                      -- Maximum length factor per random band, float value >MinBF <=1
 Shakes=1
                      -- Number of iterations for fuse-shake, integer value
 Wiggles=4
                      -- Number of iterations for fuse-wiggle, integer value
 PWiggles=1
                      -- Number of iterations for pulling, integer value
 CI_pull=1
                      -- Clashing importance for pulling, float value >=0 and <=1
                        -- Default is 1
                        -- Reduce this to make pulling more drastic
 Releasing=true
                      -- Release flag, boolean value
                        -- true (default)= After pulling, releasing is performed.
                        -- false= releasing is skipped
 Fuse=true
                      -- Fuse flag, boolean value
                        -- true  (default)= After pulling, Fuse is performed.
                        -- false= after pulling, just a shake(1) and wiggle_all(12) with CI=1 is performed
 MutateLigandDistance=15
                      -- Radius length for selection sphere around ligand, where mutating is performed.
                        -- Selects only segments which are this or more close to the ligand for mutating.
 ScoreThreshold=0.5
                      -- Threshold value for shake and wiggles, float value >=0
                        -- This won't repeat some w/s, if absolute score change per itertation is below this
 MultiCrossOver=true
                      -- Multi crossover flag, boolean value
                        -- false (default)= One crossover point for each breeding is generated.
                        -- true= Each gene can be from mom or dad
 Parent1isRoulette=true
                      -- Roulette flag for breeding parent 1, boolean value
                        -- if false (default), parent is cluster with best score and downwards
                          -- use this to force good clusters for breeding
                        -- if true, parent is chosen by fitness roulette
 Parent2isRoulette=true
                      -- Roulette flag for breeding parent 2, boolean value
                      -- if true (default), parent is chosen by fitness roulette
                      -- if false, parent is next to parent 1
                        -- use this to force good clusters for breeding
 DriftProb=0.3
                      -- band drift (cluster mutation) probability, float value >=0 and <1
                        -- Probability, if drift is added or not
 InvBProb=0.2
                      -- Inverting (deactivating/reactivating) probability for bands, float value >=0 and <1
                        -- Makes inversion happen depending on this probability value
 InvFProb=0.3
                      -- Inverting (deactivating/reactivating) probability for freezes, float value >=0 and <1
                        -- Makes inversion happen depending on this probability value
 ShuffleProb=0.9
                      -- Shuffle rate, float value >=0 and <=1
                        -- Used to scramble random segment list, where bands are applied
                        -- 0 lets the list be as it is
                        -- 1 swaps all list entries with a random one behind them in list
 RecentUse=true
                        -- recent best flag, boolean value
                          -- true= recent best is used for each generation
                          -- false= initial state is used for each generation
                            -- prevents getting stuck on local maximum (recommended for endgame)
                          -- If using RecentHybrid or LastBest, this value is ignored
 RecentHybrid=0
                        -- Hybrid behaviour between RecentUse=false/true, integer value >=0
                          -- If ==0, regular behaviour as set in RecentUse
                          -- If >0, recent best is used only all RecentHybrid's generations
                           -- (counting from generation 2)
                          -- 1 would have the same effect as RecentUse=true
                          -- I recommend values>=2 when using it
 LastBest=false
                        -- Flag for using best cluster of current generation, boolean value
                        -- Default is false
                        -- If true, neither recent best nor initial puzzle state are loaded, but best result of current generation,
                        -- allowing unimproving the puzzle to get out of local maximum
                        -- Try this, you are really stuck on a puzzle.
 LSCForce=nil
                       -- Loop start cluster force flag, integer value
                         -- If nil (default), best clusters will only be tested again
                           -- if there was an improvement in last generation
                         -- If >0, start at this cluster after first generation
                           -- If 1, test all clusters again (also good ones)
                           -- If BreedFirst, test only new generated clusters
 SCPT=1
                        -- Score change positive tolerance, float value >=0
                          -- Activates rebuild (if allowed)
                          -- if current generation start score and best cluster score difference
                          -- is below this positive value (not good enough)
 SCNT=-10
                        -- Score change negative tolerance, float value <=0
                          -- Activates rebuild (if allowed)
                          -- if current generation start score and best cluster score difference
                          -- is above this negative value (not bad enough)
 RebuildWorstGen=true
                        -- Rebuild worst at generation start flag, boolean value
                          -- If true, rebuild worst is executed once for current generation
                          -- If false, rebuild worst is executed for each cluster (not recommended)
                          -- If nil, rebuild is never executed.
 RebuildWorst=false
                        -- Rebuild flag at script start, boolean value
                          -- If true,
                          -- rebuild is executed in first generation
 RebuildForce=nil
                        -- Force RebuildWorst, boolean value
                        -- Sets how RebuildWorst is changed.
                          -- If nil (default), worst segment is only rebuilt
                            -- if there was no improvement in last generation
                          -- If true, worst segment is always rebuilt before pulling
                          -- If false, worst segment is never rebuilt before pulling
 RebuildRange=2
                        -- Rebuild range, integer value>=1
                          -- For example, if 1 and worst segment is 3, segments from 2 to 4 are rebuilt.
                          -- if 2 and worst segment is 3, segments from 1 to 5 are rebuilt.
 RebuildIter=1
                      -- Iterations for rebuild worst, integer value>0
 Mutating1=puzzle_is_ligand
                      -- if true, puzzle segment mutating after pulling is performed
 Mutating2=false
                      -- if true, puzzle segment mutating after releasing is performed
 ConstantBands=false
                      -- Add constant bands flag, boolean value
                        -- if true, adds user-defined bands and freezes of add_constant_bands function above
                        -- before regular test-cluster is applied
 Mimic=false
                        -- Mimic flag, boolean value
                          -- if true, first cluster tries to imitate initial puzzle state
 RNDoffset=0
                      -- Random offset, float value >=0 and <1
                        -- As the puzzle score are a reference for the "random" bands and freezes to create,
                        -- you can change this value to change the seed
                        -- useful if you want to restart with other bands, but at the same score.
GAB()"
 "type" : "script"
 "uses" : "1"
 "ver" : "0.3"
}
"
 "_recipe_12541" : "{
 "desc" : "Finding and bruteforce mutating all mutable segmnets found in random order. Options at end."
 "hidden" : "1"
 "mid" : "11391"
 "mrid" : "29223"
 "name" : "Rav3n_pl Mutate Combo 1.2.1"
 "parent" : "10669"
 "parent_mrid" : "12377"
 "player_id" : "174969"
 "script" : "--[[
Mutater - Combo
2 ways of mutate:
random: 
- randomly choose sphere around mutable segment and mutate in random CI
bruteforce:
- check all possible aas for single sgmnt

At start it search for mutable segments.
B4 every loop it shuffles order of sgmnts to mutate.
]]--

--[[
Tlaloc`s math library
------------------------------------------------------------------------
The original random script this was ported from has the following notices:
Copyright (c) 2007 Richard L. Mueller
Hilltop Lab web site - http://www.rlmueller.net
Version 1.0 - January 2, 2007
You have a royalty-free right to use, modify, reproduce, and
distribute this script file in any way you find useful, provided that
you agree that the copyright owner above has no warranty, obligations,
or liability for such use.
------------------------------------------------------------------------
]]--
local lngX = 1000
local lngC = 48313

local function _MWC()
    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296
    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
 
    lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)
    lngX = lngX - (math.floor(lngX / M) * M)
    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        return -value
    else
        return value
    end
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(s)
    if s==nil then 
        s=math.abs(get_score(true))
        s=s%0.001
        s=1/s
        while s<10000000 do s=s*10 end
        s=s-s%1
    end
    lngX = s
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

--[[ End math library ]]--
function Score()--return score, negative too
    return get_score(true)
end 

math.randomseed() 

P = print --a short

segCount = get_segment_count() --always the same 

mutable={} --table to store mutable sgmnts


function down(x)--cut all after comma
    return x-x%1
end
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end

 -- A random int between [1, high]
function RandomInt(high)
    return math.random(high)
end

function ShuffleTable(tab) --randomize order of elements
    local cnt=#tab 
    for i=1,cnt do
        local r=RandomInt(cnt)
        tab[i],tab[r]=tab[r],tab[i]
    end
    return tab
end

function Wiggle(how, iters, minppi) --score conditioned recursive wiggle/shake
    if how==nil then how="wa" end
    if iters==nil then iters=6 end
    if minppi==nil then minppi=0.1 end
    if iters>0 then
        iters=iters-1
        local sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2) 
        end
        local ep = Score()
        local ig=ep-sp
        if ig > minppi then return Wiggle(how, iters, minppi) end --to learn recursion you have to learn recursion ;]
    end
end

function mut(ci)
    local done=false
    set_behavior_clash_importance(ci)
    local i=1
    repeat
        local s=Score()
        do_mutate(i)
        if Score()~=s then done=true
        else i=i+1 end
        if i>2 then done=true end
    until done
    set_behavior_clash_importance(1)
end

function Aftermut(sg)
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    select_all()
    set_behavior_clash_importance(1)
    Wiggle()
	if sg~=nil then
	\	SelectSphere(sg,12)
	end
    Wiggle("s",1)
	select_all()
    Wiggle()
    deselect_all()    
end

function FindMutable() -- fsl.FindMutableSegments ()
  print("Finding Mutable Segments -- don't kill during this routine")
  quicksave(10)
  local mutable={}
  local isG={}
  local i
  select_all()
  replace_aa('g')                  -- all mutable segments are set to 'g'
  for i=1,segCount do
    if get_aa(i) == 'g' then        -- find the 'g' segments
      isG[#isG + 1] = i
    end
  end
  replace_aa('q')                  -- all mutable segments are set to 'q'
  for j=1,#isG do
    i=isG[j]
    if get_aa(i) == 'q' then        -- this segment is mutable
      mutable[#mutable + 1] = i
    end
  end
  quickload(10)
  print(#mutable," mutables found")
  return mutable
end

function SelectSphere(sg, radius)
    deselect_all()
    for i=1, segCount do
        if get_segment_distance(sg,i)<radius then select_index(i) end
    end
end
bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        P("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end

function mutate(i,small,large,ci)
    sc=Score()
    SelectSphere(i, small)
    mut(ci)
    if math.abs(Score()-sc)>1 then
        SelectSphere(i, large)
        Aftermut()
    else
        select_all()
        Wiggle()
    end
    local g=Score()-sc
    if g>0 then
        SaveBest()
    elseif g<0 then
        quickload(3)
    end        
end

function MutateRandom(loops)
    local ss=Score()
    deselect_all()
    reset_recent_best()
    quicksave(3)
    for i=1,loops do
        local ls=Score()
        mutable=ShuffleTable(mutable)
        local cnt=#mutable
        for s=1,cnt do
            sg=mutable[s]--segment
            ci=RandomInt(101)--clash importance
            ci=ci/100
            if ci>1 then ci=1 end--not over 1
            sm=RandomInt(7)--small sphere for mutate
            sb=sm+1+RandomInt(3)--big sphere for shakeout
            P("Loop ",i," of ",loops," ;sg ",s," of ",cnt," ;score: ",round(Score()))
            P("In sgmnt ",sg," spheres ",sm,"-",sb," on CI: ",ci)
            mutate(sg,sm,sb,ci)
        end
        P("Loop gain: ",round(Score()-ls))
    end
    P("Total random mutate gain: ",round(Score()-ss))
end

function Brute(sg)
    local sco=Score()
    deselect_all()
    P("Mutating segment ",sg)
    quicksave(4)
    local aa1=get_aa(sg)
    for i=1,#chains do
        local c1=Score()
        deselect_all()
        select_index(sg)
        replace_aa(chains[i])
        SelectSphere(sg,9)
        Aftermut(sg)
        if Score()<c1 then
            quickload(4)
        else
            quicksave(4)
        end
    end
    quickload(4)
    local aa2=get_aa(sg)
    local m=false
    if aa1==aa2 then
        P("Not changed.")
    else
        P("Segment mutated.")
        m=true
    end
    SaveBest()
    return m
end

function MutateBrute(loops)
    set_behavior_clash_importance(1)
    local ss=Score()
    for l=1, loops do
        local ls=Score()
        P("Mutate loop started at score: ",round(Score()))
        ShuffleTable(mutable)
        local muted=false
        for i=1,#mutable do
            local m=Brute(mutable[i])
            if m==true then muted=true end
            P("Loop ",l," ",#mutable-i," left. Current score: ",round(Score()))
        end
        P("Loop gain: ",round(Score()-ls))
        if muted==false then
            P("Not muted any single one! Breaking!")
            break
        end
    end
    P("Bruteforce mutate completed. Gain: ",round(Score()-ss))
end

chains={"G";"A";"V";"C";"P";"T";"S";"I";"L";"N";"D";"M";"H";"Q";"E";"F";"K";"Y";"R";"W"}--all of them
--chains={"G";"A";"V";"C";"P";"T";"S";"I";"L";"N";"M";"Q";"F";"Y";"W"} --desired for TNT: no ASP, GLU, ARG, LYS, HIS

lingard=false --true --set to false in non-lingard puzzles

mutable=FindMutable()

MutateRandom(3) --3 times all auto
MutateBrute(30) --up to 30 times all bruteforce



"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_12545" : "{
 "desc" : "Performing  Local Wiggle Sequences by patterns.  Start and end segment can be changed. After positive  wiggle(1) test it makes more lws (20 by default)."
 "hidden" : "1"
 "mid" : "14605"
 "mrid" : "29034"
 "name" : "Worm LWS v2"
 "parent" : "13148"
 "parent_mrid" : "15122"
 "player_id" : "174969"
 "script" : "--[[
Worm LWS v2
Performin "worm" LWS by given patterns, no freezing
]]--

p=print --"quicker" print ;]
segCount=get_segment_count()

local function Score() --Score of puzzle
    return get_score(true)
end
function round(x)
    return x-x%0.001
end

function AllLoop()
    local ok=false
    for i=1, segCount do
        local ss=get_ss(i)
        if ss~="L" then 
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end

function lw()
    local s=Score()
    do_local_wiggle(1)
    if Score()-s>0 then
        do_local_wiggle(bigLw)
    end
    restore_recent_best() --sometimes wiggle(20) makes worse!!!
end

function Worm()
    if sEnd==nil then sEnd=segCount end
    AllLoop()
    reset_recent_best()
    set_behavior_clash_importance(1)
    quicksave(3)
    local ss=Score()
    for w=1,#pattern do
        len=pattern[w]
        local sw=Score()
        p("Starting Worm of len ",len,", score: ",round(Score()))
        for s=sStart,sEnd-len+1 do
            deselect_all()
            select_index_range(s,s+len-1)
            lw()
        end
        p("Pattern gain: ",round(Score()-sw))
        quicksave(3)
    end
    deselect_all()
    load_structure()
    p("Total Worm gain: ",round(Score()-ss))
end

pattern={2,5,11,3,13,4,7,1,6} --how many segments at once to LWS
sStart=1 --from segment
sEnd=nil --to segment, nil=end of it
bigLw=20 --do local_wiggle() that many times if positive lw 1 test

Worm()





"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_12558" : "{
 "desc" : "Pushes away segment using few bands. Then stabilise. Now pushing direction is reandomized. v2-now it pulls after pushing"
 "hidden" : "0"
 "mid" : "16088"
 "mrid" : "28944"
 "name" : "Rav3n_pl Push v2.1 Fast"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "174969"
 "script" : "--[[
Push v2
randomly pushes then pulls one segment
]]--


p = print --a short
segmentCount =  get_segment_count()
function Score()--return score, negative too
    return get_score(true)
end 

function Wiggle(how, iters, minppi) --score conditioned recursive wiggle/shake
    if how==nil then how="wa" end
    if iters==nil then     iters=3 end
    if minppi==nil then minppi=0.1 end
    if "how"=="s" then iters=1 end
    if iters>0 then
        iters=iters-1
        local sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2) 
        end
        local ep = Score()
        local ig=ep-sp
        if ig > minppi then Wiggle(how, iters, minppi) end --to learn recursion you have to learn recursion ;]
    end
end
function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    reset_recent_best()
    quicksave(4) -- store state before fuse
    Fuze1(0.1,0.7)
    quickload(4) -- load state before fuse
    Fuze1(0.3,0.6)
    quickload(4) -- load state before fuse
    Fuze2(0.5,0.7)
    quickload(4) -- load state before fuse
    Fuze2(0.7,0.5)
    restore_recent_best()
end
function qStab()
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
 --   set_behavior_clash_importance(0.9)
   -- Wiggle()
    set_behavior_clash_importance(1)
    --Wiggle("s",1)
    Wiggle()
end
bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end

--[[
Tlaloc`s math library
------------------------------------------------------------------------
The original random script this was ported from has the following notices:
Copyright (c) 2007 Richard L. Mueller
Hilltop Lab web site - http://www.rlmueller.net
Version 1.0 - January 2, 2007
You have a royalty-free right to use, modify, reproduce, and
distribute this script file in any way you find useful, provided that
you agree that the copyright owner above has no warranty, obligations,
or liability for such use.
------------------------------------------------------------------------
]]--
local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

--[[ End math library ]]--

function seed()
    local s=math.abs(Score())
    s=s%0.001
    s=1/s
    while s<10000000 do s=s*10 end 
    s=s-s%1
    math.randomseed(s) 
end
seed()
function down(x)--cut all after comma
    return x-x%1
end
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
bigBRK=0
function MakeBands(sgn,bands,center)
    local SC = get_segment_distance(sgn,center)
    local search=true
    local sg2, SR, RC
    local brk=0
    repeat --try determine that band can push in good direction
        brk=brk+1
        sg2=math.random(segmentCount)
        RC=get_segment_distance(sg2,center)
        SR=get_segment_distance(sg2,sgn)
        if SR<15 
            and RC<SC-3 
            and math.abs(sg2-sgn)>5
            and math.abs(sg2-center)>3
        then search=false end
        if brk>segmentCount then break end
    until search==false
    if brk<segmentCount then
        band_add_segment_segment(sgn, sg2)
        if push then
            SR=SR+pushDst --push x units
        else
            SR=SR-pushDst --pulls x units
        end
        if SR>20 then SR=20 end
        if SR<3 then SR=3 end
        band_set_length(get_band_count(), SR)
        bands=bands-1
        ppoints[#ppoints+1]=sg2
    else
        bigBRK=bigBRK+1
    end
    if bands >0 and bigBRK<10 then MakeBands(sgn,bands,center) end --make next band
end
ppoints={}
function Push(sgn) 
    local ssc=Score()
    if push then
        p("Pushing segment ",sgn, " score: ",round(ssc))
    else
        p("Pulling segment ",sgn, " score: ",round(ssc))
    end
    band_delete()
    quicksave(3)
    ppoints={}
    bigBRK=0
    MakeBands(sgn,numBands,cntSeg)
    if get_band_count()>0 then
        if doPlatform then --stabilize pushing point
            for i=1,#ppoints do
                local sn=ppoints[i]
                for x=i,#ppoints do
                    local sn2=ppoints[x]
                    band_add_segment_segment(cntSeg, sn)
                    band_set_length(get_band_count(), get_segment_distance(sn,cntSeg))
                    band_add_segment_segment(sn2, sn)
                    band_set_length(get_band_count(), get_segment_distance(sn,sn2))
                end
            end
        end
        if doFreeze>0 then
            local ss=sgn-doFreeze
            local se=sgn+doFreeze
            if ss<1 then ss=1 end
            if se>segmentCount then se=segmentCount end
            deselect_all()
            select_index_range(1,ss)
            select_index_range(se,segmentCount)
            do_freeze(true,false)
        end
        select_all()
        set_behavior_clash_importance(wiggleCI)
        Wiggle("wb",1)
        SaveBest() --maybe it found some already?
        set_behavior_clash_importance(1)
        band_delete()
        do_unfreeze_all()
        qStab()
        SaveBest()
        if Score()>bestScore-PFthreshold then
            PinkFuse()
            SaveBest()
        end
        quickload(3)
        local g=round(Score()-ssc)
        if g>0 then p("Push gain: ",g) end
    else
        p("Can`t make proper bands")
    end
end

function RandomPush(pushes)
    for i=1,pushes do
        local search=true
        local sn
        local t=0
        repeat
            t=t+1
            sn=math.random(segmentCount)
            local dst=get_segment_distance(sn, cntSeg)
            if dst>minDist then search=false end
            if t>10 then break end
        until search==false
        if t<10 then Push(sn) end
    end
end

cntSeg=0 --"center" segment global variable, segment to push from. now randomized

numBands=3 --how many bands should push
wiggleCI=0.9 --pusching Clash Importance
PFthreshold=10 --PinkFuze if we so close to best score after qSatb
minDist=7--minimum distance from "center" to push segment
pushDst=3 --push how far away
doPlatform=false --true --makes additional bands to center to stabilize push points
doFreeze=0 --10 --if positve freezes entire protein except for area around pushed segment
            -- set to 0 to disable freeze

--Push(78) --run that way to push desired segment
while true do
    cntSeg=math.random(segmentCount)
    p("Pushing away from ",cntSeg)
    push=true
    RandomPush(10) --10 pushes from that segment
    push=false
    p("Pulling to ",cntSeg)
    RandomPush(10) --10 pulls to that segment
end



"
 "type" : "script"
 "uses" : "1"
 "ver" : "0.3"
}
"
 "_recipe_12574" : "{
 "desc" : "Lots of changes, all options at end"
 "hidden" : "0"
 "mid" : "14267"
 "mrid" : "28937"
 "name" : "GA Bands 1.8"
 "parent" : "13923"
 "parent_mrid" : "16424"
 "player_id" : "174969"
 "script" : "--[[
    THIS MOD WILL NOT WORK ON "CONDITIONED" PUZZLES PROPERLY!
    
    Beware: Ugly code ahead. And I mean it!
    
    A _primative_ genetic algorithm on bands.

    Run this in the early to mid game, after you have
    a general structure but long before you do your tweaks
    to get the last few fractions of a point.

    A brief overview:

    1) [Optional] Create some bands that you think may help the fold.
       The bands that you create will not be modified.  Note, that the
       bands that you create do not have to be anchored at both ends.

    2) This script will fill in random bands to make a enuf bands so that
       the genetic algorithm can run smoothly.  These bands will be
       anchored and they may be deleted by the script.

    3) The script generates a "herd" of random critters, a critter is a
       subset of all of the bands both user and script generated.

    4) Score how well each critter (band subset) does.

    5) Keep the best critters and kill the rest.

    6) "Breed" the critters you kept by mixing rougly half of the bands
       from the "mom" with half of the bands from the "dad" critter. Do
       this until you have filled the herd back up.

    7) Some critters are mutated during breeding. A mutation is
       the replacement of one of the critter's bands with another
       randomly chosen band.

    8) If the scores aren't going anywhere after a few generations
       start over with a new herd and a new set of script generated
       bands, step 2.

    9) Repeat from the scoring step (4) until the max generation is
       reached or we can't lock the script generated bands.

    This is a greedy GA, we keep score increases as soon as they occur.
    If it's half way thru scoring a generation then so be it. This is why
    we use relative improvements as a critter score.
--]]
--[[
Tlaloc`s math library
------------------------------------------------------------------------
The original random script this was ported from has the following notices:
Copyright (c) 2007 Richard L. Mueller
Hilltop Lab web site - http://www.rlmueller.net
Version 1.0 - January 2, 2007
You have a royalty-free right to use, modify, reproduce, and
distribute this script file in any way you find useful, provided that
you agree that the copyright owner above has no warranty, obligations,
or liability for such use.
------------------------------------------------------------------------
]]--
local lngX = 1000
local lngC = 48313

local function _MWC()
    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296
    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
 
    lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)
    lngX = lngX - (math.floor(lngX / M) * M)
    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        return -value
    else
        return value
    end
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(s)
    if s==nil then 
        s=math.abs(get_score(true))
        s=s%0.001
        s=1/s
        while s<10000000 do s=s*10 end
        s=s-s%1
    end
    lngX = s
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

--[[ End math library ]]--
function Score()--return score, negative too
    return get_score(true)
end 

math.randomseed()

segCnt=get_segment_count()
p=print

function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function down(x)
    return x-x%1
end

function Wiggle(how, iters, minppi)
    if how==nil then how="wa" end
    if iters==nil then iters=6 end
    if minppi==nil then minppi=0.1 end
    
    if iters>0 then
        iters=iters-1
        sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2) 
        end
        ep = Score()
        ig=ep-sp
        if how~="s" then
            if ig > minppi then return Wiggle(how, iters, minppi) end --tail call
        end
    end
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then 
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end
function BlueFuse()
    reset_recent_best()
    select_all()
    set_behavior_clash_importance(0.05)
    do_shake(1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(0.07)
    do_shake(1)
    set_behavior_clash_importance(1)
    Wiggle()
    restore_recent_best()
    set_behavior_clash_importance(0.3)
    do_global_wiggle_all(1)
    set_behavior_clash_importance(1)
    Wiggle()
    restore_recent_best()
    SaveBest()
end

function CanBeUsed(sg1,sg2) --checking end of bands
    local ok=true
    if #DoNotUse>0 then --none of 2 can be in that area
        for i=1, #DoNotUse do
            local r=DoNotUse[i]
            for x=r[1],r[2] do
                if x==sg1 or x==sg2 then
                    ok=false
                    break
                end
            end
            if ok==false then break end
        end
    end
    if ok==false then 
        return false --if false can`t be used
    else
        ok=false
        if #AlwaysUse>0 then --at least one have to be there
            for i=1, #AlwaysUse do
                local r=AlwaysUse[i]
                for x=r[1],r[2] do
                    if x==sg1 or x==sg2 then
                        ok=true
                        break
                    end
                end
                if ok==true then break end
            end
        else
            ok=true
        end
        return ok --if true can be used
    end    
end

bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end
function SaveRB()
    quicksave(4)
    restore_recent_best()
    SaveBest()
    quickload(4)
end
function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    reset_recent_best()
    quicksave(4)
    Fuze1(0.1,0.7)
    quickload(4)
    Fuze1(0.3,0.6)
    quickload(4)
    Fuze2(0.5,0.7)
    quickload(4)
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end
function qStab()
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    if fastQstab==false then 
        set_behavior_clash_importance(0.4)
        Wiggle("wa",1)
        set_behavior_clash_importance(1)
        Wiggle("s",1)
    end
    set_behavior_clash_importance(1)
    Wiggle()
    SaveBest()
end

-- Per critter parameters
Critter = {
    idCounter = 0, -- Used to generate critter IDs
    minBands  = 3, -- Min number of bands
    maxBands  = 5, -- Max number of bands
    startScore=0, --starting score of critter (rav3n)
}

-- Parameters dealing with the herd
Herd = {
    keep           = 3,  -- This many survive to next generation
    breed          = 3,  -- Breed this many replacements
    generation     = 1,  -- What generation is this
    maxGeneration  = 20, -- Quit after this many generations
    improvementWas = 0,  -- How good did the last generation do
    scoreBefore    = 0,  -- Score at the start of a generation
    rebootLimit    = 2,  -- Reboot after this many 0 improvement generations
    rebootCount    = 0,  -- How close are we to the reboot limit
    mutateRate     = 4,  -- On average mutate 1 out this many new borns
    rebootScore    = 0.1, -- Only increment reboot count when below this
    startingScore  = Score(), -- Score at the start of the script
}
Herd.size = Herd.keep + Herd.breed

-- Parameters dealing with bands
Band = {
    userMade    = get_band_count(), -- How many bands did user enter
    maxLength   = 20,
    minStrength = 0.1,
    maxStrength = 1,
    locked      = false, -- Were we able to lock the script generated bands
}

-- How many random bands to make
Band.scriptMade = (Herd.size * Critter.maxBands) - Band.userMade

-- A random float between [0, 1)
function RandomFloat()
    return math.random()
end

 -- A random int between [1, high]
function RandomInt(high)
    return math.random(high)
end

-- Generate a random band
function CreateBand()
    local start  = RandomInt(segCnt)
    local finish = RandomInt(segCnt)
    if  start~=finish and --not make band to same place
        math.abs(start-finish)>= minDist and --do not band if too close
        CanBeUsed(start,finish) and --at least one need to be in place
        get_segment_distance(start,finish) <= maxBandDist --not band if too far away
    then
        band_add_segment_segment(start, finish)
        local range    = Band.maxStrength - Band.minStrength
        local strength = (RandomFloat() * range) + Band.minStrength
        local n = get_band_count()
        if n > 0 then band_set_strength(n, strength) end
        
        local length = 3+ (RandomFloat() * (Band.maxLength-3)) --min len is 3
        
        if compressor then
            length = get_segment_distance(start,finish)-compressFrac --compressing
        else
            if push then
                local dist = get_segment_distance(start,finish)
                if dist >2 and dist <18 then length=dist*1.5 end
            end
            
            if hydroPull then
                if is_hydrophobic(start) and is_hydrophobic(finish)  then 
                    length=3 --always pull hydrophobic pair
                end
            end
        end
        if length >20 then length=20 end
        if length <0 then length=0 end
        if n > 0 then band_set_length(n, length) end                
    else
        CreateBand()
    end
end

function CreateBands()
    local i
    p("Creating bands...")
    for i = 1, Band.scriptMade do
        CreateBand()
    end
end

function DeleteScriptMadeBands()
    if Band.userMade==0 then 
        band_delete() --if no user bands del them all
    else 
        local b
        for b = get_band_count(), Band.userMade + 1, -1 do
            band_delete(b)
        end
    end
end

function DisableAllBands()
    band_disable()
end

function EnableCritterBands(critter)
    local b
    for b = 1, critter.bands do
        band_enable(critter.band[b])
    end
end

-- Default critter constructor
function NewCritter()
    Critter.idCounter = Critter.idCounter + 1
    local critter = { bands = 0, score = -999999, age = 0, mutated = false, startScore = 0, }
    critter.id = Herd.generation .. "_" .. Critter.idCounter
    critter.band = {}
    return critter
end

-- Constructor for generating a completely random critter
function RandomCritter()
    local i
    local critter = NewCritter()
    critter.mutated = true
    critter.id = critter.id .. "r"
    critter.bands = RandomInt(Critter.maxBands - Critter.minBands)
                  + Critter.minBands
    local max = get_band_count()
    for i = 1, critter.bands do
        critter.band[i] = RandomInt(max)
    end

    return critter
end

-- Lock in the script generated bands so that they will
-- appear when we do a restore_abs_best()
-- I would love to replace this with a slotted recent best
function LockBands()
    set_behavior_clash_importance(1)
    if Band.scriptMade <= 0 then
        Band.locked = true
        return
    end
    reset_recent_best() --save bands
    Band.locked = true
    quicksave(3) --to be 200% sure
    p("Bands locked")
end

-- Generate a random heard. This includes all new critters,
-- and a new set of script generated bands
function RandomHerd()
    local i
    DeleteScriptMadeBands()
    
    if Herd.generation>1 and randomOptions then --randomize push/pull
        local r=RandomInt(10)
        if r%2==0 then compressor=true p("Compressing.") else compressor=false end
        if compressor==false then
            local r=RandomInt(10)
            if r%2==0 then push=true p("Pushing.") else push=false end
            r=RandomInt(10)
            if r%2==0 then hydroPull=true p("Pulling hydros.") else hydroPull=false end
        end
    end
    
    CreateBands()
    DisableAllBands()
    LockBands()
    for i = 1, Herd.size do
        Herd[i] = RandomCritter()
        p("randomize: ", Herd[i].id)
    end
    
end

function ScoreHerd()
    local i
    local first = 1 
    local hs=Score()
    for i = 1, Herd.size do
        quicksave(5) --restore it if to much loss
        local label   = "  unchanged score: "
        local critter = Herd[i]
        
        if critter.startScore == Score() then
            first=first+1
        end
        
        if i >= first or critter.mutated then
            label = "  score: "
            local startingScore = Score()
            critter.startScore = startingScore
            
            DisableAllBands()
            EnableCritterBands(critter)
            select_all()
            local pullS=Score()
            set_behavior_clash_importance(wiggleCI)
            do_global_wiggle_backbone(1)
            set_behavior_clash_importance(1)
            DisableAllBands()
            SaveRB() --sometimes it wotks ;]
            if useQstab then
                if pullS-Score()>doQstab then
                    qStab()
                else Wiggle() end
                
                if  bestScore-Score()<doFuze then
                    quicksave(4)
                    if useBF then BlueFuse() end
                    quickload(4)
                    if usePF then PinkFuse() end
                end
            else
                quicksave(4)
                if useBF then BlueFuse() end
                quickload(4)
                if usePF then PinkFuse() end
            end
            SaveBest() --if not use any fuze or so.
            
            critter.score = Score() - startingScore
            
            if critter.score<= 0 and critter.score>-0.1 then 
                critter.score=-999 --no change, we not need it
            end
            
            if loss==true then
                if critter.score<0-maxLoss then 
                    quickload(5) --too negative score
                end 
            else --next critter from best state
                quickload(3)
            end
        end

        critter.age = critter.age + 1
        critter.mutated = false
        p("critter: ", critter.id, label, round(critter.score))
    end
    quickload(3)
    if mutate and Score()-hs>1 then--if more than 1pt change
        select_all()
        set_behavior_clash_importance(mutateCI)
        do_mutate(1)
        set_behavior_clash_importance(1)
        qStab()
    end
end

function SwapCritter(a, b)
    Herd[a],Herd[b]=Herd[b],Herd[a]--yes! in LUA you can do that!
end

-- A quasi sort function. Only sort what is kept.
-- A small N means that I'm OK with this being a quadratic sort
function CullHerd()
    local weakest = 1 -- Survivor with the lowest score
    local i, j

    for i = 2, Herd.size do
        if Herd[i].score > Herd[weakest].score then
            SwapCritter(i, weakest)
            j = weakest
            while j > 1 and Herd[j].score > Herd[j-1].score do
                SwapCritter(j, j-1)
                j = j - 1
            end
        end
        weakest = weakest + 1
        if weakest > Herd.keep then weakest = Herd.keep end
    end

    for i = 1, Herd.keep do
        p("kept: ", Herd[i].id, "  score: ", round(Herd[i].score))
    end
end

-- Mix bands from the mom and dad critter, rougly half from each
function BreedPair(mom, dad)
    local kid = NewCritter()
    local k, i, b = 0, 0, 0

    -- Choose bands from the mom
    b = RandomInt(mom.bands)
    for i = 1, (mom.bands / 2) + 0.5 do
        k = k + 1
        kid.band[k] = mom.band[b]

        b = b + 1
        if b > mom.bands then b = 1 end
    end

    -- Choose bands from the dad
    b = RandomInt(dad.bands)
    for i = 1, dad.bands / 2 do
        k = k + 1
        kid.band[k] = dad.band[b]

        b = b + 1
        if b > dad.bands then b = 1 end
    end

    kid.bands = k
    return kid
end

-- Breed survivors with each other
-- 1st breeds w/ 2nd and 2nd w/ 3rd etc.
-- When that's done 1st breeds w/ 3rd and so on.
function BreedHerd()
    local mom, dad, kid = 0, 0, 0
    local step = 0 -- Dad is this far away from mom +1
    local keep = Herd.keep

    for kid = keep + 1, Herd.size do
        mom = mom + 1
        if mom > keep then
            mom = 1
            step = step + 1
        end
        dad = ((mom + step) % keep) + 1
        Herd[kid] = BreedPair(Herd[mom], Herd[dad])
        p("breeding:  mom: ", Herd[mom].id,
                       "  dad: ", Herd[dad].id,
                       "  kid: ", Herd[kid].id)
    end
end

-- Mutate a random selection of the new born critters. A mutation
-- is the replacement of one of the critter's randomly chosen bands
-- with another band randomly choosen from the entire band set.
function MutateHerd()
    local i, zap, new, mutate, max
    max = get_band_count()
    for i = Herd.keep + 1, Herd.size do
        mutate = RandomInt(Herd.mutateRate)
        if mutate == 1 then
            zap = RandomInt(Herd[i].bands)
            new = RandomInt(max)
            Herd[i].band[zap] = new
            Herd[i].mutated   = true
            Herd[i].id        = Herd[i].id .. "m"
            p("Mutating: ", Herd[i].id, "  zapped: ", zap)
        end
    end
end

function ga()
    p("Starting GA Bands v1.8 ...")
    if allLoop then AllLoop() end
    quicksave(3)
    select_all()
    RandomHerd()

    while Band.locked and Herd.generation <= Herd.maxGeneration do
        p("")
        p("generation: ", Herd.generation," of ",Herd.maxGeneration, " Start score: ",round(Score()))

        if Herd.rebootCount >= Herd.rebootLimit then
            RandomHerd()
            Herd.rebootCount = 0
        end
        Herd.generation = Herd.generation + 1

        Herd.scoreBefore = Score()

        ScoreHerd()
        CullHerd()
        BreedHerd()
        MutateHerd()

        Herd.improvementWas = Score() - Herd.scoreBefore
        p("score: ",             round(Score()))
        p("improvement: ",       round(Herd.improvementWas))
        p("total improvement: ", round(Score() - Herd.startingScore))

        if Herd.improvementWas < Herd.rebootScore then
            Herd.rebootCount = Herd.rebootCount + 1
        else
            Herd.rebootCount = 0
        end
        p("reboot count: ", Herd.rebootCount, "  limit: ", Herd.rebootLimit)
        quickload(3) --every herd load best state
    end

    DeleteScriptMadeBands()
    quickload(3)--load best state
    if allLoop then load_structure() end
    LockBands()
end

-- V V V V V editable options below V V V V V

DoNotUse={--just comment lines below or add more areas to avoid
--{segCnt,segCnt}, --ligand cant be used
--{120,134},
--{1,10},
}
AlwaysUse={ --areas should be always used
--{segCnt,segCnt},--ligand need to be at one end
--{37,61} --loopy
}

Band.minStrength=0.3 --minimum band STR
Band.maxStrength=1.1 --maximum band STR
maxBandDist=25 --maximum dostance (in "points") between banding segments
minDist=5  --minimum dist (in segments) between banded segments

mutate=false --true --do mutate(1) + qstab each generation
mutateCI=0.1 --clash importance during mutate

useQstab=true --quick stabilize to see that fuze have any chance 
              --if false one (or both) of fuze/s are runned anyway
doQstab=10 --run qstab only if loss is more than that. othwewise only wiggle
fastQstab=false --if true only 1 shake and 1 wiggle as qstab

doFuze=5 --how close to best score after stabilize to run PF
useBF=false --true --run BlueFuze
usePF=true --run PinkFuze
          -- fuzes are runnned from same state! not one afer one!

--options below are valid only until reboot. it might change every reboot.
compressor=false --making all bands shorter to compress protein OVERRIDES PUSH AND PULL!
compressFrac=4 --shorten by that much. looks like 4 is good value
push=false --always push when possible (hydros may be excluded)
hydroPull=false --always pul hydrophobic pair
randomOptions=true --randomizing push/pull/compressor options every reboot

allLoop=false --run in all-loop mode (sometimes works better!)

wiggleCI=0.7 --clash impotrance during push/pull
loss=false --true --do not reload best score between critters in herd if true
maxLoss=30 --maximum loss by criter, reloading last "good" herd position- not best total!

Herd.maxGeneration  = 200 --how many generations. More=longer run
Herd.rebootLimit = 2 --how many gens w/o improvement to random new bands 1-random after 1st bad one

ga() --go!






"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_12590" : "{
 "desc" : "Performs local rebuild on Amino Acid  ( AA ) groups, based on secondary structure ( SS ). Note : If you abort prematurely, hit ( CTRL + N ) to restore your best score."
 "hidden" : "0"
 "mid" : "14300"
 "mrid" : "27660"
 "name" : "local rebuild - Seagat2011"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "199249"
 "script" : "-- local rebuild - Seagat2011\
-- Performs local rebuild on AA groups based on SS. Note : If you abort prematurely, hit ( CTRL + N ) to restore your original score\

local rebuild_forward = true -- Rebuild direction. Set to "false" to rebuild in reverse.\

reset_recent_best ()\
save_structure ( )\

local function _blueFuse ( r )\

	\	set_behavior_clash_importance ( 0.05 )
        \
	\	do_shake ( 1 )
        \	\
	\	set_behavior_clash_importance ( 1 )
        \	        \
	\	do_global_wiggle_all ( 1 )
     \	\	\
   \
	\	set_behavior_clash_importance ( 0.07 )
        \
	\	do_shake ( 1 )

	\	set_behavior_clash_importance ( 1 )
        \	\
	\	do_global_wiggle_all ( 1 )
             \
	\
	\	set_behavior_clash_importance ( 0.64 )
        \
	\	do_global_wiggle_all ( 1 )
        \
	\	set_behavior_clash_importance ( 1 )
        \	\
	\	do_global_wiggle_all ( 1 )
        \

end\

local function wsw ( r,bw )--(minppi, nows)\

	local ws\
	local sh\
	local wsbs\
	local minppi\
	local g\
	local s1\
	local s3\
	local s4\

	if bw == true then -- load parameters user wants performed before wiggle operation\
	\
	\	ws = r.wsbw\
	\	sh = r.sbw\
	\	wsbs = r.wsbs\

	else\

	\	ws = r.wsaw\
	\	sh = r.saw\
	\	wsbs = false\

	end\

	set_behavior_clash_importance ( 1 )\

	if wsbs == nil then wsbs = false end--no wiggle sidechain, start with shake\
	if wsbs == true then do_global_wiggle_sidechains ( 1 )  end\
	if sh == true then do_shake ( 1 ) end\	\
	if ws == true then do_global_wiggle_sidechains ( 1 ) end\

	select_all ( )\

end\

local function prepare_ends ( m )\

	if m.reload == true then\

	\	load_structure ( )\
	\	m.reload = false\

	else\

	\	if get_ss ( m.idx ) ~= "L" then\
	\	deselect_all ( )\
	\	select_index ( m.idx )\
	\	replace_ss ( "L" )\
	\	select_all ( )\
	\	m.reload = true\
	\	end\

	\	if get_ss ( m.idx2 ) ~= "L" then\
	\	deselect_all ( )\
	\	select_index ( m.idx2 )\
	\	replace_ss ( "L" )\
	\	select_all ( )\
	\	m.reload = true\
	\	end\

	end\

	return m\

end\

local function get_ss_group ( z )\

	local tmp\

	while ( 1 ) do\

	\	if z.rebuild_forward == true then\

	\	\	tmp = get_ss ( z.idx2 )\

	\	else\
	\
	\	\	tmp = get_ss ( z.idx )\

	\	end\

	\	if tmp == z.n then\

	\	\	if z.rebuild_forward == true then\

	\	\	\	if z.idx2 < z.k then\
	\
	\	\	\	\	z.idx2 = z.idx2 + 1\

	\	\	\	else\

	\	\	\	\	z.idx2 = z.k\
	\	\	\	\	break\

	\	\	\	end\

	\	\	else\

	\	\	\	if z.idx > 1 then\

	\	\	\	\	z.idx = z.idx - 1\

	\	\	\	else\

	\	\	\	\	z.idx = 1\
	\	\	\	\	break\

	\	\	\	end\
	\	\	end\
	\	\	\	\	\	\	\
	\	else\

	\	\	if rebuild_forward == true then\

	\	\	\	z.next_group = z.idx2\
	\	\	\	z.idx2 = z.idx2 - 1\

	\	\	else\

	\	\	\	z.next_group = z.idx\
	\	\	\	z.idx = z.idx + 1\

	\	\	end\

	\	\	break\

	\	end\

	end -- while ( 1 )\

	return z\

end\

local function local_rebuild ( r )\

	local i\
	local ss\
	local idx \
	local idx2\
	local attempts\

	local duration\	\
	\
	i = 1\
	idx = r.idx\
	idx2 = r.idx2 \	\
	attempts = r.attempts + 1\
	\
	n = {\
	["L"] = r.L_duration,\
	["E"] = r.E_duration,\
	["H"] = r.H_duration,\
	}\

	local t\
	t = r.ss\
	if t == "H" or t == "E" then\

	\	if idx > 1 then\
	\	\	idx = idx - 1\	-- Surrounding loop structures req'd, for effective rebuild\
	\	end\

	\	if idx2 < r.k then\
	\	\	idx2 = idx2 + 1\	-- Surrounding loop structures req'd, for effective rebuild\
	\	end\

	end\

	duration = n [ r.ss ] \

	while i < attempts do\

	\	print ( "-- Attempt ", i, " of ", attempts - 1 )\

	\	while ( 1 ) do -- until we achieve a new rebuild solution \

	\	\	local s1\
	\	\	local s2\

	\	\	m = {\
	\	\	\	idx = idx,\
	\	\	\	idx2 = idx2,\
	\	\	\	reload = false\
	\	\	}\
	\	\	\
	\	\	s1 = get_score ( true )\

	\	\	m = prepare_ends ( m )\

	\	\	deselect_all ()\
	\	\	select_index_range ( idx, idx2 )\
	\	\	do_local_rebuild ( duration )\

	\	\	m = prepare_ends ( m )\

	\	\	s2 = get_score ( true )\

	\	\	if s2 ~= s1 then\

	\	\	\	local _s2\
	\	\	\	local b\

	\	\	\	select_all ( )\	\	\	\	\

	\	\	\	wsw ( r, true )\
	\	\	\	do_global_wiggle_all ( 1 )\
	\	\	\	wsw ( r, false )\

	\	\	\	b = get_score ( true )\
	\	\	\	if b + r.threshold > s1 then\
	\	\	\	_blueFuse ( r )\
	\	\	\	end\

	\	\	\	restore_recent_best ( )\

	\	\	\	_s2 = get_score ( true )\

	\	\	\	if _s2 > s1 then\
	\	\	\	print ( "Gain:  ", _s2, "  + ",_s2 - s1 )

	\	\	\	end\

	\	\	\	i = i + 1\

	\	\	\	break\

	\	\	else\

	\	\	\	duration = duration + 1\

	\	\	end -- s2 ~= s1\

	\	end -- while ( 1 )\

	end -- while i < attempts\

end\

local i


local k\


k = get_segment_count () \

if rebuild_forward == true then \

	i = 1 \
else\

	i = k\

end\

print ( "Starting Score = ", get_score ( true ) )\
print ( "Printing secondary structure ( SS ) .. " )


while ( 1 ) do\

	local s1 \
	local s2\

	s1 = get_score ( true )

	\

	deselect_all ()\	\

	z = {\
	\	idx = i,\
	\	idx2 = i, \
	\	next_group = i,\
	\	k = k,\
	\	n = get_ss ( i ),\	\
	\	rebuild_forward = rebuild_forward,\	\
	}\

	z = get_ss_group ( z ) \

	i = z.next_group\

	print ("Begin: ", z.idx, "  -  End: ", z.idx2 )\

	s = {\
	idx = z.idx,\	-- Start index\
	idx2 = z.idx2,\	-- End index\
	L_duration = 2,\	-- loop ( L ) rebuild duration\
	E_duration = 4,\	-- sheet ( E ) rebuild duration\	\
	H_duration = 2,\	-- helices ( H ) rebuild duration\	\
	attempts = 6,\	-- #number of attempts\
	threshold = 150,\	-- BlueFuse *all* results within [threshold] points of best score (Set to 0 to BlueFuse only after gains)\	\
	sbw = false,\	-- Perform shake before wiggle\
	saw = false,\	-- Perform shake after wiggle (complementary)\
	wsbw = false,\	-- wiggle sidechains before wiggle (Performed after shake, if sbw is selected)\
	wsaw = false,\	-- wiggle sidechains after wiggle (Performed after shake, if wsbw is selected)(complementary)\
	wsbs = false,\	-- wiggle sidechains before both shake and wiggle (Performed before shake, if enabled, regardless of other settings selected)\
	ss = z.n,\	\	-- current secondary structure ( SS )\
	k = z.k,\	\	-- Length of polypeptide\
	}\

	local_rebuild ( s ) \	\

	s2 = get_score ( true )



	if s2 > s1 then

	print ( "Total Gain:  ", s2, "  + ",s2 - s1 )

	end

	\
	if ( z.idx2 >= z.k ) and ( z.rebuild_forward == true ) then\
	break--i = 1 \
	elseif ( z.idx <= 1 ) and ( z.rebuild_forward == false ) then\
	break--i = k\
	end\

end -- while i <= k..\

print ( "done" )"
 "type" : "script"
 "uses" : "1"
 "ver" : "0.3"
}
"
 "_recipe_12613" : "{
 "desc" : "Find and  rebuild all areas. Work in structure mode. Can set area to rebuild by hand. Options at end. This one is set for loops only and works forever. Only  backbone, sidechain and clash couning. Testing for duplicate position to stabilize."
 "hidden" : "1"
 "mid" : "18614"
 "mrid" : "26465"
 "name" : "Rebuild Areas v3.7"
 "parent" : "13434"
 "parent_mrid" : "21029"
 "player_id" : "174969"
 "script" : "--[[
Rebuild Areas v3
Trying to rebild all areas found
Options at end
]]--


--[[
Tlaloc`s math library
------------------------------------------------------------------------
The original random script this was ported from has the following notices:
Copyright (c) 2007 Richard L. Mueller
Hilltop Lab web site - http://www.rlmueller.net
Version 1.0 - January 2, 2007
You have a royalty-free right to use, modify, reproduce, and
distribute this script file in any way you find useful, provided that
you agree that the copyright owner above has no warranty, obligations,
or liability for such use.
------------------------------------------------------------------------
]]--
local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

--[[ End math library ]]--

function Score()
    return get_score(true)
end
function seed()
    local s=math.abs(Score())
    s=s%0.0001
    s=1/s
    while s<10000000 do s=s*10 end
    s=s-s%1
    math.randomseed(s)
end
seed()

 -- A random int between [1, high]
function RandomInt(high)
    return math.random(high)
end

function ShuffleTable(tab) --randomize order of elements
    local cnt=#tab
    for i=1,cnt do
        local r=RandomInt(cnt)
        tab[i],tab[r]=tab[r],tab[i]
    end
    return tab
end

segCnt=get_segment_count()
p=print
areas={}

function SelectAround(ss,se,radius)
    for i=1, segCnt do
        for x=ss,se do
            if get_segment_distance(x,i)<radius then 
                select_index(i) 
                break 
            end
        end 
    end
end

function getPartScore(segments)--using partial scoring
    local score = 0
    for i=1,#attr do
        score =  score + get_segment_score_part(attr[i], segments)
    end
    return score
end
function getAreaScore(ss,se)
    local s=0
    for i=ss,se do
        s=s+getPartScore(i)
    end
    return s
end

function Wiggle(how, iters, minppi) --score conditioned recursive wiggle/shake
    if how==nil then how="wa" end
    if iters==nil then iters=6 end
    if minppi==nil then minppi=0.01 end
    if "how"=="s" then iters=1 end
    if iters>0 then
        iters=iters-1
        local sp=Score()
        if how == "s" then do_shake(1) 
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2)
        end
        local ep = Score()
        local ig=ep-sp
        if ig > minppi then return Wiggle(how, iters, minppi) end --to learn recursion you have to learn recursion ;]
    end
end

function qStabilize()
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    set_behavior_clash_importance(0.4)
    Wiggle()
    set_behavior_clash_importance(1)
    Wiggle("s",1)
    Wiggle()
    SaveBest()
    if doPF and (bestScore-Score()<fuzeThreshold) then
        PinkFuse()
    end
end

function round(x)
    return x-x%0.001
end

bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end
function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    p("PinkFuse...")
    reset_recent_best()
    quicksave(4) -- store state before fuse
    Fuze1(0.1,0.7)
    quickload(4) -- load state before fuse
    Fuze1(0.3,0.6)
    quickload(4) -- load state before fuse
    Fuze2(0.5,0.7)
    quickload(4) -- load state before fuse
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end

function localRebuild(maxiters)
    if maxiters==nil then maxiters=3 end
    local s=Score()
    local i=0
    repeat
        i=i+1
        if i>maxiters then break end
        do_local_rebuild(i)
    until Score()~=s

    if Score()~=s then return false else return true end
end

function savePartial(ss,se)
    local part2=getPartScore(ss,se)
    if part2>partial then
        quicksave(7)--save best partial score
        partial=part2
    end
    return partial
end

partial=0
function Rebuild(ss,se,tries)
    if ss>se then ss,se=se,ss end --switch if needed
    p("Rebuilding area ",ss,"-",se," Score: ",round(Score()))
    local sSc=Score()
    local done=false
    deselect_all()
    select_index_range(ss,se)
    repeat
        done = localRebuild() --searching until score changes
    until done~=true
    reset_recent_best() -- a backup at start
    partial=getPartScore(ss,se)
    quicksave(7) --save best partial score
    p("Scoring ",tries," rebuild tries, please wait...")
    for try=1,tries do -- perform loop for number of tries
        deselect_all()
        select_index_range(ss,se)
        localRebuild()
        if shake then
            SelectAround(ss,se,12)
            Wiggle("ws",1)
            Wiggle("s",1)
            Wiggle("ws",1)
        end
        partial=savePartial(ss,se)
    end
    restore_recent_best()--restore best total score
end

function AddLoop(sS)
    local ss=sS
    local ssStart=get_ss(ss)
    local se=ss
    for i=ss+1,segCnt do
        if get_ss(i)==ssStart then se=i
        else break end
    end
    if se-ss+2>minLen and loops==true then
        areas[#areas+1]={ss,se}
    end
    return se
end

function AddOther(sS)
    local ss=sS
    local ssStart=get_ss(ss)

    local se=ss
    if ss>1 then
        for i=ss-1,1,-1 do --search bacward for start
            local sec=get_ss(i)
            if sec=="L" then ss=i
            else break end
        end
    end
    if se<segCnt-1 then --now forward to find end
        local change=false
        repeat
            se=se+1
            if se==segCnt then break end
            local sec=get_ss(se)
            if change==false then
                if sec~=ssStart then change=true end
            end
        until change==true and sec~="L"
        se=se-1
    end
    if sheets==false and ssStart=="E" then return se end
    if helices==false and ssStart=="H" then return se end
    if se-ss+2>minLen then
        areas[#areas+1]={ss,se}
    end
    return se
end

function PrintAreas()
    local a=""
    local x=0
    for i=1,#areas do
        x=x+1
        a=a..areas[i][1].."-"..areas[i][2].." "
        if x>8 then
            p(a)
            a=""
            x=0
        end
    end
    if x>0 then p(a) end
end

function FindAreas()
    if loops then
        local done=false
        local ss=0
        repeat--loops
            ss=ss+1
            local ses=get_ss(ss)
            if ses=="L" then
                ss=AddLoop(ss)
            end
            if ss==segCnt then done=true end
        until done~=false
    end
    if sheets or helices then
        local done=false
        local ss=0
        repeat--other
            ss=ss+1
            local ses=get_ss(ss)
            if ses~="L" then
                ss=AddOther(ss)
            end
            if ss==segCnt then done=true end
        until done~=false
    end
end
function CutAreas(minLen,minL, maxL)
    local x=#areas
    local ar2={}
    for i=1,x do
        local ar=areas[i]
        local ss=ar[1]
        local se=ar[2]
        local len=se-ss+1
        if len>=minLen then
            if leaveLong then
                ar2[#ar2+1]={ss,se}
            end
            for z=ss,se-minL+1 do
                for l=minL,maxL do
                    local e=z+l-1
                    if e<=se then
                        ar2[#ar2+1]={z,e}
                    end
                end
            end
        else
            ar2[#ar2+1]={ss,se}
        end
    end
    areas=ar2
end
function SmartRebuild(tries)
    quicksave(3)
    reset_recent_best()
    local ss=Score()
    for i=1,#areas do
        local sScore=Score()
        local ss=areas[i][1]
        local se=areas[i][2]
        Rebuild(ss,se,tries)
        p("Stabilizing best scored rebuild.")
        local bsr=Score()
        qStabilize()
        quickload(7)
        if Score()~=bsr then
            p("Stabilizing best partal scored rebuild")
            qStabilize()
        else
            p("Same best partial.")
        end
        quickload(3)
    end
    p("Total gain ",round(Score()-ss))
end

--atributes to score to determine best partial score rebuild
attr = {'backbone','sidechain'} --,'hiding','disulfides','other','bonding','reference','packing','clashing'}

minLen=2 --minimum lenght of area to rebuild

loops=true --rebuild loops alone
sheets=false --rebuild sheets + surrounding loops
helices=false --rebuild helices + surrounding loops

shake=false --shake around rebuilded area each rebuild
doPF=true --PinkFuze after stabilize
fuzeThreshold=5 --do BF if we so close to best score after qStab

FindAreas() --auto find usable areas
leaveLong=false --leawe longer areas to rebuild too when cutting
CutAreas(3,2,5) --cutting all areas longer than 3 on pieces form 2 to 5 and adding to rebuild list
PrintAreas() --print areas range

--areas={{35,52},{35,41},{46,52}}  --uncomment and edit to rebuild only that areas

while true do --un/comment this and last line to run it forever
    ShuffleTable(areas) --random rebuild order
    SmartRebuild(35) --or set more
end
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_12646" : "{
 "desc" : "Deep Rebuild  Worst script.  Usage and options at end."
 "hidden" : "0"
 "mid" : "19637"
 "mrid" : "29666"
 "name" : "Rav3n_pl DRW v2.5  fast"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "174969"
 "script" : "--[[
    Rav3n_pl Deep Rebuild v2.5
    WARNING!
    1) Script uses save slots 3-10!!!
    2) Best score are always in slot 3

    All options at end
]]--


p=print
segCnt=get_segment_count()

function Score()
    return get_score(true)
end
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function abs(x)
    if x<0 then x=-x end
    return x
end
function Wiggle(how, iters, minppi) --score conditioned recursive wiggle/shake
    if how==nil then how="wa" end
    if iters==nil then iters=6 end
    if minppi==nil then minppi=0.1 end

    if iters>0 then
        iters=iters-1
        local sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2)
        end
        local ig=Score()-sp
        if ig > minppi then return Wiggle(how, iters, minppi) end
    end
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end
function SelectAround(ss,se,radius,nodeselect)
    if nodeselect~=true then deselect_all() end
    for i=1, segCnt do
        for x=ss,se do
            if get_segment_distance(x,i)<radius then select_index(i) break end
        end 
    end
end
function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse(slot)
    reset_recent_best()
    Fuze1(0.1,0.7)
    quickload(slot)
    Fuze1(0.3,0.6)
    quickload(slot)
    Fuze2(0.5,0.7)
    quickload(slot)
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end

function qStabilize()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    select_all()
--    set_behavior_clash_importance(0.4)
   -- Wiggle()
    set_behavior_clash_importance(1)
    --Wiggle("s",1)
    Wiggle()
end

function Sort(tab,items) --BACWARD bubble sorting - lowest on top, only needed items
    for x=1,items do --items do
        for y=x+1,#tab do
            if tab[x][1]>tab[y][1] then
                tab[x],tab[y]=tab[y],tab[x]
            end
        end
    end
    return tab
end
function FindWorst()
    if sEnd==nil then sEnd=segCnt end
    p("Searching worst scoring parts of len ",len)
    wrst={}
    for i=sStart,sEnd-len+1 do
        local s=getAreaScore(i,i+len-1)
        wrst[#wrst+1]={s,i}
    end
    wrst=Sort(wrst,reBuild)
    areas={}
    local rb=reBuild
    if rb>#wrst then rb=#wrst end
    for i=1,rb do
        local w=wrst[i]
        local ss=w[2]
        areas[#areas+1]={ss,ss+len-1}
    end
end

bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end
function localRebuild(maxiters)
    if maxiters==nil then maxiters=3 end
    local s=Score()
    local i=0
    repeat
        i=i+1
        if i>maxiters then break end
        do_local_rebuild(i)
    until Score()~=s
    if Score()~=s then return false else return true end
end
function ReBuild(ss,se,tries)
    Clear() --reser score tables
    if ss>se then ss,se=se,ss end --switch if needed
    p("DR area ",ss,"-",se," ",tries," times. Wait... Current score: ",round(Score()))
    deselect_all()
    select_index_range(ss,se)
    if rbSkip> 0 then
        do_local_rebuild(rbSkip)
    end
    for try=1,tries do -- perform loop for number of tries
        localRebuild()
        if doShake then
            Wiggle("s",1)
        end
        Save(ss,se)
    end
end

function getPartScore(segments,attr)--using partial scoring
    local score = 0
    for i=1,#attr do
        score =  score + get_segment_score_part(attr[i], segments)
    end
    return score
end
function getAreaScore(ss,se,attr)
    local s=0
    if attr~=nil then --local scoring
        for i=ss,se do
            s=s+getPartScore(i,attr)
        end
    else --total segment scores
        for i=ss,se do
            s=s+get_segment_score(i)
        end
    end
    return s
end
Scores={} --{save_no,points}
function Clear()
    Scores={
    {10,-99999999},
    {9,-99999999},
    {8,-99999999},
    {7,-99999999},
    {6,-99999999},
    {5,-99999999},
    {4,-99999999},
    }
    slotScr={}
end
function Save(ss,se)
    local scr=
    {
    {10,getAreaScore(ss,se,{'backbone'})},
    {9,getAreaScore(ss,se,{'sidechain'})},
    {8,getAreaScore(ss,se,{'clashing'})},
    {7,getAreaScore(ss,se,{'backbone','sidechain','clashing'})},
    {6,getAreaScore(ss,se,{'backbone','clashing'})},
    {5,getAreaScore(ss,se)},
    {4,Score()}
    }
    for i=1,#Scores do
        local s=scr[i][2]
        if s>Scores[i][2] then
            local slot=scr[i][1]
            quicksave(slot) --p("Saved slot ",slot," pts" ,s) --debug
            Scores[i][2]=s
        end
    end
end

slotScr={}
function ScoresCheck(slot)
    quickload(slot)
    local s=Score()
    local ok=true
    if #slotScr > 1 then
        for i=1,#slotScr do
            if slotScr[i]==s then ok=false break end
        end
    end
    slotScr[#slotScr+1]=s
    return ok
end
function PrintAreas()
    local a=""
    local x=0
    for i=1,#areas do
        x=x+1
        a=a..areas[i][1].."-"..areas[i][2].." "
        if x>6 then
            p(a)
            a=""
            x=0
        end
    end
    if x>0 then p(a) end
end

function DeepRebuild()
    if sEnd==nil then sEnd=segCnt end
    local ss=Score()
    if struct==false then AllLoop() end
    quicksave(3)
    p("DeepRebuild started at score: ",round(ss))
    for i=1,#areas do
        local ss=Score()
        local s=areas[i][1]
        local e=areas[i][2]
        ReBuild(s,e,rebuilds)
        for r=1,#Scores do
            slot=Scores[r][1]
            if ScoresCheck(slot) then
                p("Fuzing slot ",slot)
                SelectAround(s,e,12)
                qStabilize()
                select_all()
                Wiggle()
SaveBest()
                if doPF and (bestScore-Score()<fuzeThreshold) then
                    quicksave(slot) --save stabilized for fuzing
                    PinkFuse(slot)
                end
                SaveBest()
            end
        end
        quickload(3)
        if breakOnPoints and Score()>ss then break end --break if points found
    end
    p("DeepRebuild gain: ",round(Score()-ss))
    if struct==false then load_structure() end
end
function DRcall(how)
    if how=="drw" then
        for i=minLen,maxLen do --search from minl to maxl worst segments
            len=i
            FindWorst() --fill areas table. Comment it if you have set them by hand
            PrintAreas()
            DeepRebuild()
        end
    elseif how=="fj" then --DRW len cutted on pieces
        FindWorst() --add to areas table worst part
        areas2={}
        for a=1,#areas do
            local s=areas[a] --{ss,se}
            local ss=s[1] --start segment of worst area
            local se=s[2] --end segment of worst area
            for i=ss,se do
                for x=1,len do
                    if i+x<=se then
                        areas2[#areas2+1]={i,i+x}
                    end
                end
            end
        end
        areas=areas2
        PrintAreas()
        DeepRebuild()
    elseif how=="all" then
        areas={} 
        for i=minLen,maxLen do
            for x=sStart,sEnd do
                if i+x-1<=sEnd then
                    areas[#areas+1]={x,x+i-1}
                end
            end
        end
        --PrintAreas() --uncomment if you brave ;]
        DeepRebuild()
    elseif how=="simple" then
        FindWorst()
        PrintAreas()
        DeepRebuild()
    end
end
--[[
    USAGE
1. drw - need minLen and maxLen - finding worst scores by len
2. fj - need len. searching len then cutting in pieces 2->len
3. all - need min and max, rebuilding ENTIRE prorein (from min to max)
4. simple - need len

]]--
----------------- options below VVVV

areas={ --start segment, end segment. uncomment and edit to rebuild only that areas in
--{1,10},
--{20,30},
--{32,35},
}

breakOnPoints=true --breaking rebuild after succesfull one to find new worsts
doShake=false --shake rebuilded area (only!) every rebuild, slowing down process

struct=false --set in all loop (if true work in structure mode)

doPF=true --run PinkFuse after stabilze
fuzeThreshold=-5 --run fuze if we close to best after stabilize

rebuilds=15 --how many rebuilds to try, set at least 10!
rbSkip=2 --skip that many rebuilds b4 scoring (for aunt_deen) ;]

sStart=1 --192 --308 --start segment to search worsts
sEnd=nil --199 --317 --end segment to search worst

reBuild=5 --up to worst parts to look at
len=6 --find worst segments part
minLen=2 --or specify minimum len
maxLen=4 --and maximim len

while true do --uncomment method/s you want to use
  DRcall("drw")
--DRcall("fj")
-- DRcall("all")
-- DRcall("simple")
-- DeepRebuild() --if set "areas" above by hand
end



"
 "type" : "script"
 "uses" : "1"
 "ver" : "0.3"
}
"
 "_recipe_13005" : "{
 "desc" : "Only useful on design puzzles. Mutates every mutatable segment to every possibility, then shakes out.  Do not stop the script during the first part of the run (see output) as it will leave the segments in a bad state. Time to run is proportional to the number of mutatable segments."
 "hidden" : "1"
 "mid" : "8811"
 "mrid" : "14457"
 "name" : "tlaloc Mutate All 3.04"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

-- Conventions used in this file can be found at:
-- http://foldit.wikia.com/wiki/Tlaloc_Script_Standards

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart(500, false)
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = fsl.GetScoreRecentBest()
    if score > _scoreRecentBest then
        _print('++++ ', score, ' ++++')
        _scoreRecentBest = score
    end
end

local function _ReportScoreImprovement(scoreRecentBest)
    if scoreRecentBest == nil then
        scoreRecentBest = fsl.GetScoreRecentBest()
    end
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    local improvement = scoreRecentBest - fsl.GetScoreStart()
    fsl.Print('Overall improvement: ', improvement)
    return improvement
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    fsl.ReportScoreImprovement()
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(tries, saveStart, start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1, tries do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    if saveStart then
        for i=1, count do
            fsl.Print('puzzle #', i, ' has score ', scores[i])
            if i < 10 then
                while true do
                    fsl.ResetPuzzle()
                    if foldit.GetScore(true) == scores[i] then
                        foldit.Quicksave(i)
                        break
                    end
                end
            end
        end
        if start ~= nil then
            fsl.Print('Loading start #', start)
            foldit.Quickload(start)
        else
            fsl.RestoreRecentBest()
        end
    else
        fsl.RestoreRecentBest()
    end

    fsl.Print('There are ', count, ' starts')
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ReportScoreImprovement = _ReportScoreImprovement,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Helixer
--[[
Tries to create regularly spaced helixes using bands.
--]]
local function _Helixer()
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Helixer')
    local countSegments = foldit.GetSegmentCount()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local distanceHelix = 5.5
    local bandIncrement = 1
    local bandStrength = bandIncrement
    local bands = {}
    for i = 1, countSegments do
        if foldit.GetSS(i) == 'H' then
            if i + 3 <= countSegments then
                local helix = true
                for dest = i+1, i+3 do
                     if foldit.GetSS(dest) ~= 'H' then
                        helix = false
                        break
                     end
                end
                if helix then
                   fsl.BandAddBetweenSegments(i, i+3)
                   bands[#bands + 1] = {First = i, Last = i+3}
                   foldit.BandSetStrength(foldit.GetBandCount(), bandStrength)
                   foldit.BandSetLength(foldit.GetBandCount(), distanceHelix)
                end
            end
        end
    end
    while true do
        fsl.MakeStable(true, .1, 10)
        local allFixed = true
        bandStrength = bandStrength + bandIncrement
        if bandStrength > 10 then
            break
        end
        for i = 1, #bands do
            local distance = foldit.GetSegmentDistance(bands[i].First, bands[i].Last)
            fsl.Print('Band ', i, ' distance=', distance)
            if math.abs(distanceHelix - distance) > .1 then
                fsl.Print('Changing band ', i, ' ', bands[i].First, '-', bands[i].Last, ' to ', bandStrength)
                foldit.BandSetStrength(i, bandStrength)
                allFixed = false
            end
        end
        if allFixed then
            break
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local saveSlot = fsl.RequestSaveSlot()
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    
    -- Shake out the protein before starting, otherwise it will be inaccurate
    fsl.MakeStable(true, 1, 5)

    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                fsl.MakeStable(true, .1, 1)

                -- Loop until it iterates over all sidechains without finding any points
                local tryagain
                repeat
                    tryagain = false
                    local scoreBeforeSidechains = foldit.GetScore(true)
                    local scoreRecentBestBeforeSidechains = fsl.GetScoreRecentBest()
                    local positions= foldit.GetSidechainSnapCount(segment)
                    for iSidechains=1, positions do
                        fsl.PrintTries('Sidechain', iSidechains, positions, 'position')
                        foldit.SidechainSnap(segment, iSidechains)
                        foldit.Quicksave(saveSlot)
                        local printStatus = fsl.PrintStatus(false)
                        fsl.WiggleAll(iterations)
                        fsl.PrintStatus(printStatus)
                        
                        local scoreCur = foldit.GetScore(true)
                        local delta = scoreCur - scoreBeforeSidechains
                        local scoreRecentBest = fsl.GetScoreRecentBest()
                        local deltaRecentBest = scoreRecentBest - scoreRecentBestBeforeSidechains
                        --[[
                        fsl.Print('scoreCur=', scoreCur)
                        fsl.Print('scoreBeforeSidechains=', scoreBeforeSidechains)
                        fsl.Print('delta=', delta)
                        --]]
                        if delta <= 0.1 and deltaRecentBest <= 0 then
                            foldit.Quickload(saveSlot)
                        else
                            fsl.Print('Score improved by ', delta, ', trying sidechains again')
                            fsl.Print('Score=', scoreCur, ' Best=', scoreRecentBest)
                            tryagain = true
                            break
                        end
                    end
                until not tryagain
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
                fsl.ReportScoreImprovement()
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    fsl.ReleaseSaveSlot(saveSlot)
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randomtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Helixer = _Helixer,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.MutateAll(1)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_13547" : "{
 "desc" : "This is a variant of step_walker by Datstandin. It backs up and re-irons the protein if a local wiggle increases points. Very good for end game point grinding."
 "hidden" : "0"
 "mid" : "2655"
 "mrid" : "1064"
 "name" : "moon_walker"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "167300"
 "script" : "
-- step walker refresh. Original ideas from Datstandin.

-- updated by smith92clone 31May2010

-- Perform a local wiggle /w campon for each segment, with 1, 2 and 3 segments selected
-- If a wiggle increases in points, backup one segment and wiggle again. Could run a long time.
-- (LF/TAB converted) 6June2010

g_segments = get_segment_count()

function reset_protein()
    set_behavior_clash_importance(1)
    deselect_all()
    do_unfreeze_all()
end

function get_protein_score(segment_count)
    if segment_count == nil then
        segment_count = get_segment_count()
    end
    -- need this function until Fold.it Lua returns negative numbers from get_score()
    local total = 0
    local index
    for index=1,segment_count do
        total = total + get_segment_score(index)
    end
    return total
end

function wiggle_it_out(wiggle_params)
    deselect_all()
    select_all()
    do_global_wiggle_sidechains(wiggle_params.sideChain_count)
    do_shake(wiggle_params.shake)
    do_global_wiggle_all(wiggle_params.all_count)
    restore_recent_best()
end

function do_the_local_wiggle_campon(first,last,wiggle_params)
    deselect_all()
    if last > g_segments then
        last = g_segments
    end
    select_index_range(first,last)
    local end_score = get_protein_score()
    local points_increased = false
    local beginning_score = end_score
    repeat
        start_score = end_score
        do_local_wiggle(wiggle_params.local_wiggle)
        restore_recent_best()
        end_score = get_protein_score()
        print("    start ",start_score," end ", end_score)
    until end_score < start_score + wiggle_params.local_tolerance
    if beginning_score + wiggle_params.local_tolerance < end_score then
        points_increased = true
    end
    --restore_recent_best()
    return points_increased
end

function step_wiggle(start,finish,wiggle_params)
    local i
    local reset
    local rewiggle_increment = 1 -- points
    local rewiggle_score = get_protein_score() + rewiggle_increment
    i = start
    while i <= finish do
        local j
        local saved_changed
        local points_changed = false
        for j = 1,3 do
            print("seg:",i," of ",finish," wiggle Length: ",j)
            saved_changed = do_the_local_wiggle_campon(i,i+j-1,wiggle_params)
            if saved_changed then
                points_changed = true
            end
        end
        if points_changed then
            reset = i - 1 -- we want to go back to the previous segment
            if reset < start then
                reset = start
            end
            for j=1,3 do
                print("retry seg:",reset," of ",finish," wiggle Length: ",j)
                do_the_local_wiggle_campon(reset,reset+j-1,wiggle_params)
            end
            reset = reset + 1
            if reset <= i then
                -- let's not get ahead of ourselves. Only really an issue when we are retrying 1
                for j=1,3 do
                    print("retry seg:",reset," of ",finish," wiggle Length: ",j)
                    do_the_local_wiggle_campon(reset,reset+j-1,wiggle_params)
                end
            end
        end
        local new_score = get_protein_score()
        if new_score > rewiggle_score then
            wiggle_it_out(wiggle_params)
            rewiggle_score = new_score + rewiggle_increment
        end
        i = i + 1
    end
end

reset_protein()
reset_recent_best()
wiggle_params = {}
wiggle_params.local_wiggle = 12
wiggle_params.local_tolerance = 0.00001
wiggle_params.sideChain_count = 15
wiggle_params.shake = 5
wiggle_params.all_count = 15

step_wiggle(1,g_segments,wiggle_params)
"
 "type" : "script"
 "uses" : "1"
 "ver" : "0.3"
}
"
 "_recipe_14750" : "{
 "desc" : "Tries to make protein more compact. All options at end. "
 "hidden" : "1"
 "mid" : "17939"
 "mrid" : "30297"
 "name" : "Compressor v1.9"
 "parent" : "16733"
 "parent_mrid" : "21047"
 "player_id" : "174969"
 "script" : "--[[
    Rav3n_pl Compressor v1.9
    trying to compress protein
    options at end
]]--

--[[
Tlaloc`s math library
------------------------------------------------------------------------
The original random script this was ported from has the following notices:
Copyright (c) 2007 Richard L. Mueller
Hilltop Lab web site - http://www.rlmueller.net
Version 1.0 - January 2, 2007
You have a royalty-free right to use, modify, reproduce, and
distribute this script file in any way you find useful, provided that
you agree that the copyright owner above has no warranty, obligations,
or liability for such use.
------------------------------------------------------------------------
]]--
local lngX = 1000
local lngC = 48313

local function _random(m,n)
    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296
    local H = 65536
    
    function _MWC()
        local S_Hi = math.floor(lngX / H)
        local S_Lo = lngX - (S_Hi * H)
        local C_Hi = math.floor(lngC / H)
        local F1 = A_Hi * S_Hi
        local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
     
        lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)
        lngX = lngX - (math.floor(lngX / M) * M)
        lngC = math.floor((F2 / H) + F1)

        return lngX
    end
    
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / M
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / M) * (n - m + 1)) + m
    end
end

local function _abs(value)
    if value < 0 then
        return -value
    else
        return value
    end
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(s)
    if s==nil then 
        s=math.abs(get_score(true))
        s=s%0.001
        s=1/s
        while s<10000000 do s=s*10 end
        s=s-s%1
    end
    lngX = s
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}
math.randomseed()
--[[ End math library ]]--
function Score()
    return get_score(true)
end

segCnt=get_segment_count()
p=print

function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function down(x)
    return x-x%1
end

function Wiggle(how, iters, minppi)
    if how==nil then how="wa" end
    if iters==nil then iters=6 end
    if minppi==nil then minppi=0.1 end

    if iters>0 then
        iters=iters-1
        sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2)
        end
        ep = Score()
        ig=ep-sp
        if how~="s" then
            if ig > minppi then return Wiggle(how, iters, minppi) end
        end
    end
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end
bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts.")
        bestScore=Score()
        quicksave(3)
    end
end
function qStab()
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    if fastStab==false then
        set_behavior_clash_importance(0.4)
        Wiggle("wa",1)
        set_behavior_clash_importance(1)
        Wiggle("s",1)
    end
    set_behavior_clash_importance(1)
    Wiggle()
    SaveBest()
end
function BlueFuse()
    reset_recent_best()
    select_all()
    set_behavior_clash_importance(0.05)
    do_shake(1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(0.07)
    do_shake(1)
    set_behavior_clash_importance(1)
    Wiggle()
    restore_recent_best()
    set_behavior_clash_importance(0.3)
    do_global_wiggle_all(1)
    set_behavior_clash_importance(1)
    Wiggle()
    restore_recent_best()
    SaveBest()
end
function PinkFuse(slot)
    reset_recent_best()
    quicksave(slot)
    Fuze1(0.1,0.7)
    quickload(slot)
    Fuze1(0.3,0.6)
    quickload(slot)
    Fuze2(0.5,0.7)
    quickload(slot)
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end

function MakeBands(num)
    local done=false
    local s1=math.random(segCnt)
    local s2=math.random(segCnt)

    if s1>s2 then s1,s2=s2,s1 end
    
    local d=get_segment_distance(s1,s2)
    if s2-s1>=minSkip and d>=minDist and d<=maxDist then done=true end
    
    if (done and #useRegions>0) then
        done=false
        for a=1,#useRegions do 
            local ss=useRegions[a][1]
            local se=useRegions[a][2]
            if (s1>=ss and s1<=se) or (s2>=ss and s2<=se) then
                done=true
                break
            end
        end
    end
    
    local ss1=get_ss(s1)
    local ss2=get_ss(s2)

    if (done and noLoops) then
        if ss1=="L" or ss2=="L" then done=false end
    end

    if (done and structure) then
        if ss1=="L" or ss2=="L" then done=false end
    end

    if (done and S2H) then
        if (ss1=="E" or ss2=="E") and (ss1=="H" or ss2=="H") and (ss1~=ss2) then
            done=true
        else
            done=false
        end
    end

    if done then
        num=num-1
        band_add_segment_segment(s1,s2)
        k=get_band_count()
        local len=d-compressFrac
        if len<3.5 then len=3.5 end
        if len>20 then len=20 end
        band_set_length(k,len)
        bands[#bands+1]={s1,s2}
    end

    if num>0 then return MakeBands(num) end --tail call
end
bands={}
function Repeat_bands(bands)
    band_delete()
    for i=1,#bands do
        local s1=bands[i][1]
        local s2=bands[i][2]
        band_add_segment_segment(s1,s2)
        local k=get_band_count()
        local d=get_segment_distance(s1,s2)
        local len=d-compressFrac
        if len<3.5 then len=3.5 end
        if len>20 then len=20 end
        band_set_length(k,len)
    end
end
function Bandstr(str) --set all band strengt
    if str<0.1 then str=0.1 end
    if str>10 then str=10 end
    for i=1, get_band_count() do
        band_set_strength(i, str)
    end
end
function SaveRB(slot)
    quicksave(slot)
    restore_recent_best()
    SaveBest()
    quickload(slot)
end

lastBands=0.6
function Compressor(numTries)
    p("Starting Compressor 1.9, ",numTries," loops.")
    if allLoop then AllLoop() end
    quicksave(3)
    quicksave(7) --save state for losing
    badOnes=0
    reset_recent_best()
    local sscore=Score()
    local best=false
    for i=1,numTries do
        loss=Score()*percLoss/100 --pulling till we lost some points
        band_delete()
        if best==true and repeatGood==true then
            p("Repeating last bands.")
            Repeat_bands(bands)
        else
            bands={}
            MakeBands(numBands)
        end
        local ls=Score()
        p("Compress loop ",i," of ",numTries," started. Current score: ",round(ls))
        set_behavior_clash_importance(pullingCI)
        select_all()
        reset_recent_best()
        if slowBands then
            for str=lastBands,bandStr,0.07 do--search enough band strenght to move
                restore_recent_best()--because sometimes it makes points during pull :D
                local ss=Score()
                Bandstr(str)
                Wiggle("wb",1)
                if ss-Score()>loss then
                    lastBands=str-0.1
                    break
                end
            end
        else
            Bandstr(bandStr)
            Wiggle("wb",1)
        end
        SaveRB(4) --because sometimes it missing fractions
        band_delete()
        qStab()
        if Score()> (bestScore-fuzeScore) then
            SaveBest()
            if useBF then 
                quicksave(4)
                BlueFuse()
                SaveBest()
                quickload(4)
            end
            if usePF then 
                PinkFuse(4)
                SaveBest()
            end
        else
            SaveBest()
        end
        
        if maxLoss>0 then
            if Score()>bestScore-maxLoss then
                quicksave(7) --save actual "best" solution
            else
                badOnes=badOnes+1
                if badOnes >=reloadBest then
                    badOnes=0
                    quickload(3)
                else
                    quickload(7) --load "second best"
                end
            end
        else
            quickload(3)
        end
        local es=Score()
        if es>ls then best=true else best=false end --and es==bestScore --repeating all bands making points
        p("Loop ",i," gain ",round(es-ls)," ;total gain ",round(bestScore-sscore))
    
    end
    quickload(3)
    if allLoop then load_structure() end
    p("Total gain: ",round(Score()-sscore))
end

useRegions={  --set regions that have to be used in all bands
--{1,20}
--{25,55}
--{100,210}
}

minDist=10 --minimum spatial distance between banding segments
maxDist=24 --maximum spatial distance between banding segments
compressFrac=4 --make bands shorter by that much points
minSkip=15 --minimum segment distance between banded segments
numBands=17 --how many bands use at once

fuzeScore=-1 --how close we have to be to run BF/PF
usePF=true --true --use PinkFuse after qStab
useBF=false --true --use BlueFuse after qStab.
            --fuzes are started form SAME state, NOT one after one!
fastStab=true --only 1 shake and 1 wiglle when true
            
allLoop=true --false --work in all-loop mode. sometimes work better than structure mode :)

S2H=false --true --all bands are between sheets and helixes
struct=false --all bands have at least one end on structure (not loop)
noLoops=false --band cant have end on loop

bandStr=1.0 -- max band strenght
slowBands=true --bands strenght are raised few times till score drops by %
percLoss=2 --pulling stops when score drops by that percent (ie 2=200pts when 10k pts)
repeatGood=true --repeating good bands

pullingCI=0.7 --clash impotrance during pull
maxLoss=50 --maximum acceptable LOSS after BF/PF. also lowering fuzeScore
reloadBest=5 --reload best solution after that many worst ones


Compressor(1000) --go! 1000 times :)




"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_14809" : "{
 "desc" : "Testing for best scoring segments then LWS them and buddies.   Take only "big" points by default. Options at end."
 "hidden" : "1"
 "mid" : "4401"
 "mrid" : "30537"
 "name" : "Lucky LWS v2.5"
 "parent" : "4400"
 "parent_mrid" : "3228"
 "player_id" : "174969"
 "script" : "--[[
    Lucky LWS
    serach and LWS best scoring segments
    options at end
]]--

p=print
segCnt=get_segment_count()
function Score()
    return get_score(true)
end
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end

function getpoints()
    t={}
    p("Searching best scoring segments.")
    local ss=Score()
    deselect_all()
    do_unfreeze_all()
    for i=startS, endS do --fill score table
        quicksave(4)
        deselect_all()
        select_index(i)
        local scs=Score()
        do_local_wiggle(1)
        local g=Score()-scs
        t[#t+1]={i,g}
        p("Segment ",i," score: ",g)
        if g<keepTest then quickload(4) end
    end
    p("Test score gain: ",round(Score()-ss))
    return t
end

function wig(mingain)    --score conditioned wiggle,
    repeat                    --wiggles selected segments
        local ss=Score()
        do_local_wiggle(2)
        local wg=Score()-ss
        if wg<0 then
            restore_recent_best()
        end
    until wg<mingain
    deselect_all()
end


function wiggle(s, mingain, buddies)
    p("Wigglin segment ",s)
    deselect_all()
    local sgs=Score()
    select_index(s)
    wig(mingain)
    if buddies > 0 then --select buddies
        for b=1, buddies do
            deselect_all()
            if s+b>endS then select_index_range(s,endS)
            else select_index_range(s,s+b)end
            wig(mingain)
        
            if s-b<startS then select_index_range(startS,s)
            else select_index_range(s-b,s)end
            wig(mingain)

            if s+b>endS then select_index_range(s,endS)
            else select_index_range(s,s+b)end
            if s-b<startS then select_index_range(startS,s)
            else select_index_range(s-b,s)end
            wig(mingain)
        end
    end
    p("Segment gain: ",round(Score()-sgs))
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then 
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end
function Sort(tab,items) -- bubble sorting - lowest on top, only needed items
    if items>#tab then items=#tab end
    for x=1,items do --items do
        for y=x+1,#tab do
            if tab[x][2]<tab[y][2] then
                tab[x],tab[y]=tab[y],tab[x]
            end
        end
    end
    return tab
end
function LuckyLWS()
    if endS==nil then endS=segCnt end
    set_behavior_clash_importance(1)
    do_unfreeze_all()
    AllLoop()
    reset_recent_best()
    sscore=Score()
    besttable=getpoints()
    besttable=Sort(besttable,howmany)
    if howmany>#besttable then howmany=#besttable end
    for i=1, howmany do
        if besttable[i][2]>=LWSonly then
            local seg=besttable[i][1]
            reset_recent_best()
            wiggle(seg, mingain, buddies)
        end
    end
    p("Total gain: ", round(Score()-sscore))
    load_structure()
end

keepTest = 0.1 --keep test points only when gain is more than
LWSonly = 0.05 --do lws only if test more than
howmany = 5 --how many best
mingain = 0.1 --minimum gain per wiggle iterations
buddies = 4 -- how many segments aside should be wiggled too

startS=1
endS=nil

--for i=1,3 do --run 3 times
    LuckyLWS()
--end


"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_15521" : "{
 "desc" : "Rebuilding  Worst Delta .  Need 5 to reset delat.   Based upon Walkin Rebuild but focuses on most impacted.  Leaves secondary structure as is."
 "hidden" : "1"
 "mid" : "16022"
 "mrid" : "19273"
 "name" : "gary Rebuild Worst v0.3"
 "parent" : "15699"
 "parent_mrid" : "18898"
 "player_id" : "184419"
 "script" : "--Gary Rebuild worst delta\
--A modified version of Walkin Rebuild V4\

rav={}\
CG303={}\
game={}\
gary={\
  -- sort a table of talbes on element y\
  -- of the embedded tables\
  BubbleSort = function(x, y)\
    s=gary.CopyScores(x)\
    for i=1,#s - 1 do\
      for j =#s, i + 1, -1 do\
        if s[i][y] < s[j][y] then\
          s[j], s[i] = s[i], s[j]\
        end\
      end\
    end\
    return s\
  end,\

  CopyScores = function(x)\
    copy={}\
    for i=1, #x do\
      copy[i]={x[i][1], x[i][2]}\
    end\
    return copy\
  end,\

  GetSegScores = function()\
    -- set of segment # and score at seg #\
    local scores={}\
    for i=1, game.segCount do --fill score table\
      scores[i]={i, get_segment_score(i)}\
    end\
    return scores\
  end,\

  GetBadRange = function(segW,maxLen)\
    -- get a set of segments up to maxLen with scores worst than segW\
    local segWScore=get_segment_score(segW)\
    local worstFound=true\
    local len=1\
    local segS=segW\
    local segE=segW\
    while (len<maxLen) and worstFound do\
      worstFound=false\
      if segS>1 then\
        if get_segment_score(segS-1) < segWScore then\
          segS=segS-1\
          worstFound=true\
          len=len+1\
        end\
      end\
      if (segE<game.segCount) and (len<maxLen) then\
        if get_segment_score(segE+1) < segWScore then\
          segE=segE+1\
          worstFound=true\
          len=len+1\
        end\
      end\
    end\
    return segS, segE\
  end,\

  ZeroScores = function()\
    -- set of segment # and score at seg #\
    local scores={}\
    for i=1, game.segCount do --fill score table with zeroes\
      scores[i]={i, 0}\
    end\
    return scores\
  end,\

  AddScores = function(s1,s2)\
    -- s1 and s2 need to be same size and order\
    -- no test is performed\
    local delta={}\
    for i=1, #s1 do\
      delta[i]={s1[i][1],s1[i][2] + s2[i][2]}\
    end\
    return delta\
  end,\

  SubtractScores = function(s1,s2)\
    -- s1 and s2 need to be same size and order\
    -- no test is performed\
    local delta={}\
    for i=1, #s1 do\
      delta[i]={s1[i][1], s1[i][2] - s2[i][2]}\
    end\
    return delta\
  end\
}\

function CG303.detect_ligand(flag)\
 --[[\
 ligand puzzle detection\
 normally, segments have a secondary structure of "E", "H" or "L"\
 and they always have a spatial distance of about 3.75 to 3.85 to their next index neighbour.\
 a ligand is more far away.\

 this function should respond true if this is a ligand puzzle, and false if it is not.\
 if flag is nil, ligand auto-detection is enabled, distance of last two segments is checked\
 if flag is not nil, ligand auto-detection is disabled, result is flag\

 It also returns the last segment index which is no ligand\
 ]]--\

 local flag=flag\

 local LastPos=get_segment_count() -- fetch very last segment index number\

 if flag==nil then\
   -- print("Detecting if there is a ligand.")\
   local ss=get_ss(LastPos)\
   flag=not(ss=="L" or ss=="H" or ss=="E" )\
   -- if last segment's ss is neither "L" nor "H" nor "E"\
   flag=flag or (get_segment_distance(LastPos-1,LastPos)>=3.9)\
   -- or distance to second last segment is bigger or equal than 3.9\
 end -- if\

 local os="This should "\
 if flag then\
   LastPos=LastPos-1\
  else\
   os=os.."not "\
 end -- if flag\
 print(os,"be a ligand puzzle.")\

 return flag,LastPos\
end -- function\

function Round(x)--cut all afer 3-rd place\
	return x-x%0.001\
end\

function SelectSphere(sg, radius,nodeselect)\
	if nodeselect~=true then deselect_all() end\
	for i=1, game.segCount do\
	\	if get_segment_distance(sg,i)<radius then select_index(i) end\
	end\
end\

function AllLoop()\
	do_unfreeze_all()\
	select_all()\
	replace_ss("L")\
end\

mingain = 0.05 --minimum gain per 2 wiggle iterations\
buddies = 2 -- how many segments asida should be wiggled too (n, n+1 then n, n-1) \
            -- ie worst segment is no 44 and buddies set to 1 then\
            -- willging seg 43+44; later seg 44+45 \

function wig()\
  local change=false\
  ss=get_score(true)\
  repeat\
    sc=get_score(true)\
    do_local_wiggle(2)\
    se=get_score(true)\
    wg=se-sc\
  until wg<mingain\
  es=get_score(true)\
  if es<ss then \
    restore_recent_best()\
  else\
    change=true\
  end\
  deselect_all()\
  return change\
end\

function wiggle(s)\
        local change=false\
	deselect_all()\
	do_unfreeze_all()\
	if s+1<=game.segCount then select_index(s+1)end\
	if s-1>=1 then select_index(s-1)end \
	do_freeze(true, true)\
	deselect_all()\
	select_index(s)\
	if wig() then change=true end\
	\	\
	if buddies > 0 then --select buddies\
	\	for b=1, buddies do\
	\	\	deselect_all()\
	\	\	do_unfreeze_all()\
	\	\	if s+b+1<=game.segCount then select_index(s+b+1)end\
	\	\	if s-1>=1 then select_index(s-1)end \
	\	\	do_freeze(true, true)\
	\	\	deselect_all()\
	\	\	if s+b>game.segCount then select_index_range(s,game.segCount)\
	\	\	else select_index_range(s,s+b)end\
	\	\	if wig() then change=true end\
	\	\	\
	\	\	deselect_all()\
	\	\	do_unfreeze_all()\
	\	\	if s+1<=game.segCount then select_index(s+1)end\
	\	\	if s-b-1>=1 then select_index(s-b-1)end \
	\	\	do_freeze(true, true)\
	\	\	deselect_all()\
	\	\	if s-b<1 then select_index_range(1,s)\
	\	\	else select_index_range(s-b,s)end\
	\	\	if wig() then change=true end\
	\	\	deselect_all()\
	\	\	do_unfreeze_all()\
	\	end\
	end\
  return change\
end\

function Gibaj(jak, iters, minppi) --score conditioned recursive wiggle/shake\
	if jak==nil then jak="wa" end\
	if iters==nil then \	iters=6 end\
	if minppi==nil then minppi=0.04 end\
	\
	if iters>0 then\
	\	iters=iters-1\
	\	local sp=get_score(true)\
	\	if jak == "s" then do_shake(1)\
	\	elseif jak == "wb" then do_global_wiggle_backbone(1)\
	\	elseif jak == "ws" then do_global_wiggle_sidechains(1)\
	\	elseif jak == "wa" then do_global_wiggle_all(1) \
	\	end\
	\	local ep = get_score(true)\
	\	local ig=ep-sp\
	\	if ig > minppi then Gibaj(jak, iters, minppi) end\
	end\
end\

function BlueFuse(locally)\
	reset_recent_best()\
	if locally ~=true then select_all() end\
	set_behavior_clash_importance(.05)\
	do_shake(1)\
	set_behavior_clash_importance(1)\
	Gibaj()\
	set_behavior_clash_importance(.07)\
	do_shake(1)\
	set_behavior_clash_importance(1)\
	Gibaj()\
	restore_recent_best()\
	set_behavior_clash_importance(.3)\
	do_global_wiggle_all(1)\
	set_behavior_clash_importance(1)\
	Gibaj()\
	restore_recent_best()\
end\

function Lws(mingain)\	--score conditioned local wiggle,\
  local change=false\
  set_behavior_clash_importance(1)\
  if mingain==nil then mingain=1 end\
  repeat --wiggles selected segments\
    local ss=get_score(true)\
    do_local_wiggle(2)\
    local se=get_score(true)\
    local wg=se-ss\
    if wg<0 then\
      restore_recent_best()\
    else\
      change=true\
    end\
  until wg<mingain \
  return change\
end\

function AfterRebuild(lws, bf,locally)\
	if lws==nil then lws=true end\
	if bf==nil then bf=true end\
	reset_recent_best()\
	set_behavior_clash_importance(1)\
	Gibaj("s",1)\
	Gibaj("ws",1)\
	Gibaj("s",1)\
	Gibaj("ws",1)\
	if lws then Lws(2) end\
	if bf then BlueFuse(locally) end\
	select_all()\
	Gibaj()\
end\

function Rebuild(maxIters)--local rebuild until any change\
	if maxIters==nil then maxIters=5 end\
	local s=get_score(true)\
	local i=0\
	repeat\
	\	i=i+1\
	\	if i>maxIters then break end--impossible to rebuild!\
	\	do_local_rebuild(i)\
	until get_score(true)~=s \
	if get_score(true)==s then return false else return true end\
end\

function LocalRebuild(ss,se,maxiters,sphere, lws, bf)\
  local change=false\
  deselect_all()\
  select_index_range(ss,se)\
  local sc=get_score(true)\
  local ok=Rebuild(maxIters)\
  if ok then\
    for s=ss, se do\
      SelectSphere(s,sphere,true)\
    end\
    AfterRebuild(lws,bf,true)\
  end\

  local gain =get_score(true)-sc\
  if gain>0 then\
    quicksave(3)\
    print("Gained: ",get_score(true)-sc," NewScore: ",get_score(true))\
    change=true\
  elseif gain<0 then\
    quickload(3)\
  else\
    print("Unable to rebuild.")\
  end\
  return change\
end\

function Build(sSeg, eSeg, backward, len, maxiters, loopmode, sphere, lws, bf)\
	if backward then\
	\	for i=eSeg, sSeg,-1 do\
	\	\	local ss=i-len+1\
	\	\	if ss>sSeg then\
	\	\	\	LocalRebuild(ss,i,maxiters,sphere, lws, bf)\
	\	\	end\
	\	end\
	else\
	\	for i=sSeg, eSeg do\
	\	\	local se=i+len-1\
	\	\	if se<game.segCount then\
	\	\	\	LocalRebuild(i,se,maxiters,sphere, lws, bf)\
	\	\	end\
	\	end\
	end\
end\

function gary.RebuildDelta(maxLen, maxiters, sphere, lws, bf, minChange, initRebuilds)\
  local sscore = get_score(true)\
  local rebuilds=initRebuilds\
  print("Gary Rebuild Delta started. Score: ",Round(sscore))\
  print("delta calculated after ",initRebuilds," good rebuilds")\
  reset_recent_best()\
  quicksave(3)\
  do_unfreeze_all()\
  deselect_all()\

  local oscores=gary.GetSegScores()\
  local delta=gary.BubbleSort(oscores,2)\
  local i=#delta\
  local segW=delta[i][1]\
  local segS, segE = gary.GetBadRange(segW,maxLen)\
  repeat\
    if segS~=segE then\
      print("Working on sgmnts ",segS,"-",segE," with delta ", delta[i][2])\
    else\
      print("Working on sgmnt ",segS," with delta ", delta[i][2])\
    end\
    local oldScore=get_score(true)\
    if LocalRebuild(segS,segE,maxiters,sphere, lws, bf) then\
      if get_score(true) - oldScore > minChange then\
        minChange=minChange / minChangeDelta\
        if rebuilds>2 then\
          rebuilds=rebuilds-1\
          print("Need ", rebuilds," more.")\
          i=i-1\
        else\
          rebuilds=initRebuilds\
          for x=segS,segE do\
            oscores[x][2]=get_segment_score(x)\
          end\
          nscores=gary.GetSegScores()\
          delta=gary.BubbleSort(gary.SubtractScores(nscores,oscores),2)\
          i=#delta\
        end\
      else\
        i=i-1\
      end\
      if i > 0 then\
        segW=delta[i][1]\
        segS, segE = gary.GetBadRange(segW,maxLen)\
      end\
    else\
      minChange=minChange * minChangeDelta\
      if segS < segE then\
        segS, segE=gary.GetBadRange(segW,segE-segS)\
      else \
        i=i-1\
        if i > 0 then\
          segW=delta[i][1]\
          segS, segE = gary.GetBadRange(segW,maxLen)\
        end\
      end\
    end\
  until i==0\
  print("Total rebuild gain: ",Round(get_score(true)-sscore))\
end\
  \
function ReBuild(sSeg, eSeg, backward, minLen, maxLen, maxiters, loopmode, sphere, lws, bf)\
	local sscore = get_score(true)\
	print("Walking Rebuild started. Score: ",Round(sscore))\
	do_unfreeze_all()\
	deselect_all()\
	if loopmode then\
	\	save_structure()\
	\	AllLoop()\
	end\
	reset_recent_best()\
	quicksave(3)\
	for i=minLen, maxLen do\
	\	Build(sSeg, eSeg, backward, i, maxiters, loopmode, sphere, lws, bf)\
	end\
	\
	print("Total rebuild gain: ",Round(get_score(true)-sscore))\
	if loopmode then load_structure() end\
end\

--[[\
ReBuild(sSeg, eSeg, backward, minLen, maxLen, maxiters, loopmode, sphere, lws, bf)\
sSeg- start segment to rebuild\
eSeg- end segment to rebuild\
backward- start from end\
minLen- minimum sgmnts len to rebuild (may be even 1)\
maxLen- maximum len to rebuild (over 7 seems useless)\
maxiters- maximum tries to rebuild\
loopmode- work in all-loop mode\
sphere- sphere size for shake/wiggle after rebuild\
lws- LWS sphere around (min gain 2pts, not LWSing totally)\
bf- BlueFuze sphere around\
minChange- minimum change to accept as a change\
initRebuilds- Rebuilds needed to calcualte delta.\
]]--\

game.isLigand, game.segCount=CG303.detect_ligand()\

sSeg=1\
eSeg=game.segCount\
backward=false\
minLen=1\
maxLen=2\
maxiters=5\
loopmode=true\
sphere=9\
lws=true\
bf=true\
minChange=0.5\
minChangeDelta=.99\
initRebuilds=5\
--ReBuild(sSeg, eSeg, backward, minLen, maxLen, maxiters, loopmode, sphere, lws, bf)\
gary.RebuildDelta(maxLen, maxiters, sphere, lws, bf, minChange, initRebuilds)\
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_15746" : "{
 "desc" : "Wiggling  worst  and surroundnig segments until  are positive gain.  Ignoring "hidding"scoring part"
 "hidden" : "0"
 "mid" : "12224"
 "mrid" : "14100"
 "name" : "Precise LWS 2.0.1"
 "parent" : "5795"
 "parent_mrid" : "7514"
 "player_id" : "174969"
 "script" : "--Precise LWS by rav3n_pl\
--searches and wiggles worst segments\
--options at end of script\

p=print --"quicker" print ;]\

local function score() --score of puzzle\
	return get_score(true)\
end\


function getPartScore(segments)--using partial scoring\
	local attr = {'packing','backbone','other','bonding','sidechain','clashing'}--,'hiding','reference','disulfides'}\
	local score = 0\
	for i=1,#attr do\
	\	score =  score + get_segment_score_part(attr[i], segments)\
	end\
	return score\
end\

local function getworst() --fill score table\
	worst={}\
	for i=1, get_segment_count() do \
	\	sc=getPartScore(i)\
	\	worst[i]=sc\
	end\
	return worst\
end\

local function wig(mingain)\	--score conditioned wiggle,\
	repeat\	\	\	\	\	--wiggles selected segments\
	\	ss=score()\
	\	do_local_wiggle(2)\
	\	se=score()\
	\	wg=se-ss\
	\	if wg<0 then\
	\	\	restore_recent_best()\
	\	end\
	until wg<mingain \
	deselect_all()\
	do_unfreeze_all()\
end\

local function wiggle(s, mingain, buddies)\
	p("Wigglin segment ",s)\
	deselect_all()\
	do_unfreeze_all()\
	sgs=score()\
	maxi=get_segment_count()\
	if s+1<=maxi then select_index(s+1)end\
	if s-1>=1 then select_index(s-1)end \
	do_freeze(true, true)\
	deselect_all()\
	select_index(s)\
	wig(mingain)\
	\
	if buddies > 0 then --select buddies\
	\	for b=1, buddies do\
	\	\
	\	\	if s+b+1<=maxi then select_index(s+b+1)end\
	\	\	if s-1>=1 then select_index(s-1)end \
	\	\	do_freeze(true, true)\
	\	\	deselect_all()\
	\	\	if s+b>maxi then select_index_range(s,maxi)\
	\	\	else select_index_range(s,s+b)end\
	\	\	wig(mingain)\

	\	\	if s+1<=maxi then select_index(s+1)end\
	\	\	if s-b-1>=1 then select_index(s-b-1)end \
	\	\	do_freeze(true, true)\
	\	\	deselect_all()\
	\	\	if s-b<1 then select_index_range(1,s)\
	\	\	else select_index_range(s-b,s)end\
	\	\	wig(mingain)\

	\	\	if s+b+1<=maxi then select_index(s+b+1)end\
	\	\	if s-b-1>=1 then select_index(s-b-1)end \
	\	\	do_freeze(true, true)\
	\	\	deselect_all()\
	\	\	if s+b>maxi then select_index_range(s,maxi)\
	\	\	else select_index_range(s,s+b)end\
	\	\	if s-b<1 then select_index_range(1,s)\
	\	\	else select_index_range(s-b,s)end\
	\	\	wig(mingain)\
	\	end\
	end\
	sge=score()\
	p("Segment gain: ",sge-sgs)\
end\
function AllLoop()\
	local ok=false\
	local sc=get_segment_count()\
	for i=1, sc do\
	\	local ss=get_ss(i)\
	\	if ss~="L" then \
	\	\	save_structure()\
	\	\	ok=true\
	\	\	break\
	\	end\
	end\
	if ok then\
	\	select_all()\
	\	replace_ss("L")\
	end\
end\
function wiggleworst(howmany, mingain, buddies)\
	set_behavior_clash_importance(1)\
	AllLoop()\
	do_unfreeze_all()\
	deselect_all()\
	reset_recent_best()\
	sscore=score()\
	worst=getworst()\
	for i=1, howmany do\
	p(howmany+1-i, " segments left to do.")\
	\	min=worst[1]\
	\	seg=1\
	\	for f=2,get_segment_count() do\
	\	\	if min>worst[f] then \
	\	\	\	min=worst[f]\
	\	\	\	seg=f\
	\	\	end\
	\	end\
	\	wiggle(seg, mingain, buddies)\
	\	worst[seg]=9999--never again same one\
	end\
	escore=score()\
	p("Total gain: ", escore-sscore, " pts")\
	load_structure()\
end\

howmany = 5 \	--how many worst segments to process\
mingain = 0.3 \	--minimum gain per wiggle iterations (if more per 2 wiggle wiggles again)\
buddies = 3 \	--how many segments aside should be wibbled too\
	\	\	\	--ie worst segment is no 44 and buddies set to 1 then\
	\	\	\	-- willging seg 44 then 43+44; later seg 44+45 and finally 43+44+45\
wiggleworst(howmany, mingain, buddies)\
"
 "type" : "script"
 "uses" : "5"
 "ver" : "0.3"
}
"
 "_recipe_15841" : "{
 "desc" : "Added sphered shake to speed it up. More output, showing progress and gain. Best solution always in slot 3. Can skip or use only setted aas. Options at end."
 "hidden" : "0"
 "mid" : "14914"
 "mrid" : "17646"
 "name" : "Acid Tweeker v1.2"
 "parent" : "9499"
 "parent_mrid" : "10019"
 "player_id" : "174969"
 "script" : "--Acid Tweaker  v1.0 by Steven Pletsch\
--modded by rav3n_pl ;]\

g_segments = get_segment_count()   -- total number of segments in puzzle\
g_total_score = 0   --  recent best to compare to and see if score was improved\
g_score = {}    -- array of segment scores for comparisons (total for segment)\

P=print --a short\

segCount=get_segment_count()\

function Score()\
	return get_score(true)\
end \

function Gibaj(jak, iters, minppi)\
	if jak==nil then jak="wa" end\
	if iters==nil then \	iters=6 end\
	if minppi==nil then minppi=0.1 end\	\
	if iters>0 then\
	\	iters=iters-1\
	\	sp=Score()\
	\	if jak == "s" then do_shake(1)\
	\	\	elseif jak == "wb" then do_global_wiggle_backbone(1)\
	\	\	elseif jak == "ws" then do_global_wiggle_sidechains(1)\
	\	\	elseif jak == "wa" then do_global_wiggle_all(1) \
	\	end\
	\	ep = Score()\
	\	ig=ep-sp\
	\	if jak~="s" then\
	\	\	if ig > minppi then Gibaj(jak, iters, minppi) end\
	\	end\
	end\
end\

function SelectSphere(sg, radius,nodeselect)\
	if nodeselect~=true then deselect_all() end\
	for i=1, segCount do\
	\	if get_segment_distance(sg,i)<radius then select_index(i) end\
	end\
end\

function Round(x)--cut all afer 3-rd place\
	return x-x%0.001\
end\

function Gain(sc)\
	local g=Score()-sc\
	if g>0 then \
	\	P("Gained: ",Round(g)) \
	\	quicksave(3)--always best solution\
	end\
end\
function usableAA(sn)\
	local usable=false\
	if #useOnly > 0 then\
	\	for i=1,#useOnly do\
	\	\	local ss=useOnly[i][1]\
	\	\	local se=useOnly[i][2]\
	\	\	for s=ss,se do\
	\	\	\	if s==sn then \
	\	\	\	\	usable=true\
	\	\	\	\	break \
	\	\	\	end\
	\	\	end\
	\	end\
	else\
	\	usable=true\
	\	if #doNotUse>0 then\
	\	\	for i=1,#doNotUse do\
	\	\	\	local ss=doNotUse[i][1]\
	\	\	\	local se=doNotUse[i][2]\
	\	\	\	for s=ss,se do\
	\	\	\	\	if s==sn then \
	\	\	\	\	\	usable=false\
	\	\	\	\	\	break \
	\	\	\	\	end\
	\	\	\	end\
	\	\	\	if usable==false then break end\
	\	\	end\
	\	end\
	\	\
	\	if #skipAA>0 then\
	\	\	local aa=get_aa(sn)\
	\	\	for i=1,#skipAA do\
	\	\	\	if aa==skipAA[i] then \
	\	\	\	\	usable=false \
	\	\	\	\	break \
	\	\	\	end\
	\	\	end\
	\	end\
	end\
	return usable\
end\

function wiggle_out()\
	set_behavior_clash_importance(.6)\
	do_global_wiggle_all(1)\
	set_behavior_clash_importance(1.)\
	Gibaj()\
	Gibaj("s")\
	set_behavior_clash_importance(.6)\
	Gibaj()\
	set_behavior_clash_importance(1.)\
	select_all()\
	Gibaj()\
	restore_recent_best()\
end\

function sidechain_tweak()\
	P("Pass 1 of 3: Sidechain tweak")\
	for i=1, g_segments do\
	\	if usableAA(i) then\
	\	\	deselect_all()  \
	\	\	select_index(i)\
	\	\	local ss=Score()\
	\	\	g_total_score = Score()\
	\	\	set_behavior_clash_importance(0)\
	\	\	do_shake(2)\
	\	\	set_behavior_clash_importance(1.)\
	\	\	if(Score() > g_total_score -1.) then\
	\	\	\	restore_recent_best()  \
	\	\	else \
	\	\	\	P("Try sgmnt ", i)\
	\	\	\	if(Score() > g_total_score - 30) then\
	\	\	\	\	SelectSphere(i, 10)\
	\	\	\	\	wiggle_out()  \
	\	\	\	else\
	\	\	\	\	SelectSphere(i, 10)\
	\	\	\	\	deselect_index(i)\
	\	\	\	\	set_behavior_clash_importance(.75)\
	\	\	\	\	do_shake(2)\
	\	\	\	\	select_index(i)\
	\	\	\	\	wiggle_out()\
	\	\	\	end\
	\	\	\	Gain(ss)\
	\	\	end\
	\	end\
	end\
end\

function sidechain_tweak_around()\
	P("Pass 2 of 3: Sidechain tweak around")\
	for i=1, g_segments do\
	\	if usableAA(i) then\
	\	\	deselect_all()\
	\	\	for n=1, g_segments do\
	\	\	\	g_score[n] = get_segment_score(n)\
	\	\	end\
	\	\	select_index(i)\
	\	\	local ss=Score()\
	\	\	g_total_score = Score()\
	\	\	set_behavior_clash_importance(0)\
	\	\	do_shake(2)\
	\	\	set_behavior_clash_importance(1. )\
	\	\	if(Score() > g_total_score -1.) then\
	\	\	\	restore_recent_best()  \
	\	\	else \
	\	\	\	P("Try sgmnt ", i)\
	\	\	\	if(Score() > g_total_score - 30) then\
	\	\	\	\	SelectSphere(i,10)\
	\	\	\	\	wiggle_out()  \
	\	\	\	else\
	\	\	\	\	deselect_all()\
	\	\	\	\	for n=1, g_segments do\
	\	\	\	\	\	if(get_segment_score(n) < g_score[n] - 1) then\
	\	\	\	\	\	\	select_index(n)\
	\	\	\	\	\	end\
	\	\	\	\	end\
	\	\	\	\	deselect_index(i)\
	\	\	\	\	set_behavior_clash_importance(0.1)\
	\	\	\	\	do_shake(2)\
	\	\	\	\	SelectSphere(i,10,true)\
	\	\	\	\	wiggle_out()\
	\	\	\	end\
	\	\	\	Gain(ss)\
	\	\	end\
	\	end\
	end\
end\

function sidechain_manipulate()\
	P("Last pass: Brute force sidechain manipulator")\
	for i=1, g_segments do\
	\	if usableAA(i) then\
	\	\	deselect_all()\
	\	\	rotamers = get_sidechain_snap_count(i)\
	\	\	quicksave(4)\
	\	\	if(rotamers > 1) then\
	\	\	\	local ss=Score()\
	\	\	\	P("Sgmnt: ", i," positions: ",rotamers)\
	\	\	\	for x=1, rotamers do\
	\	\	\	quickload(4)\
	\	\	\	g_total_score = Score()\
	\	\	\	do_sidechain_snap(i, x)\
	\	\	\	set_behavior_clash_importance(1.)\
	\	\	\	\	if(Score() > g_total_score -1.) then\
	\	\	\	\	\	restore_recent_best()  \
	\	\	\	\	else \
	\	\	\	\	\	if(Score() > g_total_score - 30) then\
	\	\	\	\	\	\	SelectSphere(i,10)\
	\	\	\	\	\	\	wiggle_out()  \
	\	\	\	\	\	else\
	\	\	\	\	\	\	SelectSphere(i,10)\
	\	\	\	\	\	\	deselect_index(i)\
	\	\	\	\	\	\	set_behavior_clash_importance(.75)\
	\	\	\	\	\	\	do_shake(2)\
	\	\	\	\	\	\	select_index(i)\
	\	\	\	\	\	\	wiggle_out()\
	\	\	\	\	\	end\
	\	\	\	\	end  \
	\	\	\	end\
	\	\	\	Gain(ss)\
	\	\	end\
	\	end\
	end\
end\

--g_segments=g_segments-1 -- uncomment for lingard puzzles only!\
useOnly={ --ranges what have to be used OVERRIDES BOTH LOWER OPTIONS\
--{12,24},\
--{66,66},\
}\
doNotUse={ --ranges that should be skipped \
--{55,58},\
--{12,33},\
}\
skipAA={ --aa codes to skip\
{'a'},\
{'g'},\
}\

reset_recent_best()\
quicksave(3)--in save 3 always best solution. Load in case of crash.\
s1=Score()\
sidechain_tweak()\
s2=Score()\
P("Tweak gain: ",Round(s2-s1))\
sidechain_tweak_around()\
s3=Score()\
P("Around gain: ",Round(s3-s2))\
sidechain_manipulate()\
s4=Score()\
P("Start score: ",Round(s1))\
P("Tweak gain: ",Round(s2-s1))\
P("Around gain: ",Round(s3-s2))\
P("Manipulate gain: ",Round(s4-s3))\
P("Totoal Acid gain: ",Round(s4-s1))\
P("End score: ",Round(s4))\
"
 "type" : "script"
 "uses" : "2"
 "ver" : "0.3"
}
"
 "_recipe_17333" : "{
 "desc" : "Lots of changes, all options at end"
 "hidden" : "1"
 "mid" : "14267"
 "mrid" : "16580"
 "name" : "GA Bands 1.4"
 "parent" : "13923"
 "parent_mrid" : "16424"
 "player_id" : "174969"
 "script" : "--[[\
    THIS MOD WILL NOT WORK ON "CONDITIONED" PUZZLES PROPERLY!\
    \
	Beware: Ugly code ahead. And I mean it!\
	\
	A _primative_ genetic algorithm on bands.\

    Run this in the early to mid game, after you have\
    a general structure but long before you do your tweaks\
    to get the last few fractions of a point.\

    A brief overview:\

    1) [Optional] Create some bands that you think may help the fold.\
       The bands that you create will not be modified.  Note, that the\
       bands that you create do not have to be anchored at both ends.\

    2) This script will fill in random bands to make a enuf bands so that\
       the genetic algorithm can run smoothly.  These bands will be\
       anchored and they may be deleted by the script.\

    3) The script generates a "herd" of random critters, a critter is a\
       subset of all of the bands both user and script generated.\

    4) Score how well each critter (band subset) does.\

    5) Keep the best critters and kill the rest.\

    6) "Breed" the critters you kept by mixing rougly half of the bands\
       from the "mom" with half of the bands from the "dad" critter. Do\
       this until you have filled the herd back up.\

    7) Some critters are mutated during breeding. A mutation is\
       the replacement of one of the critter's bands with another\
       randomly chosen band.\

    8) If the scores aren't going anywhere after a few generations\
       start over with a new herd and a new set of script generated\
       bands, step 2.\

    9) Repeat from the scoring step (4) until the max generation is\
       reached or we can't lock the script generated bands.\

    This is a greedy GA, we keep score increases as soon as they occur.\
    If it's half way thru scoring a generation then so be it. This is why\
    we use relative improvements as a critter score.\
--]]\
-----------------------------------------\
-- math library\

------------------------------------------------------------------------\
-- The original random script this was ported from has the following notices:\
-- Copyright (c) 2007 Richard L. Mueller\
-- Hilltop Lab web site - http://www.rlmueller.net\
-- Version 1.0 - January 2, 2007\
-- You have a royalty-free right to use, modify, reproduce, and\
-- distribute this script file in any way you find useful, provided that\
-- you agree that the copyright owner above has no warranty, obligations,\
-- or liability for such use.\
------------------------------------------------------------------------\

local lngX = 1000\
local lngC = 48313\

local function _MWC()\
    local S_Hi\
    local S_Lo\
    local C_Hi\
    local C_Lo\
    local F1\
    local F2\
    local F3\
    local T1\
    local T2\
    local T3\

    local A_Hi = 63551\
    local A_Lo = 25354\
    local M = 4294967296\

    local H = 65536\

    local S_Hi = math.floor(lngX / H)\
    local S_Lo = lngX - (S_Hi * H)\
    local C_Hi = math.floor(lngC / H)\
    local C_Lo = lngC - (C_Hi * H)\

    local F1 = A_Hi * S_Hi\
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\
    local F3 = (A_Lo * S_Lo) + C_Lo\

    local T1 = math.floor(F2 / H)\
    local T2 = F2 - (T1 * H)\
    lngX = (T2 * H) + F3\
    local T3 = math.floor(lngX / M)\
    lngX = lngX - (T3 * M)\

    lngC = math.floor((F2 / H) + F1)\

    return lngX\
end\

local function _abs(value)\
    if value < 0 then\
        value = -value\
    end\
    return value\
end\

local function _floor(value)\
    return value - (value % 1)\
end\

local function _randomseed(x)\
    lngX = x\
end\

local function _random(m,n)\
    if n == nil and m ~= nil then\
        n = m\
        m = 1\
    end\
    if (m == nil) and (n == nil) then\
        return _MWC() / 4294967296\
    else\
        if n < m then\
            return nil\
        end\
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m\
    end\
end\

math=\
{\
    abs = _abs,\
    floor = _floor,\
    random = _random,\
    randomseed = _randomseed,\
}\

-- End math library\
-----------------------------------------\
function Score()\
	return get_score(true)\
end \
math.randomseed(math.abs(Score()))\

segCnt=get_segment_count()\
p=print\

function round(x)--cut all afer 3-rd place\
	return x-x%0.001\
end\
function down(x)\
	return x-x%1\
end\

function Gibaj(jak, iters, minppi)\
	if jak==nil then jak="wa" end\
	if iters==nil then \	iters=6 end\
	if minppi==nil then minppi=0.1 end\
	\
	if iters>0 then\
	\	iters=iters-1\
	\	sp=Score()\
	\	if jak == "s" then do_shake(1)\
	\	\	elseif jak == "wb" then do_global_wiggle_backbone(1)\
	\	\	elseif jak == "ws" then do_global_wiggle_sidechains(1)\
	\	\	elseif jak == "wa" then do_global_wiggle_all(1) \
	\	end\
	\	ep = Score()\
	\	ig=ep-sp\
	\	if jak~="s" then\
	\	\	if ig > minppi then Gibaj(jak, iters, minppi) end\
	\	end\
	end\
end\
function AllLoop() --turning entire structure to loops\
	local ok=false\
	for i=1, segCnt do\
	\	local s=get_ss(i)\
	\	if s~="L" then \
	\	\	save_structure()\
	\	\	ok=true\
	\	\	break\
	\	end\
	end\
	if ok then\
	\	select_all()\
	\	replace_ss("L")\
	end\
end\
function BlueFuse()\
	reset_recent_best()\
	select_all()\
	set_behavior_clash_importance(0.05)\
	do_shake(1)\
	set_behavior_clash_importance(1)\
	Gibaj()\
	set_behavior_clash_importance(0.07)\
	do_shake(1)\
	set_behavior_clash_importance(1)\
	Gibaj()\
	restore_recent_best()\
	set_behavior_clash_importance(0.3)\
	do_global_wiggle_all(1)\
	set_behavior_clash_importance(1)\
	Gibaj()\
	restore_recent_best()\
end\

function wsw(minppi, nows)\
	set_behavior_clash_importance(1)\
	if nows==nil then nows=false end--no wiggle sidechain, start whith shake\
	repeat\
	\	local s1=Score()\
	\	if nows==false then do_global_wiggle_sidechains(1) end\
	\	do_shake(1)\
	\	local s3=Score()\
	\	do_global_wiggle_sidechains(1)\
	\	local s4=Score()\
	\	local g=s4-s1\
	\	nows=true\
	\	if s4-s3<minppi/10 then break end --no point to shake again\
	until g<minppi\
end\
function wswTest()\
	quicksave(8)\
	wsw(1,true) --shake first\
	quickload(8)\
	wsw(1,false) --wiggle first\
end\
function qStabilize(fasst)\
	set_behavior_clash_importance(1)\
	do_unfreeze_all()\
	select_all()\
	reset_recent_best()\
	if fasst==true then\
	\	Gibaj()\
	else\
	\	if fastWSW then\
	\	\	wsw(1,true)\
	\	\	Gibaj()\
	\	\	wsw(1,false)\
	\	else\
	\	\	repeat\
	\	\	\	local g=Score()\	\
	\	\	\	wswTest()\
	\	\	\	restore_recent_best()\
	\	\	\	Gibaj()\
	\	\	\	g=Score()-g\
	\	\	until g<1 --min 1pt form s/w/wa\
	\	end\
	\	if doBF then BlueFuse() end\
	end\
end\

function CanBeUsed(sg1,sg2) --checking end of bands\
	local ok=true\
	if #DoNotUse>0 then --none of 2 can be in that area\
	\	for i=1, #DoNotUse do\
	\	\	local r=DoNotUse[i]\
	\	\	for x=r[1],r[2] do\
	\	\	\	if x==sg1 or x==sg2 then\
	\	\	\	\	ok=false\
	\	\	\	\	break\
	\	\	\	end\
	\	\	end\
	\	\	if ok==false then break end\
	\	end\
	end\
	if ok==false then \
	\	return false --if false can`t be used\
	else\
	\	ok=false\
	\	if #AlwaysUse>0 then --at least one have to be there\
	\	\	for i=1, #AlwaysUse do\
	\	\	\	local r=AlwaysUse[i]\
	\	\	\	for x=r[1],r[2] do\
	\	\	\	\	if x==sg1 or x==sg2 then\
	\	\	\	\	\	ok=true\
	\	\	\	\	\	break\
	\	\	\	\	end\
	\	\	\	end\
	\	\	\	if ok==true then break end\
	\	\	end\
	\	else\
	\	\	ok=true\
	\	end\
	\	return ok --if true can be used\
	end\	\
end\

-- Per critter parameters\
Critter = {\
    idCounter = 0, -- Used to generate critter IDs\
    minBands  = 2, -- Min number of bands\
    maxBands  = 5, -- Max number of bands\
}\

-- Parameters dealing with the herd\
Herd = {\
    keep           = 3,  -- This many survive to next generation\
    breed          = 5,  -- Breed this many replacements\
    generation     = 1,  -- What generation is this\
    maxGeneration  = 20, -- Quit after this many generations\
    improvementWas = 0,  -- How good did the last generation do\
    scoreBefore    = 0,  -- Score at the start of a generation\
    rebootLimit    = 2,  -- Reboot after this many 0 improvement generations\
    rebootCount    = 0,  -- How close are we to the reboot limit\
    mutateRate     = 4,  -- On average mutate 1 out this many new borns\
    rebootScore    = 0.1, -- Only increment reboot count when below this\
    startingScore  = Score(), -- Score at the start of the script\
}\
Herd.size = Herd.keep + Herd.breed\

-- Parameters dealing with bands\
Band = {\
    userMade    = get_band_count(), -- How many bands did user enter\
    maxLength   = 20,\
    minStrength = 0.1,\
    maxStrength = 1,\
    locked      = false, -- Were we able to lock the script generated bands\
}\

-- How many random bands to make\
Band.scriptMade = (Herd.size * Critter.maxBands) - Band.userMade\

-- A random float between [0, 1)\
function RandomFloat()\
    return math.random()\
end\

 -- A random int between [1, high]\
function RandomInt(high)\
	return math.random(high)\
end\

-- Generate a random band\
function CreateBand()\
    local start  = RandomInt(segCnt)\
	local finish = RandomInt(segCnt)\
	if CanBeUsed(start,finish) and--at least one need to be in place\
	\	math.abs(start-finish)>= minDist and --do not band if too close\
	\	get_segment_distance(start,finish) < maxBandDist and--not band if too far away\
	\	start~=finish --not make band to same place\
	then\
	\	band_add_segment_segment(start, finish)\
	\	local range    = Band.maxStrength - Band.minStrength\
	\	local strength = (RandomFloat() * range) + Band.minStrength\
	\	local n = get_band_count()\
	\	if n > 0 then band_set_strength(n, strength) end\
	\	\
	\	local length = 3+ (RandomFloat() * (Band.maxLength-3)) --min len is 3\
	\	\
	\	if push then\
	\	\	local dist = get_segment_distance(start,finish)\
	\	\	if dist >2 and dist <18 then length=dist*1.5 end\
	\	\	if length >20 then length=20 end\
	\	end\
	\	\
	\	if hydroPull then\
	\	\	if is_hydrophobic(start) and is_hydrophobic(finish)  then \
	\	\	\	length=3 --always pull hydrophobic pair\
	\	\	end\
	\	end\
	\	\
	\	if n > 0 then band_set_length(n, length) end\	\	\	\	\
	else\
	\	CreateBand()\
	end\
end\

function CreateBands()\
    local i\
    for i = 1, Band.scriptMade do\
        CreateBand()\
    end\
end\

function DeleteScriptMadeBands()\
    if Band.userMade==0 then \
	\	band_delete() --if no user bands del them all\
	else \
	\	local b\
	\	for b = get_band_count(), Band.userMade + 1, -1 do\
	\	\	band_delete(b)\
	\	end\
	end\
end\

function DisableAllBands()\
    band_disable()\
end\

function EnableCritterBands(critter)\
    local b\
    for b = 1, critter.bands do\
        band_enable(critter.band[b])\
    end\
end\

-- Default critter constructor\
function NewCritter()\
    Critter.idCounter = Critter.idCounter + 1\
    local critter = { bands = 0, score = -999999, age = 0, mutated = false }\
    critter.id = Herd.generation .. "_" .. Critter.idCounter\
    critter.band = {}\
    return critter\
end\

-- Constructor for generating a completely random critter\
function RandomCritter()\
    local i\
    local critter = NewCritter()\
    critter.mutated = true\
    critter.id = critter.id .. "r"\
    critter.bands = RandomInt(Critter.maxBands - Critter.minBands)\
                  + Critter.minBands\
    local max = get_band_count()\
    for i = 1, critter.bands do\
        critter.band[i] = RandomInt(max)\
    end\

    return critter\
end\

-- Lock in the script generated bands so that they will\
-- appear when we do a restore_abs_best()\
-- I would love to replace this with a slotted recent best\
function LockBands()\
	set_behavior_clash_importance(1)\
    if Band.scriptMade <= 0 then\
        Band.locked = true\
        return\
    end\
	reset_recent_best() --save bands\
    Band.locked = true\
	p("Bands locked")\
end\

-- Generate a random heard. This includes all new critters,\
-- and a new set of script generated bands\
function RandomHerd()\
    local i\
    DeleteScriptMadeBands()\
    CreateBands()\
    DisableAllBands()\
    LockBands()\
    for i = 1, Herd.size do\
        Herd[i] = RandomCritter()\
        p("randomize: ", Herd[i].id)\
    end\
end\

function ScoreHerd()\
    local i\
    -- Do not rescore if it will not change... or shouldn't change\
    local first = 1\
    if Herd.improvementWas <= 0 then first = Herd.keep + 1 end\
	local hs=Score()\
    for i = 1, Herd.size do\
	\	quicksave(3) --restore it if no gain\
        local label   = "  unchanged score: "\
        local critter = Herd[i]\

        if i >= first or critter.mutated then\
            label = "  score: "\
            local startingScore = Score()\

            DisableAllBands()\
            EnableCritterBands(critter)\
	\	\	select_all()\
	\	\	\
	\	\	set_behavior_clash_importance(wiggleCI)\
            do_global_wiggle_backbone(1)\
	\	\	set_behavior_clash_importance(1)\
            DisableAllBands()\
	\	\	if fuzeOnly then\
	\	\	\	BlueFuse()\
	\	\	else\
	\	\	\	local fasst=false\
	\	\	\	if math.abs(Score()-startingScore)<1 then fasst=true end\
	\	\	\	qStabilize(fasst)\
	\	\	end\

            critter.score = Score() - startingScore\
	\	\	\
	\	\	if critter.score<= 0 and critter.score>-0.1 then \
	\	\	\	critter.score=-999 --no change, leawing it\
	\	\	end\
	\	\	\
	\	\	if critter.score<0 then \
	\	\	\	quickload(3) --negative score\
	\	\	else\
	\	\	\	quicksave(3) --good score\
	\	\	end \
        end\

        critter.age = critter.age + 1\
        critter.mutated = false\
        p("critter: ", critter.id, label, round(critter.score))\
    end\
	\
	if mutate and Score()-hs>1 then--if more than 1pt change\
	\	select_all()\
	\	do_mutate(1)\
	end\
end\

function SwapCritter(a, b)\
	Herd[a],Herd[b]=Herd[b],Herd[a]--yes! in LUA you can do that!\
end\

-- A quasi sort function. Only sort what is kept.\
-- A small N means that I'm OK with this being a quadratic sort\
function CullHerd()\
    local weakest = 1 -- Survivor with the lowest score\
    local i, j\

    for i = 2, Herd.size do\
        if Herd[i].score > Herd[weakest].score then\
            SwapCritter(i, weakest)\
            j = weakest\
            while j > 1 and Herd[j].score > Herd[j-1].score do\
                SwapCritter(j, j-1)\
                j = j - 1\
            end\
        end\
        weakest = weakest + 1\
        if weakest > Herd.keep then weakest = Herd.keep end\
    end\

    for i = 1, Herd.keep do\
        p("kept: ", Herd[i].id, "  score: ", round(Herd[i].score))\
    end\
end\

-- Mix bands from the mom and dad critter, rougly half from each\
function BreedPair(mom, dad)\
    local kid = NewCritter()\
    local k, i, b = 0, 0, 0\

    -- Choose bands from the mom\
    b = RandomInt(mom.bands)\
    for i = 1, (mom.bands / 2) + 0.5 do\
        k = k + 1\
        kid.band[k] = mom.band[b]\

        b = b + 1\
        if b > mom.bands then b = 1 end\
    end\

    -- Choose bands from the dad\
    b = RandomInt(dad.bands)\
    for i = 1, dad.bands / 2 do\
        k = k + 1\
        kid.band[k] = dad.band[b]\

        b = b + 1\
        if b > dad.bands then b = 1 end\
    end\

    kid.bands = k\
    return kid\
end\

-- Breed survivors with each other\
-- 1st breeds w/ 2nd and 2nd w/ 3rd etc.\
-- When that's done 1st breeds w/ 3rd and so on.\
function BreedHerd()\
    local mom, dad, kid = 0, 0, 0\
    local step = 0 -- Dad is this far away from mom +1\
    local keep = Herd.keep\

    for kid = keep + 1, Herd.size do\
        mom = mom + 1\
        if mom > keep then\
            mom = 1\
            step = step + 1\
        end\
        dad = ((mom + step) % keep) + 1\
        Herd[kid] = BreedPair(Herd[mom], Herd[dad])\
        p("breeding:  mom: ", Herd[mom].id,\
                       "  dad: ", Herd[dad].id,\
                       "  kid: ", Herd[kid].id)\
    end\
end\

-- Mutate a random selection of the new born critters. A mutation\
-- is the replacement of one of the critter's randomly chosen bands\
-- with another band randomly choosen from the entire band set.\
function MutateHerd()\
    local i, zap, new, mutate, max\
    max = get_band_count()\
    for i = Herd.keep + 1, Herd.size do\
        mutate = RandomInt(Herd.mutateRate)\
        if mutate == 1 then\
            zap = RandomInt(Herd[i].bands)\
            new = RandomInt(max)\
            Herd[i].band[zap] = new\
            Herd[i].mutated   = true\
            Herd[i].id        = Herd[i].id .. "m"\
            p("Mutating: ", Herd[i].id, "  zapped: ", zap)\
        end\
    end\
end\

function reset() --reset counters to next GA run\
	Herd.rebootCount = 0\
	Herd.generation = 0\
end\
function ga()\
	if allLoop then AllLoop() end\
	quicksave(3)\
	select_all()\
	RandomHerd()\

	while Band.locked and Herd.generation <= Herd.maxGeneration do\
	\	p("")\
	\	p("generation: ", Herd.generation)\

	\	if Herd.rebootCount >= Herd.rebootLimit then\
	\	\	RandomHerd()\
	\	\	Herd.rebootCount = 0\
	\	end\
	\	Herd.generation = Herd.generation + 1\

	\	Herd.scoreBefore = Score()\

	\	ScoreHerd()\
	\	CullHerd()\
	\	BreedHerd()\
	\	MutateHerd()\

	\	Herd.improvementWas = Score() - Herd.scoreBefore\
	\	p("score: ",             round(Score()))\
	\	p("improvement: ",       round(Herd.improvementWas))\
	\	p("total improvement: ", round(Score() - Herd.startingScore))\

	\	if Herd.improvementWas < Herd.rebootScore then\
	\	\	Herd.rebootCount = Herd.rebootCount + 1\
	\	else\
	\	\	Herd.rebootCount = 0\
	\	end\
	\	p("reboot count: ", Herd.rebootCount, "  limit: ", Herd.rebootLimit)\
	end\

	DeleteScriptMadeBands()\
	if allLoop then load_structure() end\
	LockBands()\
	if gaForEver then \
	\	reset()\
	\	ga() \
	end\
end\

DoNotUse={--just comment lines below or add more areas to avoid\
--{120,134},\
--{1,10},\
}\
AlwaysUse={ --areas should be always used\
--{segCnt,segCnt},\
--{20,35}\
}\

gaForEver=true --run in permament loop\
allLoop=false --run in all-loop mode (sometimes works better!)\

fastWSW=true --when releasing use less acurate point finding\
doBF=false --true --blufuze after stabilize\

maxBandDist=19 --maximum dostance (in "points") between banding segments\
Band.minStrength=0.3 --minimum band STR\
Band.maxStrength=1.1 --maximum band STR\
minDist=down(segCnt/5)  --minimum dist (in segments) between banded segments\
wiggleCI=0.8 --clash impotrance during push/pull\
hydroPull=false --always pul hydrophobic pair\
push=false --true --always push when possible (hydros may be excluded)\


fuzeOnly=false --make BF right after every pull. no stabilize\
mutate=false --true --do mutate(1) each generation\

ga()\
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_20642" : "{
 "desc" : "Somewhat improved over 1.0.  The default settings work pretty well  but read  the top  of the script to see  what options  are available."
 "hidden" : "1"
 "mid" : "15475"
 "mrid" : "18527"
 "name" : "Sidechain flipper 2.0"
 "parent" : "15384"
 "parent_mrid" : "18402"
 "player_id" : "3010"
 "script" : "start_idx =  15                             -- change to another residue id for a bit of variety
start_from_best = false            -- set to false if you want to start from the current configuration, not the best. 

--   For each  rotamer postion of each side chain, does  a flip, freeze, shake, unfreeze, wiggle, shake, wiggle.
--   Most generally, if the first shake fails to produce an improvement in the score,  stops working on that rotamer position and proceeds to the next.

level = 2

-- level 1. Flip Leu and Ile only. Flipping these tend to be the most productive. although Glu is a close third.
-- level 2. Default. Best trade-off between potential gain and speed.
-- level 3. Tries more positions. Unlike the lower 2 levels, does not require that on the first shake an additional side chain be flipped.
-- level 4.  Foregoes  the freeze-shake-unfreeze bit of the algorithm entirely.  This can result in severe disruption to the protein structure.  Not terribly useful except perhaps in the opening.

post_scramble = 2

-- post_scramble = 1.  No sidechain scramble.  Won't leak walk juice.
-- post_scramble = 2.   Does a brief scramble  iff  a flip gets within two  (see kScrambleThreshold) points of the original. 

kScrambleThreshold = 2        

--    Amino acids. Hydrophobics first.

single_letter_codes = { "g","a","v","l","i","m","f","w","p","s","t","c","y","n","q","d","e","k","r","h"}
three_letter_codes  = { "Gly","Ala","Val","Leu","Ile","Met","Phe","Trp","Pro","Ser","Thr","Cys","Tyr","Asn","Gln","Asp","Glu","Lys","Arg","His"}


function get_aa3 ( i )

    k = get_aa (  i )

    for  j = 1, 20 do
        if ( k == single_letter_codes [  j ] ) then
            return three_letter_codes [  j  ]
        end
    end

    return "Unk"

end

function Coprime ( n )

--    returns a number that has no common factor with n.  Something of a hack but
--    it seems unlikely we'll ever have  puzzles with less than 31 or more than 1146 residues

    if ( n < 31 ) then
       return 1
      elseif ( n >= 31*37 ) then
        return 1
      elseif ( n%31 ~= 0 ) then
        return 31
       else
        return 37
    end

end

function pseudorandom ( score )

    -- Returns a pseudorandom number >= 0 and < 1.
    -- Based on the fractional  part of the  score

    if ( score >= 0 ) then
      return  score % 1
     else
      return (-score ) % 1
    end

end

function nudge (  score )

    select_all ()
    set_behavior_clash_importance ( 0.2  + 0.2 * pseudorandom ( score ) )
    do_global_wiggle_all ( 1 )
    set_behavior_clash_importance ( 1 )
    do_global_wiggle_all ( 8 )
end

function quick_nudge ( score )

    select_all ()
    reset_recent_best ()
    set_behavior_clash_importance ( 0.1 * pseudorandom ( score )  )
    do_shake ( 1 )
    set_behavior_clash_importance  ( 1 )
    do_global_wiggle_all ( 8 )
    do_shake ( 1  )
    do_global_wiggle_sidechains  ( 1 )
    restore_recent_best ()

end

function  Go ( n )

    inc =  Coprime ( n )
    idx  = start_idx

    --    use this to go through the protein in a  less than regular way

    for  i = 1 , n  do

        n_rotamers = get_sidechain_snap_count ( idx  )

        aa = get_aa3 ( idx )

        if ( leu_ile_only == false or aa == "Leu" or aa  == "Ile" ) then

            print (  aa , " " , idx ,  " (", i, "/", n,")", " n_rotamers " , n_rotamers )

            r = 1
            improvement_made = false

            --  Lysines and arginines  can have  40 or  rotamers and its wasteful to go through them all: flipping the
            -- sidechains of those amino  acids rarely works anyway
            -- Till there's  something in the API that allows  identification  of the  residue, restrict the  number of attempts

            n_attempts = 0
            while ( r <= n_rotamers and improvement_made == false  and n_attempts < max_attempts ) do
                
                quickload ( 1 )
                select_all ()

                do_sidechain_snap ( idx , r )
                score_after_snap = get_score ()
                 
                --print (  "rotamer ", r , " n_attempts ", n_attempts  )

                snap_loss =  best_score - score_after_snap

                if (  snap_loss <  0 ) then
                    
                     -- Can conceivably happen

                    if  ( post_scramble  > 1 ) then
                       quick_nudge ( score_after_snap )
                    end

                    quicksave ( 1 )
                    best_score  = score_after_snap
                    improvement_made = true

                    print (  "Immediate improvement at ", idx )
                    print ( "best score ", best_score )

                    n_attempts  = n_attempts + 1

                elseif (  snap_loss >  min_snap_loss ) then

                     -- If  snapping changes it by less than 100, either we are  already at the current rotamer position 
                     -- or this technique is unlikely to produce a gain

                    n_attempts = n_attempts + 1

                    gain_from_shake = 0

                    if (  level < 4 ) then
                        deselect_all ()
                        select_index  ( idx )

                        do_freeze (  false , true )
                     
                        select_all ()

                        do_shake ( 1 )
                        score_after_shake  = get_score ()
                        gain_from_shake =  score_after_shake - score_after_snap

                        do_unfreeze_all ()
                      else
                        score_after_shake = score_after_snap
                        gain_from_shake = 0
                    end

                    if ( gain_from_shake  >  lowest_allowable_shake_gain and best_score - score_after_shake < max_shake_loss ) then
                    
                        --print ( "score after shake " , best_score - score_after_shake )

                        do_global_wiggle_all ( 15 )
                        score_after_wiggle  = get_score ()

                        do_shake ( 1 )
                        score_after_second_shake = get_score ()
                    
                         if ( score_after_second_shake - score_after_wiggle > 0.5 ) then
                            do_global_wiggle_all ( 10 )
                            score_after_second_wiggle = get_score ()
                            
                            if (  score_after_second_wiggle - score_after_second_shake  < 1  and 
                                   best_score - score_after_second_wiggle < 30 ) then
                                nudge ( score_after_second_wiggle )
                                score_after_nudge = get_score ()
                                --print ( "Gain from nudge " , score_after_nudge - score_after_second_wiggle )
                                if ( score_after_nudge > score_after_second_wiggle ) then
                                    score = score_after_nudge
                                 else
                                    score = score_after_second_wiggle
                                end
                              else
                                score = score_after_second_wiggle
                            end

                        else
                            score = score_after_second_shake
                        end                
                    
                        
                        if (  best_score - score  <  kScrambleThreshold  and post_scramble  == 2 )  then
                            quick_nudge ( score )
                            score = get_score ()                     
                        end

                        if ( score > best_score ) then
                            
                          do_shake ( 1 )
                          quicksave ( 1 )
                          best_score = get_score ()

                          print ( "Improvement at " ,  idx  )
                          --print ( "best score ", best_score ,  " snap loss " , snap_loss  , "  shake gain " , gain_from_shake )
                          print  ( "best_score ", best_score )

                          improvement_made = true;
                                                 
                        end

                        if ( improvement_made == false ) then
                            if ( score  >  score_in_qs10 ) then
                                quicksave ( 10 )
                                score_in_qs10 = score 
                                --print ( "Quicksave 10 " , score )
                             end
                        end

                    end        -- if shake improved things

                end        -- if not current rotamer position

                r = r + 1

            end

             if (  n_attempts > max_attempts  and improvement_made == false ) then
                print  ( "R " , r  )
             end

        end

        idx = idx + inc
        if ( idx  > n ) then
          idx = idx - n
        end

    end    -- for i

end

n_residues  = get_segment_count ()
set_behavior_clash_importance ( 1 )

if ( start_from_best == true ) then
  restore_abs_best ()
end

--    Tidy up the protein

do_unfreeze_all ()
band_count  =  get_band_count ()
for i = band_count , 1 , -1 do
  band_disable ( i )
end

quicksave ( 1 )
best_score = get_score ()
score_in_qs10 = 0

print (  "best score  ", best_score )

if ( level == 1 ) then
  leu_ile_only = true
 else
  leu_ile_only = false
end

if ( level == 1 or level == 2 ) then
   lowest_allowable_shake_gain = 0.5
 else
   lowest_allowable_shake_gain = -0.5
end

if ( level == 1 or level == 2  or level == 4 ) then
  max_attempts = 3
 else
  max_attempts = 6
end

min_snap_loss = 60

if ( level == 1 or level == 2 ) then
   max_shake_loss = 3000
 else
   max_shake_loss = 100000
end

Go ( n_residues )"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_20652" : "{
 "desc" : "Now using  quad fuze after rebuild."
 "hidden" : "1"
 "mid" : "15078"
 "mrid" : "18401"
 "name" : "Rebuild Worst Area v2"
 "parent" : "13792"
 "parent_mrid" : "16493"
 "player_id" : "174969"
 "script" : "--[[\
	Rebuild Worst Areas v2\
	find and rebuild wost scoring segment chain\
	options at end\
]]--\

p=print\
segCnt=get_segment_count()\
areas={} --define global table\

function Score()\
	return get_score(true)\
end \
function round(x)--cut all afer 3-rd place\
	return x-x%0.001\
end\
function getPartScore(segments)--using partial scoring\
	local attr = {'packing','backbone','hiding','other','bonding','sidechain','disulfides'}--,'reference','clashing'\
	local score = 0\
	for i=1,#attr do\
	\	score =  score + get_segment_score_part(attr[i], segments)\
	end\
	return score\
end\
function getAreaScore(ss,se)\
	local s=0\
	for i=ss,se do\
	\	s=s+getPartScore(i)\
	end\
	return s\
end\
function abs(x)\
	if x<0 then x=-x end\
	return x\
end\
function Wiggle(how, iters, minppi) --score conditioned recursive wiggle/shake\
	if how==nil then how="wa" end\
	if iters==nil then \	iters=6 end\
	if minppi==nil then minppi=0.04 end\
	\
	if iters>0 then\
	\	iters=iters-1\
	\	local sp=Score()\
	\	if how == "s" then do_shake(1)\
	\	\	elseif how == "wb" then do_global_wiggle_backbone(1)\
	\	\	elseif how == "ws" then do_global_wiggle_sidechains(1)\
	\	\	elseif how == "wa" then do_global_wiggle_all(1) \
	\	end\
	\	local ig=Score()-sp\
	\	if ig > minppi then Wiggle(how, iters, minppi) end\
	end\
end\
function AllLoop() --turning entire structure to loops\
	local ok=false\
	for i=1, segCnt do\
	\	local s=get_ss(i)\
	\	if s~="L" then \
	\	\	save_structure()\
	\	\	ok=true\
	\	\	break\
	\	end\
	end\
	if ok then\
	\	select_all()\
	\	replace_ss("L")\
	end\
end\
bestScore=Score()\
function SaveBest()\
	local g=Score()-bestScore\
	if g>0 then\
	\	p("Gained another ",round(g)," pts.")\
	\	bestScore=Score()\
	\	quicksave(3)\
	end\
end\
function Sort(tab,items) --BACWARD bubble sorting - lowest on top, only needed items\
	for x=1,items do --items do\
	\	for y=x+1,#tab do\
	\	\	if tab[x][1]>tab[y][1] then\
	\	\	\	tab[x],tab[y]=tab[y],tab[x]\
	\	\	end\
	\	end\
	end\
	return tab\
end\

function FuseEnd()\
    set_behavior_clash_importance(1)\
    Wiggle()\
    Wiggle("s",1)\
    Wiggle()\
    SaveBest()\
end\
function Fuze1(ci1,ci2)\
	set_behavior_clash_importance(ci1)\
	Wiggle("s",1)\
	set_behavior_clash_importance(ci2)\
	Wiggle("wa",1)\
	FuseEnd()\
end\
function Fuze2(ci1,ci2)\
	set_behavior_clash_importance(ci1)\
	Wiggle("wa",1)\
	set_behavior_clash_importance(1)\
	Wiggle()\
	set_behavior_clash_importance(ci2)\
	Wiggle("wa",1)\
	FuseEnd()\
end\
function PinkFuse()\
	select_all()\
	quicksave(4) -- store state before fuse\
	print("Fuze 1")\
	Fuze1(0.1,0.7)\

	quickload(4) -- load state before fuse\
	print("Fuze 2")\
	Fuze1(0.3,0.6)\
	\
	quickload(4) -- load state before fuse\
	print("Fuze 3")\
	Fuze2(0.5,0.7)\
	\
	quickload(4) -- load state before fuse\
	print("Fuze 4")\
	Fuze2(0.7,0.5)\
end\

partial=0\
function savePartial(ss,se)\
	local part2=getPartScore(ss,se)\
	if part2>partial then\
	\	quicksave(7)--save best partial score\
	\	partial=part2\
	end\
	return partial\
end\
function localRebuild(maxiters)\
	if maxiters==nil then maxiters=3 end\
	local s=Score()\
	local i=0\
	repeat\
	\	i=i+1\
	\	if i>maxiters then break end\
	\	do_local_rebuild(i)\
	until Score()~=s \
	if Score()~=s then return false else return true end\
end\
function wsw(minppi, nows)\
	set_behavior_clash_importance(1)\
	if nows==nil then nows=false end--no wiggle sidechain, start whith shake\
	repeat\
	\	local s1=Score()\
	\	if nows==false then do_global_wiggle_sidechains(1) end\
	\	do_shake(1)\
	\	local s3=Score()\
	\	do_global_wiggle_sidechains(1)\
	\	local s4=Score()\
	\	local g=s4-s1\
	\	nows=true\
	\	if s4-s3<minppi/10 then break end --no point to shake again\
	until g<minppi\
end\
function Rebuild(ss,se,tries)\
	if ss>se then ss,se=se,ss end --switch if needed\
	p("Rebuilding area ",ss,"-",se," ",tries," times. Wait...")\
	local sSc=Score()\
	local done=false\
	deselect_all()\
	select_index_range(ss,se)\
	repeat\
	\	done = localRebuild() --searching until score changes\
	until done~=true\
	reset_recent_best() -- first global "best"\
	partial=getPartScore(ss,se)\
	quicksave(7) --save first best partial score\
	for try=1,tries do -- perform loop for number of tries\
	\	deselect_all()\
	\	select_index_range(ss,se)\
	\	localRebuild()\
	\	if doShake then\
	\	\	wsw(1,true)\
	\	end\
	\	savePartial(ss,se)\
	end\
	restore_recent_best()--restore best total score\
end\
function FindWorst()\
	p("Searching worst scoring parts...")\
	areas={}\
	for i=sStart,sEnd-len+1 do\
	\	local s=getAreaScore(i,i+len-1)\
	\	areas[#areas+1]={s,i}\
	end\
	areas=Sort(areas,reBuild)\
end\
startScore=Score()\
function RebuildWorst()\
	p("Starting Rebuild Worst Parts, score: ",round(Score()))\
	if sEnd==nil then sEnd=segCnt end\
	AllLoop()\
	FindWorst()\
	quicksave(3)\
	for i=1,reBuild do\
	\	\	local ss=areas[i][2]\
	\	\	local se=ss+len-1\
	\	\	local s1=Score()\
	\	\	Rebuild(ss,se,tries)\
	\	\	p("Fuzing best total score...")\
	\	\	local ts=Score() --remember best start score\
	\	\	PinkFuse()\
	\	\	quickload(7) --load best pratial score\
	\	\	if Score()==ts then\
	\	\	\	p("Same global score, not fuzing parial.")\
	\	\	else\
	\	\	\	p("Fuzing best partial score...")\
	\	\	\	PinkFuse()\
	\	\	end\
	\	\	quickload(3)\
	\	\	local cs=Score()\
	\	\	p("Rebuld gain: ",round(cs-s1)," ;Total gain: ",round(cs-startScore)," ;Current score: ",round(cs))\
	end\
	\
	load_structure()\
end\

len=nil --len of rebuilded area\
tries=35 --tries by rebuild\
reBuild=5 --how many worsts areas to rebuild\
doShake=false --true --shake rebuilded area every rebuild, false will speed things up\
sStart=1 --start segment of rebuilded area\
sEnd=segCnt --end segment\

--while true do  --uncomment this and last line to run it forever\
for i=2,5 do --run it for worst 2,3,4 and 5 segs in row. change if you want.\
	len=i\
	RebuildWorst()\
end\
--end"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_22245" : "{
 "desc" : "Added sphered shake to speed it up. More output, showing progress and gain. Best solution always in slot 3. Can skip or use only setted aas. Options at end."
 "hidden" : "1"
 "mid" : "25504"
 "mrid" : "33519"
 "name" : "Acid Tweeker v1.2"
 "parent" : "14914"
 "parent_mrid" : "17646"
 "player_id" : "200415"
 "script" : "--Acid Tweaker  v1.0 by Steven Pletsch\
--modded by rav3n_pl ;]\

g_segments = get_segment_count()   -- total number of segments in puzzle\
g_total_score = 0   --  recent best to compare to and see if score was improved\
g_score = {}    -- array of segment scores for comparisons (total for segment)\

P=print --a short\

segCount=get_segment_count()\

function Score()\
	return get_score(true)\
end \

function Gibaj(jak, iters, minppi)\
	if jak==nil then jak="wa" end\
	if iters==nil then \	iters=6 end\
	if minppi==nil then minppi=0.1 end\	\
	if iters>0 then\
	\	iters=iters-1\
	\	sp=Score()\
	\	if jak == "s" then do_shake(1)\
	\	\	elseif jak == "wb" then do_global_wiggle_backbone(1)\
	\	\	elseif jak == "ws" then do_global_wiggle_sidechains(1)\
	\	\	elseif jak == "wa" then do_global_wiggle_all(1) \
	\	end\
	\	ep = Score()\
	\	ig=ep-sp\
	\	if jak~="s" then\
	\	\	if ig > minppi then Gibaj(jak, iters, minppi) end\
	\	end\
	end\
end\

function SelectSphere(sg, radius,nodeselect)\
	if nodeselect~=true then deselect_all() end\
	for i=1, segCount do\
	\	if get_segment_distance(sg,i)<radius then select_index(i) end\
	end\
end\

function Round(x)--cut all afer 3-rd place\
	return x-x%0.001\
end\

function Gain(sc)\
	local g=Score()-sc\
	if g>0 then \
	\	P("Gained: ",Round(g)) \
	\	quicksave(3)--always best solution\
	end\
end\
function usableAA(sn)\
	local usable=false\
	if #useOnly > 0 then\
	\	for i=1,#useOnly do\
	\	\	local ss=useOnly[i][1]\
	\	\	local se=useOnly[i][2]\
	\	\	for s=ss,se do\
	\	\	\	if s==sn then \
	\	\	\	\	usable=true\
	\	\	\	\	break \
	\	\	\	end\
	\	\	end\
	\	end\
	else\
	\	usable=true\
	\	if #doNotUse>0 then\
	\	\	for i=1,#doNotUse do\
	\	\	\	local ss=doNotUse[i][1]\
	\	\	\	local se=doNotUse[i][2]\
	\	\	\	for s=ss,se do\
	\	\	\	\	if s==sn then \
	\	\	\	\	\	usable=false\
	\	\	\	\	\	break \
	\	\	\	\	end\
	\	\	\	end\
	\	\	\	if usable==false then break end\
	\	\	end\
	\	end\
	\	\
	\	if #skipAA>0 then\
	\	\	local aa=get_aa(sn)\
	\	\	for i=1,#skipAA do\
	\	\	\	if aa==skipAA[i] then \
	\	\	\	\	usable=false \
	\	\	\	\	break \
	\	\	\	end\
	\	\	end\
	\	end\
	end\
	return usable\
end\

function wiggle_out()\
	set_behavior_clash_importance(.6)\
	do_global_wiggle_all(1)\
	set_behavior_clash_importance(1.)\
	Gibaj()\
	Gibaj("s")\
	set_behavior_clash_importance(.6)\
	Gibaj()\
	set_behavior_clash_importance(1.)\
	select_all()\
	Gibaj()\
	restore_recent_best()\
end\

function sidechain_tweak()\
	P("Pass 1 of 3: Sidechain tweak")\
	for i=421, g_segments do\
	\	if usableAA(i) then\
	\	\	deselect_all()  \
	\	\	select_index(i)\
	\	\	local ss=Score()\
	\	\	g_total_score = Score()\
	\	\	set_behavior_clash_importance(0)\
	\	\	do_shake(2)\
	\	\	set_behavior_clash_importance(1.)\
	\	\	if(Score() > g_total_score -1.) then\
	\	\	\	restore_recent_best()  \
	\	\	else \
	\	\	\	P("Try sgmnt ", i)\
	\	\	\	if(Score() > g_total_score - 30) then\
	\	\	\	\	SelectSphere(i, 10)\
	\	\	\	\	wiggle_out()  \
	\	\	\	else\
	\	\	\	\	SelectSphere(i, 10)\
	\	\	\	\	deselect_index(i)\
	\	\	\	\	set_behavior_clash_importance(.75)\
	\	\	\	\	do_shake(2)\
	\	\	\	\	select_index(i)\
	\	\	\	\	wiggle_out()\
	\	\	\	end\
	\	\	\	Gain(ss)\
	\	\	end\
	\	end\
	end\
end\

function sidechain_tweak_around()\
	P("Pass 2 of 3: Sidechain tweak around")\
	for i=421, g_segments do\
	\	if usableAA(i) then\
	\	\	deselect_all()\
	\	\	for n=1, g_segments do\
	\	\	\	g_score[n] = get_segment_score(n)\
	\	\	end\
	\	\	select_index(i)\
	\	\	local ss=Score()\
	\	\	g_total_score = Score()\
	\	\	set_behavior_clash_importance(0)\
	\	\	do_shake(2)\
	\	\	set_behavior_clash_importance(1. )\
	\	\	if(Score() > g_total_score -1.) then\
	\	\	\	restore_recent_best()  \
	\	\	else \
	\	\	\	P("Try sgmnt ", i)\
	\	\	\	if(Score() > g_total_score - 30) then\
	\	\	\	\	SelectSphere(i,10)\
	\	\	\	\	wiggle_out()  \
	\	\	\	else\
	\	\	\	\	deselect_all()\
	\	\	\	\	for n=1, g_segments do\
	\	\	\	\	\	if(get_segment_score(n) < g_score[n] - 1) then\
	\	\	\	\	\	\	select_index(n)\
	\	\	\	\	\	end\
	\	\	\	\	end\
	\	\	\	\	deselect_index(i)\
	\	\	\	\	set_behavior_clash_importance(0.1)\
	\	\	\	\	do_shake(2)\
	\	\	\	\	SelectSphere(i,10,true)\
	\	\	\	\	wiggle_out()\
	\	\	\	end\
	\	\	\	Gain(ss)\
	\	\	end\
	\	end\
	end\
end\

function sidechain_manipulate()\
	P("Last pass: Brute force sidechain manipulator")\
	for i=421, g_segments do\
	\	if usableAA(i) then\
	\	\	deselect_all()\
	\	\	rotamers = get_sidechain_snap_count(i)\
	\	\	quicksave(4)\
	\	\	if(rotamers > 1) then\
	\	\	\	local ss=Score()\
	\	\	\	P("Sgmnt: ", i," positions: ",rotamers)\
	\	\	\	for x=1, rotamers do\
	\	\	\	quickload(4)\
	\	\	\	g_total_score = Score()\
	\	\	\	do_sidechain_snap(i, x)\
	\	\	\	set_behavior_clash_importance(1.)\
	\	\	\	\	if(Score() > g_total_score -1.) then\
	\	\	\	\	\	restore_recent_best()  \
	\	\	\	\	else \
	\	\	\	\	\	if(Score() > g_total_score - 30) then\
	\	\	\	\	\	\	SelectSphere(i,10)\
	\	\	\	\	\	\	wiggle_out()  \
	\	\	\	\	\	else\
	\	\	\	\	\	\	SelectSphere(i,10)\
	\	\	\	\	\	\	deselect_index(i)\
	\	\	\	\	\	\	set_behavior_clash_importance(.75)\
	\	\	\	\	\	\	do_shake(2)\
	\	\	\	\	\	\	select_index(i)\
	\	\	\	\	\	\	wiggle_out()\
	\	\	\	\	\	end\
	\	\	\	\	end  \
	\	\	\	end\
	\	\	\	Gain(ss)\
	\	\	end\
	\	end\
	end\
end\

g_segments=g_segments-1 -- uncomment for lingard puzzles only!\
useOnly={ --ranges what have to be used OVERRIDES BOTH LOWER OPTIONS\
--{12,24},\
--{66,66},\
}\
doNotUse={ --ranges that should be skipped \
--{55,58},\
--{12,33},\
}\
skipAA={ --aa codes to skip\
{'a'},\
{'g'},\
}\

reset_recent_best()\
quicksave(3)--in save 3 always best solution. Load in case of crash.\
s1=Score()\
sidechain_tweak()\
s2=Score()\
P("Tweak gain: ",Round(s2-s1))\
sidechain_tweak_around()\
s3=Score()\
P("Around gain: ",Round(s3-s2))\
sidechain_manipulate()\
s4=Score()\
P("Start score: ",Round(s1))\
P("Tweak gain: ",Round(s2-s1))\
P("Around gain: ",Round(s3-s2))\
P("Manipulate gain: ",Round(s4-s3))\
P("Totoal Acid gain: ",Round(s4-s1))\
P("End score: ",Round(s4))\
"
 "type" : "script"
 "uses" : "2"
 "ver" : "0.3"
}
"
 "_recipe_23468" : "{
 "desc" : "New! Improved! Washes whiter! See  first comment for details."
 "hidden" : "1"
 "mid" : "6985"
 "mrid" : "6588"
 "name" : "Loop rebuild  2.0"
 "parent" : "6760"
 "parent_mrid" : "6327"
 "player_id" : "3010"
 "script" : "max_rebuild_length =  5                      -- Maximum rebuild length.          
min_rebuild_length =  4                      --  Suggest leaving this at 4.  Haven't had much luck  with smaller rebuilds but 
                                                                    -- others have. Your mileage may vary.
number_of_rebuilds =  10                   -- It'll look for the  best score from this number of rebuilds. Change to taste.
                                                                    --  Irrelevant for rebuild lengths  of 2  where this value is coerced to 1
stop_if_close = false                             -- Set to true to make it interactive and  manually explore  rebuilds that get close 
                                                                    -- to the highest score
start_idx =  6                                           -- start residue.  Anything between 1 and the number of residues will do
                                                                    -- Change for a bit of randomness.
loops_only =  false                                 -- if false, rebuild helices and sheets also  
                                                                    --  they'll be temporarily converted to loops
loop_forever = true                               --  just keep going. Good for overnight running.  
start_from_best =  false                      -- set to false if you want it to start from the current configuration, not the best
min_residue =  1                                     -- Change these  if you want to  rebuild part of a protein only. For example, to 
                                                                    --  rebuild  53-64, set min_residue to 53 and max_residue to 64. To  restore, set to 
                                                                    -- 1 and 9999  (or any large number) respectively
max_residue =  9999

refinement_hack = false                      -- For refinement puzzles with conditions only.
                                                                    -- if set to true , it'll reset the  puzzle to  the recent credit best  before each  rebuild
                                                                    -- you will always effectively be starting from the best credit solution, so will be                                                                                -- unable to  use this script to explore from lower-scoring solutions. The output                                                                                -- may be misleading  also. As the name implies, its a hack  until a cleaner interface
                                                                      -- comes from the devs.

sidechain_scramble = true                  -- if true, will do  one after a point gain. Trade off: more points from the script but
                                                                    -- more time-consuming also and  possibly fewer subsequent points from walks.
monit =  false                                          -- prints debug and performance info.

--    Other changes

--    Tries an alternative  post-rebuild strategy if the first one is close

--    Stores the  best non-improved structure in Quicksave slot 10. The structure that's saved is the
--    the best before WS etc, so if this script fails to produce (or even if it does) you can load the structure  in
--    slot 10 and try WS in different ways.

original_secondary_structure = {}

function Coprime ( n )

-- returns a number that has no common factors with n
-- an ugly hack

    if ( n <  31 ) then
       return 1
    elseif ( n >= 31*37 ) then
       return 1
    elseif ( n%31 ~= 0 ) then
       return 31
     else
        return 37
     end

end
        
function IsSegmentALoop ( first , last )

   non_loop_found = false
   for i = first , last do
       if ( get_ss ( i ) ~= "L" ) then
          non_loop_found= true
        end
     end

   return  not non_loop_found
end

function ConvertToLoop ( first , last )

    for  k = first , last do
        if ( original_secondary_structure [ k ] ~= "L" ) then
            deselect_all ( )
            select_index ( k )
            replace_ss ( "L" )
        end
    end
end

function RestoreStructure ( first , last )

    for k = first, last do
        deselect_all ()
        select_index ( k )
        replace_ss  ( original_secondary_structure [ k ] )
    end
end

function  nudge ()

    if ( monit ) then
        c = get_score ()
    end

    select_all ()
    set_behavior_clash_importance ( 0.3 )
    do_global_wiggle_all ( 1 )
    set_behavior_clash_importance ( 1 )
    do_global_wiggle_all ( 10 )

    if ( monit ) then
        print ( "Gain from nudge " , get_score() - c )
    end

end

function   BlueFuse_part_1 ( )

    if ( monit ) then
        c = get_score ()
    end

    reset_recent_best ()
    select_all  ()
    set_behavior_clash_importance ( 0.05 )
    do_shake ( 1 )
    set_behavior_clash_importance ( 1 )
    do_global_wiggle_all ( 8 )

    restore_recent_best ()        -- In case the above machinations made things worse

    if  ( monit ) then
       d = get_score ()
       print ( "Gain from BF1 " , d  - c )
    end

end

function  disable_all_bands ()

    band_count = get_band_count ()

    for i = band_count , 1 , -1 do
        band_disable ( i )
    end

end

function enable_all_bands ()

    band_count = get_band_count ()

    for i = band_count , 1 , -1 do
        band_enable ( i)
    end

end

function  BlueFuse_part_2 ()

        c = get_score ()
        reset_recent_best()

        select_all ()
        set_behavior_clash_importance ( 0.05 )
        do_shake ( 1 )
        set_behavior_clash_importance ( 1 )
        do_global_wiggle_all ( 8 )
        restore_recent_best ()

        set_behavior_clash_importance ( 0.07 )
        do_shake ( 1 )
        set_behavior_clash_importance ( 1 )
        do_global_wiggle_all ( 8 )
        restore_recent_best ()
        set_behavior_clash_importance ( 0.3 )
        do_global_wiggle_all ( 1 )
        set_behavior_clash_importance ( 1 )
        do_global_wiggle_all ( 8 )
        restore_recent_best ()

        if ( monit ) then
            d = get_score ()
            print ( "Gain from BF2 " , d - c )
        end

end

function  WiggleShakeWiggle ( start_idx , end_idx )

     -- returns the score after doing a WSW:  shortcircuiting if things don't look promising

    score_a = get_score ()

    do_global_wiggle_all ( 15 )
    score_after_wiggle = get_score ()

    if ( score_after_wiggle - score_a  < 10 and best_score - score_after_wiggle > 30 ) then
        --    The wiggle got stuck and didn't achieve anything
        nudge ()
        score_after_wiggle = get_score ()
    end
    
    if ( monit ) then
        --print (  "After first wiggle (bb) : ",  best_score - score_after_wiggle )
    end

    if ( best_score - score_after_wiggle  > 100 ) then
        -- Not worth continuing
       return  score_after_wiggle
    end

    do_shake ( 1 )
    
    score_after_second_shake = get_score ()

    if ( score_after_second_shake - score_after_wiggle > 0.5 ) then
        do_global_wiggle_all ( 10 )
        score_after_second_wiggle = get_score ()

        if (  score_after_second_wiggle - score_after_second_shake  < 1  and best_score  - score_after_second_wiggle < 50 ) then

            -- The second shake did something but the subsequent wiggle didn't

            reset_recent_best ()
            nudge ( )
            restore_recent_best ()

            score = get_score  ()

            return  score
        else
            return  score_after_second_wiggle
        end
    else
        return score_after_second_shake
    end

end

function  post_rebuild (  score_after_rebuild , threshold_a ,  threshold_b , start_idx , end_idx )

    --  Tries  to recover after a rebuild.

    --  If  the first recovery attempt results in a score that is less than the best score by a value
    --  of threshold_a or less, then try  alternative strategies

    if ( best_score - score_after_rebuild > 3000 ) then
       do_shake (  2 )
        initial_shake = true
    elseif  ( best_score - score_after_rebuild > 1500 ) then
        do_shake ( 1 )
        initial_shake = true
    else
        initial_shake = false
    end

    --    First try  WSW

    curr_score = WiggleShakeWiggle ( start_idx , end_idx )

    if ( monit ) then
        print ( "after  wsw bb ",  best_score - curr_score )
    end

    best_recovery_score = curr_score
    quicksave ( 3 )

    if (  best_score - curr_score <  threshold_a ) then

        best_recovery_score = curr_score
        quicksave ( 3 )

        --   Now try shaking at start if we didn't already do so

        quickload ( 2 )

         if ( initial_shake == false ) then

            score_before_shake = get_score ()
            do_shake ( 1 )
            score_after_shake = get_score ()

            if ( score_after_shake - score_before_shake > 0.1  ) then

                -- If shaking did nothing then  no point duplicating previous WSW
   
                curr_score = WiggleShakeWiggle ( start_idx  , end_idx )
    
                if ( monit ) then
                    print ( "after swsw bb " , best_score - curr_score )
                end

                if ( curr_score > best_recovery_score ) then
                    if ( monit ) then
                        print ( "Second better" )
                    end

                    best_recovery_score = curr_score
                    quicksave  ( 3 )
                 else
                     if ( monit ) then
                        print ( "First better" )
                    end
                end

            end

        end

         -- Additional  post-rebuild strategies will go here as the API matures

    end

    if ( best_score - best_recovery_score < threshold_b ) then
        quickload ( 3 )
        return true
      else
        return false
    end

end

function rebuild ( n , rebuild_length  )

    n_possible_segs = n - rebuild_length + 1

    inc = Coprime ( n_possible_segs  )

    --    The point of  this Coprime, start_idx business is so we go through the protein in  a
    --    nonuniform way. Rather than rebuilding 1-4, 2-5 , 3-6 for example, we might do 21 4, 53-57, 3-6  
    --    or something like  that

    for  i = 1 , n_possible_segs do
         
        improvement_made = false

        end_idx = start_idx + rebuild_length - 1

        if (  start_idx >= min_residue and  end_idx <= max_residue and
                    ( loops_only == false or IsSegmentALoop ( start_idx , end_idx  ) == true ) ) then
    
            rb =  rb + 1
               
            print (  "rb ", rb , " " , start_idx  ,"-" ,  end_idx ,  " ("  ,i , "/" , n_possible_segs , ")"  )

            if ( refinement_hack == true ) then
                restore_credit_best ()
             else
                quickload (  1 )
            end

            best_score = get_score ()

            if ( loops_only == false ) then
                ConvertToLoop ( start_idx ,  end_idx )
            end

            deselect_all ()
            select_index_range (  start_idx  ,  end_idx  )

            -- for some reason, do_local_rebuild ( 1)  often leaves  the protein unchanged

            k  = 0 
            repeat 
                k = k + 1
                do_local_rebuild ( k )
                score_after_rebuild = get_score ()
             until  score_after_rebuild ~= best_score or k  > 2  

            if ( score_after_rebuild ~= best_score ) then
               
                -- If  the scores are  still equal  we probably have a locked segment

                reset_recent_best ()
                if (  number_of_rebuilds > 1 ) then                   
                    do_local_rebuild ( number_of_rebuilds  - 1 )
                    restore_recent_best ()
                end

                score_after_rebuild = get_score ()

                select_all ()

                -- Compute a value delta which will be used later to determine if we are
                -- "sufficiently" close to  our original  best score.  If it turns out later that
                -- we are, then either stop  if stop _if_close is true or  nudge it around

                if ( best_score - score_after_rebuild  < 20 ) then
                    delta = 0.01
                 elseif ( rebuild_length >= 6 ) then
                     delta = 10
                 elseif ( rebuild_length == 5 ) then
                    delta =  7
                 elseif ( rebuild_length == 4 ) then
                     delta = 5
                  else
                     delta = 2
                end

                investigate_alternates_threshold = 2*delta

                if ( investigate_alternates_threshold < 10 ) then
                    investigate_alternates_threshold = 10
                end

                quicksave ( 2 )

                if ( post_rebuild ( score_after_rebuild  ,  investigate_alternates_threshold , delta , start_idx , end_idx  ) == true ) then
                     
                    if ( loops_only == false ) then
                      load_structure ()
                    end

                    if ( stop_if_close == true ) then
                        return true
                    end

                    BlueFuse_part_1 ()
                    curr_score = get_score ()

                    if ( curr_score > best_score ) then

                        if ( sidechain_scramble == true ) then
                            BlueFuse_part_2 ( )
                         end

                        curr_score =  get_score ()
 
                        best_score = curr_score

                        improvement_made = true

                        quicksave ( 1 )
                        print ( "Improvement to ",  best_score )
                    end
                
                end

                curr_score = get_score ()

                if (  curr_score > qs10_best_score  and improvement_made == false ) then
                    qs10_best_score = curr_score
                    quickload ( 2 )

                     -- Bracket the area with frozen segments for easy recognition
                    deselect_all ()
                 
                    if ( start_idx > 1 ) then
                        select_index  ( start_idx - 1 )
                    end
                
                    if ( end_idx <  n ) then
                        select_index ( end_idx + 1 )
                    end

                    do_freeze ( true , false )

                    quicksave ( 10 )
                 end

            end    -- if first rebuild worked

            if ( loops_only == false ) then
                -- RestoreStructure ( start_idx , end_idx )
                load_structure ()
            end

        end

      start_idx = start_idx + inc
      if ( start_idx >  n_possible_segs ) then
          start_idx =  start_idx - n_possible_segs
      end
        
    end        --    for i
    return false
end

if ( start_from_best == true ) then
  restore_abs_best ()
end

-- Tidy up if necessary

disable_all_bands ()

n_residues = get_segment_count()

if ( loops_only  == false ) then
    for i = 1, n_residues do
        original_secondary_structure [ i ] = get_ss ( i )
    end
end

save_structure () 

rb = 0
quicksave ( 1 )

set_behavior_clash_importance ( 1 )

best_score = get_score ()
print (  "Start score : " , best_score )

if ( start_score  == 0 ) then
    print ( "Suggest quitting as starting score < = 0" )
end

if ( loops_only == true ) then
    print (  "Loops only" )
  else
    print (  "Loops, sheets, and helices" )
end

if ( max_residue > n_residues ) then
    max_residue = n_residues
end

if ( min_residue < 1 ) then
    min_residue = 1
end

if ( max_residue <= min_residue ) then
    print ( "Rebuild  range error" )
    loop_forever = false
end

if ( true ) then -- min_residue  > 1 or  max_residue < n_residues ) then
    print  ( "Rebuild  range " , min_residue , " to " , max_residue )
   else
    print ( "Rebuild all" )
end

qs10_best_score = 0

if ( refinement_hack == true ) then
    print ( "Refinement hack on" )
end

repeat
    for rebuild_length = max_rebuild_length , min_rebuild_length , -1  do 

      if ( rebuild_length <= 2 ) then
         number_of_rebuilds = 1
      end

      if ( rebuild ( n_residues  , rebuild_length ) ==  true ) then
        loop_forever = false
        break
      end
    end 
until  loop_forever == false

if ( refinement_hack == true ) then
    restore_credit_best ()
  else
    quickload ( 1 )
end

enable_all_bands ()



"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_23478" : "{
 "desc" : "Now with two layers of testing.
See script for details."
 "hidden" : "1"
 "mid" : "9345"
 "mrid" : "9836"
 "name" : "SmartRebuild V3.41"
 "parent" : "9344"
 "parent_mrid" : "9835"
 "player_id" : "119022"
 "script" : "-- lua script Smart Rebuild 3.x for FoldIt by Crashguard303
-- Performs a rebuild of a user specified selection (use new interface to make your selection!).

function SmartRebuild()
 -- internal values: triesL1,tiesL2,iter,crunch

 --clean up values:
 if triesL1<1 then triesL1=1 end -- assure that we minimum make one try
 if triesL2<1 then triesL2=1 end -- assure that we minimum make one try
 
 if iter<1 then iter=1 end -- and one iteration

 if crunch==nil then crunch=true end
 if crunch==true then
 
 print("Creating reference state...")
 do_local_rebuild(iter)
 end -- if
 
 reset_recent_best() -- set current puzzle state as recent best
 local ScoreAtStart=get_score(true)
 print("  Score now: ",ScoreAtStart)
 quicksave(1) -- L1 saving

 print("Running multiple rebuild...")

 local tryL1
 for tryL1=1,triesL1 do
  if tryL1>1 then quickload(1) end
  print ("L1 Pass ",tryL1,"/",triesL1)
  local tryL2
  for tryL2=1,triesL2 do -- perform loop for number of tries
      print (" L2 Pass ",tryL2,"/",triesL2)
    
      do_local_rebuild(iter)

	  print("Score now: ",get_score(true))
  end --  tryL2 loop
 end -- tryL1 loop
 restore_recent_best() -- fetch best rebuild result
 local ScoreAtEnd=get_score(true)
 print("Score at start: ",ScoreAtStart)
 print("Score at end: ",ScoreAtEnd)
 print("Difference: ",ScoreAtEnd-ScoreAtStart)
end -- function

-- user parameters:
triesL1=3                   -- Number of passes L1, integer value >=1
                                    -- Sets how often the puzzle is set back to initial/reference state
triesL2=6                  -- Number of passes L2, integer value >=1
iter=3                       -- Number of iterations per rebuild, integer value
crunch=true            -- boolean value
                                -- If true, before checking multiple rebuilds, a single rebuild solution is created and saved,
                                    -- so that there is a score reference (recommended)

                                     -- Note!
                                     -- If this is not your first run without changes in the puzzle,  you can set this to false.

SmartRebuild() -- run script"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_24810" : "{
 "desc" : "Aotearoa's Romance translated tuo Lua, plus some extras, now using new score feature.
See script link for details."
 "hidden" : "0"
 "mid" : "4791"
 "mrid" : "3695"
 "name" : "Aot-Rom-Lua V2.0"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "119022"
 "script" : "-- Aotearoa's Romance by Aotearoa aka Renton
-- Lua translation, x-functions and other extras by Crashguard303

function xshake(iter,threshold,NumSegs,BestScore)
  curr_iter=0
  exit_condition=false
  repeat
   curr_iter=curr_iter+1
   print(" Iteration# ",curr_iter,"/max ",iter)
   do_shake(1)
   BestScore,delta=ScoreCheck(BestScore)
   if (iter>0) and (curr_iter>=iter) then exit_condition=true end
   if delta<threshold then exit_condition=true end
   until exit_condition==true
   return BestScore
end -- function

function xwiggleall(iterAll,threshold,NumSegs,BestScore)
  curr_iter=0
  exit_condition=false
  repeat
   curr_iter=curr_iter+1
   print(" Iteration# ",curr_iter,"/max ",iterAll)
   do_global_wiggle_all(1)
   BestScore,delta=ScoreCheck(BestScore)
   if (iterAll>0) and (curr_iter>=iterAll) then exit_condition=true end
   if delta<threshold then exit_condition=true end
  until exit_condition==true
  return BestScore
end -- function

function xwigglelocal(iterlocal,threshold,NumSegs,BestScore)
  curr_iter=0
  exit_condition=false
  repeat
   curr_iter=curr_iter+1
   print(" Iteration# ",curr_iter,"/max ",iterlocal)
   do_local_wiggle(1)
   BestScore,delta=ScoreCheck(BestScore)
   if (iterlocal>0) and (curr_iter>=iterlocal) then exit_condition=true end
   if delta<threshold then exit_condition=true end
  until exit_condition==true
  return BestScore
end -- function

function xwigglelocal2(Start,NumSegs,Step,iterlocal,threshold,BestScore,frozenlist)
print("Local Wiggle.")
for k=Start,NumSegs,Step do
 if (k-Start)%Step==0 and frozenlist[k]==false then
  print("Segment: ",k,"/",NumSegs)
  deselect_all()
  select_index(k)
  Bestscore=xwigglelocal(iterlocal,threshold,NumSegs,BestScore)
 end -- if
end -- k
return BestScore
end -- function

function ScoreCheck(BestScore)
 BestScore2=BestScore
 Score=get_score(true) 
 delta=Score-BestScore2
 if delta>=0 then
   -- print ("Old recent score: ",BestScore2)
   print ("New recent score: ",Score)
   BestScore2=Score
   reset_recent_best()
  else
   restore_recent_best()
 end
 return BestScore2,delta
end -- function

function FlushList(list,NumSegs)
 print("Unfreezing.")
 do_unfreeze_all()
 for k=1,NumSegs do
  list[k]=false
 end
 return list
end -- function

function xfreeze(Start,NumSegs,Step,list)
print("Freezing.")
deselect_all()
for k=Start,NumSegs,Step do
 if (k-Start)%Step==0 then
  select_index(k)
  list[k]=true
 end -- if
end -- k
do_freeze(true,true)

reset_recent_best()
return list
end -- function

function Romance(threshold,CI)
set_behavior_clash_importance(CI)
NumSegs=get_segment_count()
frozenlist={}
frozenlist=FlushList(frozenlist,NumSegs)

reset_recent_best()

BestScore=get_score(true)

select_all()
print("Global Shake (1)")
do_shake(1)
BestScore=ScoreCheck(BestScore)

print("Global Wiggle.")
BestScore=xwiggleall(25,threshold,NumSegs,BestScore)

frozenlist=xfreeze(2,NumSegs,3,frozenlist)

BestScore=xwigglelocal2(2,NumSegs,2,17,threshold,BestScore,frozenlist)

frozenlist=FlushList(frozenlist,NumSegs)
save_structure()
select_all()
replace_ss("L")
reset_recent_best()

print("Global Shake (1)")
do_shake(1)
BestScore=ScoreCheck(BestScore)

print("Global Wiggle")
BestScore=xwiggleall(4,threshold,NumSegs,BestScore)

frozenlist=FlushList(frozenlist,NumSegs)

frozenlist=xfreeze(3,NumSegs,4,frozenlist)

reset_recent_best()

BestScore=xwigglelocal2(3,NumSegs,2,15,threshold,BestScore,frozenlist)

frozenlist=xfreeze(4,NumSegs,5,frozenlist)

reset_recent_best()

BestScore=xwigglelocal2(2,NumSegs,3,7,threshold,BestScore,frozenlist)

frozenlist=FlushList(frozenlist,NumSegs)

reset_recent_best()
select_all()
print("Global Shake (1)")
do_shake(1)
BestScore=ScoreCheck(BestScore)

print("Global Wiggle.")
BestScore=xwiggleall(25,threshold,NumSegs,BestScore)

load_structure()
do_unfreeze_all()
end -- function

Romance(0.0001,1)"
 "type" : "script"
 "uses" : "35"
 "ver" : "0.3"
}
"
 "_recipe_25044" : "{
 "desc" : "The Swiss Army-Knife of tools.
Can perform almost every tool in your desired range and chunk- and stepsize, and watches score improvement.
See Top of script for details."
 "hidden" : "0"
 "mid" : "2157"
 "mrid" : "518"
 "name" : "Multi-tool V9.71"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "119022"
 "script" : "-- Multi-tool V9.71 by Crashguard303

-- Starting with Themarquis'  "Wiggle by Ones" script , I added  score-condition for wiggle repeating, score and its delta output,
-- adjustable chunk size, so you can wiggle by ones, twos...whatever.
-- Sets  recent best at points gain , restores best on point loss. It is combinable with bands and your own manual selection.
-- Runs as loop from given start to given end  values within given stepping, and can also run backwards.
-- Automatically gets end segment positions when entering zero and can change clashing importance.
-- Can perform wiggle all, sidechain and backbone as well as mutate.
-- Callable as function at the end of the script.

function swap(x,y)
 return y,x
end

function rescale(x,x1,x2,y1,y2)      -- applies spatial point x within 1D-scale [x1,x2] to the scale [x2,y2]
 divisor=(x2-x1)
 if divisor==0 then divisor=1e-310 end
 temp=(y2-y1)/divisor*(x-x1)+y1
 return temp
end

function integervalue(temp) -- integer function
 if temp==0 then int=0
  else
   if temp>=0 then sign=1
    else sign=-1
   end
   temp2=temp*sign
   rest=temp2-temp2%1
   int=rest*sign
 end
 return int
end 

function get_segment_score_range(SegA,SegB)
-- adds all segment scores within a given range
 temp=0
 for scount=SegA,SegB do
  temp=temp+get_segment_score(scount)
 end
 return temp
end

function do_tool(UTool,iter)
 if UTool=="mutate" then do_mutate(iter)
  -- perform selected operation for (iter) iterations
  elseif UTool=="shake" then do_shake(iter)
  elseif UTool=="rebuild" then do_local_rebuild(iter)
  elseif UTool=="wiggle_backbone" then do_global_wiggle_backbone(iter)
  elseif UTool=="wiggle_sidechains" then do_global_wiggle_sidechains(iter)
  else do_global_wiggle_all(iter)
 end
end

function Multitool(UTool,SegA,SegB,StpS,ChnkS,TItr,RItr,MinChng,CI,Uslct,OC)
--- User definable program variables:
-- UTool           -- Use tool. "wiggle_all", "wiggle_backbone", "wiggle_sidechains",
                             --"mutate" and "rebuild" are possible.
                             -- on other input, wiggle_all is performed
-- SegA            -- Starting segment number
                               -- if zero, 1 is  default
-- SegB            -- Ending segment
                               -- If zero, last segment is chosen
-- StpS             -- Stepsize. 1 to process all segments, 2 for only every seond... etc
                               -- use negative values to go backwards
                               -- if zero, 1 is  default
-- ChnkS          -- Chunksize. Number of segments which are processed at one cycle
                               -- if zero, 1 is  default
-- TItr               -- number of iterations for test
                               -- if zero, 1 is default
-- RItr               -- number of iterations for refinement
                               -- if zero,  1 is default
-- MinChng    -- minimum positive segment score (sum) change condition,  which activtates refinement
                               -- and ends it when result below
                               -- if  below zero, 0.002 is default.
-- CI                  -- Clash Importance. Value range 0-1.
                               -- If value <0 or >1, current setting is taken.
                               -- if you enter another value,  your current setting will be used.
-- Uslct            -- Unselect. Integer value.
                               -- If 1, all segments will be unselected at the beginning
                               -- if zero, not.
-- OC             -- Override Control. Integer value
                               -- Normally, the whole tool only keeps as good or better point results,
                               -- and only refines, if the test made a positive score change.
                               -- But you can change this behaviour here!
                               -- It helps to tolerate point loss and to force refining.
                                -- if 0, no Override
                                -- if >0, refinement is forced with the given number of passes
                                -- if <0, refinement is forced with the given number of passes,
                                -- and you allow the first pass to DROP the score (important for rebuild)

--- Internal program variables:
-- SegTarget   -- Last Segment Number to be processed.
-- OvrR             -- if 0, refinement only if score condition is given
                               -- if>0, refinement will be repeated for for this times.
                               -- set this to >0 when using mutate or rebuild
                               -- default is 0.
-- OvrRDef          -- Override default.
-- CrushF           --  if=1, improvement is enforced.  It stores the test result anyway regardless if it is good or not,
                                -- and needs override. If OvrR is zero, it will be set to OvrRDef
                                -- if>1, OvrR is set to its value.
                                -- default is zero.
                                -- useful for rebuild.

-- CORRECT VARIABLES

if ChnkS<1 then ChnkS=1 end
if UTool=="rebuild" and ChnkS<1 then ChnkS=3 end
ChnkS=ChnkS-1
lastS=get_segment_count()

StpS=integervalue(SegA)
if StpS==0 then StpS=1 end
if StpS<0 then StpS=-StpS end

SegA=integervalue(SegA)
SegB=integervalue(SegB)


if SegA<1 then SegA=1 end
if SegB<1 then SegB=lastS end

if SegA>SegB then SegA,SegB=swap(SegA,SegB) StpS=-StpS end
SegB=SegB-ChnkS
if StpS<0 then SegA,SegB=swap(SegA,SegB) end

if SegB>SegA then SegTarget=SegB
 else SegTarget=SegA
end
SegTarget=SegTarget-1\

if TItr<1 then TItr=1 end
if RItr<1 then RItr=1 end
if MinChng<=0 then MinChng=0.0002 end

if (CI>=0) and (CI<=1) then set_behavior_clash_importance(CI) end

Uslct=integervalue(Uslct)
if Uslct<0 then Uslct=0 end
if Uslct>1 then Uslct=1 end

reset_recent_best() --backup
sets=1              -- our variables  for number of sets
restores=0          -- and restores

if Uslct==1 then deselect_all() end
-- first we deselect what ever is selected, if needed

OvrRDef=10
OC=integervalue(OC)

if UTool=="rebuild" and OC==0 then OC=-OvrRDef end
if OC<0 then CrushF=1 OvrR=OC*-1
 elseif OC>1 then CrushF=0 OvrR=OC
 else CrushF=0 OvrR=0 
end

if OvrR<0 then OvrR=1 end
if CrushF<0 then CrushF=0 end

if (CrushF==1) and (OvrR==0)then OvrR=OvrRDef end
if CrushF>1 then CrushF=1 OvrR=CrushF end

scorebefore=get_score()

for seg=SegA,SegB,StpS do
-- for seg from offset,end with StpS do the following:
-- we pick the segments we want to do stuff to by selecting them.
     prc=rescale(seg,SegA,SegB,0,100) -- calculate status in percent
     prc=integervalue(prc*1000)/1000  -- allow only 3 digits after decimal separator
     SegB2=seg+ChnkS
     --calculate the last segment of the actual position to select whole chunk
     select_index_range(seg,SegB2)
     -- select the whole chunk
     score1=get_segment_score_range(1,lastS)
     pscore1=get_score()
     -- get score information for later reference
     print("Testing segment-chunk: ",seg," to ",SegB2," of ",SegTarget," (",prc,"\%)")
      -- show where we are
      do_tool(UTool,TItr)
      -- perform selected operation for testing
      score2=get_segment_score_range(1,lastS)
      pscore2=get_score()
      print("Tested segment-chunk: ",seg," to ",SegB2," of ",SegTarget," (",prc,"\%)")
      -- display score before wiggle
      print(score1," Segment Score to")
      delta=score2-score1
      -- calculate  segment score difference
      delta2=pscore2-pscore1
      --  calculate puzzle score difference
      print  (score2," Difference: ",delta)
      -- show  score after wiggle and difference

      if delta<MinChng and OvrR==0 then print("Skipping refinement.") end
      if CrushF>0 then reset_recent_best() print ("Crushed!")
        else
          if delta<0 or delta2<0 then restore_recent_best() restores=restores+1 end
          -- if negative segment score change, restore
          if delta>0 then reset_recent_best() sets=sets+1 end
          -- if positive segment score difference, store
      end

      pass=0 
      -- reset refinement pass #

      while  (delta>=MinChng and delta2>=0) or ((OvrR>0) and (pass<OvrR)) do
      -- if there is a significant positive change  (MinChng)
      -- or overridepasses are not reached
      -- repeat this
        pass=pass+1
        -- count pass#
        score1=score2
        -- store segment score before refinement
        pscore1=pscore2
        -- store puzzle score before refinement
        lastdelta=delta         
  -- print (">",OC," >",OvrR," >",CrushF)
        print ("Chunk ",seg," to ",SegB2," of ",SegTarget," (",prc,"\%) pass# ",pass)
        do_tool(UTool,RItr)
        -- perform selected operation for refinement
        select_index_range(seg,SegB2)
        score2=get_segment_score_range(1,lastS)
        pscore2=get_score()
        print ("Chunk ",seg," to ",SegB2," of ",SegTarget," (",prc,"\%) pass# ",pass)
        print (score1," segment score to ")
        print(score2)
        delta=score2-score1
        -- segment/chunk score difference
        delta2=pscore2-pscore1
        -- puzzle score difference
        deltarate=delta-lastdelta
        print ("Difference: ",delta)
        print("Difference-rate: ",deltarate)
        if delta<0 or delta2<0 then restore_recent_best() restores=restores+1 end
        if delta>0 then reset_recent_best() sets=sets+1 end
     end
     for temp=seg,SegB2 do
      deselect_index(temp)
      -- undo selection for the next step
     end
end
-- end of loop
scoreafter=get_score()
scorechange=scoreafter-scorebefore
print("Finished with ",sets," sets and ",restores," restores. Changed from")
print(scorebefore," to ")
print(scoreafter,". Difference: ",scorechange)
end
-- END OF FUNCTION. Remember it is
-- Multitool(UTool,SegA,SegB,StpS,ChnkS,TItr,RItr,MinChng,CI,Uslct,OC)

Multitool("wiggle_all",0,0,1,3,1,1,0.01,1,0,0)"
 "type" : "script"
 "uses" : "29"
 "ver" : "0.3"
}
"
 "_recipe_2527" : "{
 "desc" : "Some small changes.
See script link for details."
 "hidden" : "0"
 "mid" : "12106"
 "mrid" : "13757"
 "name" : "Genetic Fuse V1.7"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "119022"
 "script" : "--[[
Genetic Fuse by Crashguard303
]]--

-- Random Number Generator

-- Author: tlaloc (aka Greg Reddick)

-- This is a substitute for the math.random() and math.randomseed()
-- functions in the lua standard library. If they ever become available
-- this code can be removed and the standard functionality should work with
-- by only prefixing all the function names with 'math.'.


------------------------------------------------------------------------
-- random ([m [, n]])

-- When called without arguments, returns a uniform pseudo-random real number in the
-- range [0,1). When called with an integer number m, math.random returns a uniform
-- pseudo-random integer in the range [1, m]. When called with two integer numbers
-- m and n, math.random returns a uniform pseudo-random integer in the range [m, n].
------------------------------------------------------------------------
-- randomseed (x)

-- Sets x as the "seed" for the pseudo-random generator: equal seeds produce
-- equal sequences of numbers.
------------------------------------------------------------------------
-- getseed ()

-- This is a substitute for the os.time() lua function that is commonly
-- used to seed a random number generator.

-- It generates it from the least significant
-- digits of the current score. So if the score
-- doesn't change, then the number sequence will
-- be the same. However, *any* change to the score
-- will cause a different sequence.
-- If the score is 0, it performas a WiggleAll until a non-zero score
-- is generated, then restore the structure.
------------------------------------------------------------------------

-- This implementation uses the Multiply with Carry random number generator
-- Translated into Lua from the VBScript published at
-- http://www.rlmueller.net/Programs/MWC32.txt

------------------------------------------------------------------------
-- The original script has the following notices:
-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007
-- You have a royalty-free right to use, modify, reproduce, and
-- distribute this script file in any way you find useful, provided that
-- you agree that the copyright owner above has no warranty, obligations,
-- or liability for such use.
------------------------------------------------------------------------

function floor(value)
    return value - (value % 1)
end

function getseed()
    local score = abs(get_score(true)+RNDoffset)
    if score == 0 then
        quicksave(9)
        do_global_wiggle_all(1)
        score = abs(get_score(true)+RNDoffset)
        quickload(9)
    end
    local fraction = (score - floor(score)) * 1000
    local least = fraction - floor(fraction)
    local seed = floor(least * 100000)
    return seed
end

-- lngX = 1000
lngC = 48313

function MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = floor((F2 / H) + F1)

    return lngX
end

function randomseed(x)
    lngX = x
end

function random(m,n)
    local m=m
    local n=n
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return floor((MWC() / 4294967296) * (n - m + 1)) + m
    end
end

function abs(x)
 local y=x
 if x<0 then y=-y end
 return y
end -- function

function sgn(x)
 local y=x
 if y>=0 then
   return 1
  else
   return -1
 end -- if y
end -- function

function CutOff(x,y)
 return floor(x*10^y)/10^y
end -- function

function Moebius(Min,Max,x)
 -- Moebius value
 -- preserves negative signum
 -- brings absolute values above Max+Difference to Min+Difference
 -- brings absolute values below Min-Difference to Max-Difference
 local s=sgn(x) -- fetch signum
 local y=x*s -- multiply with signum to get absolute value
 local Min=Min
 local Max=Max
 if y>Max then
   y=Min+(y-Max)
  elseif y<Min then
   y=Max+(y-Min)
 end -- if y
 return y*s -- multpily with signum to get non-absolute value again
end -- function

function FillHerd(StartIndex)
 local StartIndex=StartIndex
 local k
 for k=StartIndex,HerdSize do
  local IndiSlot=IndiPointer[k]
  print("Generating Individuum ",k,"(",IndiSlot,")")
  local l
  IndiType[IndiSlot]="random"
  for l=1,IndiLength do
   IndiCI[IndiSlot][l]=random()*(IndiCIMax-IndiCIMin)+IndiCIMin -- Random CI value

   IndiSiter[IndiSlot][l]=random(0,IndiSiterMax) -- Random iteration value for shakes
    if random_flag(InvertProb)==1 then IndiSiter[IndiSlot][l]=-IndiSiter[IndiSlot][l] end -- maybe invert it

   IndiWiter[IndiSlot][l]=random(0,IndiWiterMax) -- Random iteration value for shakes
   if random_flag(InvertProb)==1 then IndiWiter[IndiSlot][l]=-IndiWiter[IndiSlot][l] end -- maybe invert it

   -- print(" CI:",IndiCI[IndiSlot][l]," S-iters:",IndiSiter[IndiSlot][l]," W-iters:",IndiWiter[IndiSlot][l])
  end -- l loop
 end -- k loop
end -- function

function random_flag(x)
 local x=x
 -- Returns a random value; either  0 or 1, depending on mutation probability x
 local flag=random()
 if flag<x then
   return 1
  else
   return 0
 end -- if
end -- function

function random_direction()
 -- Returns random value; either -1 or +1
 return random_flag(0.5)*2-1
end -- function

function random_direction2(x)
 local x=x
 -- Returns random value; either -1 or +1, but only if mutation allows it, else 0
 if random_flag(x)==0 then
   return 0
  else
  return random_direction()
 end -- if
end -- function

function CrossOverCheck(Pos,Target)
 if MultipleCrossOver then
    if random_flag(0.5)==1 then
      return true
     else
      return false
    end -- if random_flag
   else
    if Pos>Target then
       return true
      else
       return false
    end -- if Pos
 end -- if MultipleCrossOver
end -- function

function CrossOver(Source1,Source2,Target)
 local So1=Source1   -- Parent (source) Indi index 1
 local So2=Source2   -- Parent (source) Indi index 2
 local Ta=Target         -- Destination (target) Indi index
 local So1P=IndiPointer[So1] -- Fetch Indi 1 address
 local So2P=IndiPointer[So2] -- Fetch Indi 2 address
 local TaP=IndiPointer[Ta] -- Fetch Indi destination address

 print("Breeding ",So1,"(",So1P,") and ",So2,"(",So2P,") to ",Ta,"(",TaP,")")

 local CrossOverPoint
 if MultipleCrossOver==false then -- If we use multi crossover, we don't need to
  CrossOverPoint=random(0,IndiLength) -- generate random crossover point
  -- CrossOverPoint=random(CrossOverPoint,IndiLength)
  -- As the random number generator tends to create small values, you can use this to pull value randomly up
  print("Crossover point:",CrossOverPoint)
 end -- if MultipleCrossOver

 local k
 for k=1,IndiLength do -- Go through Chromosome length
  local SoT
  if CrossOverCheck(k,CrossOverPoint) then -- If crossover point is exceeded, take So2 Indi chromosomes
    SoT=So2P
   else -- If crossover point is not exceeded, take So1 Indi chromosomes
    SoT=So1P
  end -- if
  IndiCI[TaP][k]=IndiCI2[SoT][k]
  IndiSiter[TaP][k]=IndiSiter2[SoT][k]
  IndiWiter[TaP][k]=IndiWiter2[SoT][k]

  -- Mutating starts here
  local Change=random_direction2(MutProb)*MutCIDigit^(-random(MutCIMin,MutCIMax)) -- Change random digit of CI, or not if no mutation
  IndiCI[TaP][k]=Moebius(0,1,IndiCI[TaP][k]+Change)
  if IndiCI[TaP][k]<IndiCIMin or IndiCI[TaP][k]>IndiCIMax then IndiCI[TaP][k]=random()*(IndiCIMax-IndiCIMin)+IndiCIMin end
  if random_flag(InvertProb)==1 then IndiCI[TaP][k]=1-IndiCI[TaP][k] end -- if random_flag, invert

  -- print("Mutated CI: ",Temp," by ",CIChange," to ",IndiCI[TaP][k])

  IndiSiter[TaP][k]=MutateIter(IndiSiter[TaP][k],IndiSiterMax) -- Mutate shake iterations, inclusive inverting
  IndiWiter[TaP][k]=MutateIter(IndiWiter[TaP][k],IndiWiterMax) -- Mutate wiggle iterations, inclusive inverting
 end -- k loop
end -- function

function MutateIter(Value,Max)
    local Value=Value
    local Max=Max
    local Change=random_direction2(MutProb) -- change shakes by -1 or 1, or not if no mutation
    Value=Moebius(0,Max,Value+Change)
    if random_flag(InvertProb)==1 then Value=-Value end -- if random_flag, invert
    return Value
end -- function

function Roulette()
 local RouletteTarget=random()*(Fitness+1)
 local RouletteValue=0
 local Wheel=random(1,HerdSize)
 repeat
  Wheel=Wheel+1
  if Wheel>HerdSize then Wheel=1 end
  RouletteValue=RouletteValue+IndiScore2[IndiPointer[Wheel]]
 until RouletteValue>RouletteTarget
 return Wheel
end -- function

function CopyHerd()
  -- Copy all Indis to extra table
 IndiCI2={}
 IndiSiter2={}
 IndiWiter2={}
 IndiScore2={}

 local k
 for k=1,HerdSize do -- Cycle through complete herd
  IndiCI2[k]={}
  IndiSiter2[k]={}
  IndiWiter2[k]={}
  IndiScore2[k]=IndiScore[k]
  local l
  for l=1,IndiLength do -- and Indi contents
   IndiCI2[k][l]=IndiCI[k][l]
   IndiSiter2[k][l]=IndiSiter[k][l]
   IndiWiter2[k][l]=IndiWiter[k][l]
  end -- l
 end -- k
end -- function

function Breed2()
 CopyHerd() -- Create Indi2 tables out of Indi tables
 local FitnessWorst=IndiScore2[IndiPointer[HerdSize]] -- Check worst points
 Fitness=0 -- initialize Fitness
 local k
 for k=1,HerdSize do -- We don't need the pointer here, beacuse we change all score values
  -- if FitnessWorst<0 then -- If worst Fitness<0
   IndiScore2[k]=IndiScore2[k]-FitnessWorst+1 -- Adapt all scores, so that last Fitness is 1. Needed for negative values
  -- end -- if
  Fitness=Fitness+IndiScore2[k] -- Calculate Fitness by summing all new Indi fitnesses
 end -- k

 local Target
 for Target=BreedFirst,BreedLast do

  local Source1
  if Source1isRoulette then -- If Roulette
    Source1=Roulette() -- Select a random parent, prefering fit ones
   else -- If not
    Source1=Target-BreedFirst+1 -- Parent 1 is one of the best
  end -- if Source1isRoulette

  local Source2
  if Source2isRoulette then -- If Roulette
    repeat
     Source2=Roulette()  -- Select a different random parent, prefering fit ones
    until Source2~=Source1 -- but not the same as Source2
   else -- If not
    Source2=Source1+1 -- Parent2 is 1 behind Parent 1
    if Source2>HerdSize then Source2=1 end -- if last one exceeded, start with first again
  end -- if Source1isRoulette

  CrossOver(Source1,Source2,Target)
  IndiType[IndiPointer[Target]]="breeded"
 end -- Target
end -- function

function Breed()
 -- sorting
 local KFinish=HerdSize-1
 local k
 for k=1,KFinish do
  LStart=k+1
  local l
  for l=LStart,HerdSize do
   if IndiScore[IndiPointer[k]]<IndiScore[IndiPointer[l]] then
    IndiPointer[k],IndiPointer[l]=IndiPointer[l],IndiPointer[k]
   end -- if
  end -- l
 end -- k
 print()
 print ("Score:")
 for k=1,HerdSize do
  print(k,"(",IndiPointer[k],"): ",IndiScore[IndiPointer[k]])
 end -- k

 Breed2()

 if FillPoint<=HerdSize then
  FillHerd(FillPoint) -- Replace last Indis by random new ones, if needed
 end -- if
end -- function

function BestScoreCheck(BestScore)
 local BestScore=BestScore
 local TempScore=get_score(true)
 if TempScore>BestScore then BestScore=TempScore end
 return BestScore
end --function

function Genetic_Fuse()
 FillPoint=BreedLast+1
 randomseed(getseed())  -- initialize random seed
 IndiScore={}
 IndiType={}
 IndiCI={}
 IndiSiter={}
 IndiWiter={}

 IndiPointer={}

 local k
 for k=1,HerdSize do  -- for complete herdsize, initialize:
  IndiPointer[k]=k    -- Index slot pointer (required for fast result sorting)
  -- IndiScore[k]=0
  IndiCI[k]={}           -- CI table
  IndiSiter[k]={}       -- Shake iteration table
  IndiWiter[k]={}      -- Wiggle iteration table
 end -- k

 FillHerd(1) -- Generate complete random herd

 select_all() -- Select all segments to make shake/wiggle effect on them

 if UseRecentBest==false then -- do we use recent best?
   quicksave(1) -- This will be the initial state for each generation
  else
   reset_recent_best() -- set initial puzzle stae as recent best
   ExecuteCluster=true -- perform Indi test always
 end -- if UseRecentBest

 print()
 print("Starting Genetic fuse...")

 local Generation=0
 repeat
  Generation=Generation+1

  if UseRecentBest then
   restore_recent_best() -- take best result so far
   -- print("RRB")
   quicksave(1) -- and save it for each try of this generation
   -- print("QS 1")
  end -- if UseRecentBest

  local BestScore
  local k
  for k=1,HerdSize do -- Cycle through all Indis
   ExecuteCluster=true
   if Generation>1 then
    if UseRecentBest==false then -- Do we use recent best? If not,
     if k<BreedFirst then
      ExecuteCluster=false -- we don't need to perform the good solutions again
     end -- if k
    end -- if UseRecentBest
   end -- if Generation
   -- Check if this Indi (try) has to be processed or just shown
   if ExecuteCluster then -- if Indi is not just to be shown, but tested
    quickload(1) -- load this for each Indi of herd
    -- print("QL 1")
    BestScore=get_score(true) -- Reset best score for this try
   end -- if ExecuteCluster
   local IndiSlot=IndiPointer[k] -- Fetch slot (house) number, where the Indi lives
   print("Gen:",Generation," Indi:",k,"(",IndiSlot,")/",HerdSize," type:",IndiType[IndiSlot])
   -- Show Indi number(and address), herdsize and type
   local l
   for l=1,IndiLength do -- Cycle through complete chromosome
    print("  CI:",CutOff(IndiCI[IndiSlot][l],3)," S-iters:",IndiSiter[IndiSlot][l]," W-iters:",IndiWiter[IndiSlot][l])
    if ExecuteCluster then -- If needed
     set_behavior_clash_importance(IndiCI[IndiSlot][l]) -- perform CI change
     if IndiSiter[IndiSlot][l]>0 then
      do_shake(IndiSiter[IndiSlot][l]) -- perform shake
      BestScore=BestScoreCheck(BestScore)
     end -- if
     if IndiWiter[IndiSlot][l]>0 then
      do_global_wiggle_all(IndiWiter[IndiSlot][l]) -- perform wiggle
      BestScore=BestScoreCheck(BestScore)
     end -- if
    end -- if ExecuteCluster
   end -- l loop
   print("  CI:1 S-iters:",IndiSiterMax," W-iters:",IndiWiterMax) -- Finish try with
   if ExecuteCluster then
    set_behavior_clash_importance(1) -- CI=1
    do_shake(IndiSiterMax) -- maximum shake
    do_global_wiggle_all(IndiWiterMax) -- maximum wiggle
    IndiScore[IndiSlot]=BestScoreCheck(BestScore) -- get Indi score
   end -- if ExecuteCluster
   print("    Score:",IndiScore[IndiSlot]) -- and show score
  end -- k
  Breed() -- Roulette, crossover, mutate and fill
 until Generation==Generations
 -- Repeat until target generation number is reached exactly
 -- If target is below 1, it can never be reached exactly
 restore_recent_best() -- fetch best state
end -- function

Generations=50
                                   -- Number of Generations, when this script has to end, integer value>=0
                                     -- Set this to 0 to run infinitely
BreedFirst=3
                                      -- First Individuum index to replaced by breeded one, integer value>=1
                                        -- For example, if 3, first 2 good solutions will be kept.
BreedLast=5
                                      -- Last Individuum index to replaced by breeded one, integer value >=BreedFirst and <=HerdSize
                                        -- if <HerdSize, rest of herd (BreedLast+1 to HerdSize) is filled with random indiviuums per generation
HerdSize=8
                                   -- Number of solutions (Individuums) to try per generation
IndiLength=6
                                      -- Chomosome length.
                                        --Number of CI changes, shakes and wiggles per try, integer value>0
MutProb=.3
                                   -- Mutation probability, float value >=0 and <=1
                                      -- Mutation effects CI, shakes and wiggles
                                      -- If 0, no mutation is performed, only crossover
                                      -- if 1, mutation is always performed
InvertProb=.2
                                   -- Invert probability, folat value >=0 and <=1
                                     -- If 0, inversion is turned off
                                     -- If 1, inversion is always on (not recommended)
MultipleCrossOver=true
                                   -- Multiple crossover point flag, boolean value
                                     -- If false (default), crossover works only at one point
                                     -- If ftrue, each single gene can be from one of both partents
Source1isRoulette=true
                                   -- Roulette flag for parent 1, boolean value
                                     -- if false (default), breeding starts with parent 1 as source and downwards
                                     -- if true, parent is selected by fitness roulette, good solutions appear more often than bad ones
Source2isRoulette=true
                                  -- Roulette flag for parent 2, boolean value
                                     -- if false, breeding starts with parent 1+1 as source and downwards
                                     -- if true (default), parent is selected by fitness roulette, good solutions appear more often than bad ones
IndiCIMin=0
                                      -- Minimum possible CI, float value
IndiCIMax=1
                                      -- Maximum possible CI, float value
MutCIMin=1
                                      -- First possible CI digit to change when mutating, integer value>0
MutCIMax=3
                                      -- Last possible CI digit to change when mutating, integer value>0, >=MutCIMin
MutCIDigit=10
                                      -- Digit base of CI mutating, integer value
                                        -- 2 will change CI by (+or-)2^-(MutCIMin..MutCIMax), quasi binary change
                                        -- 10 will change CI by (+or-)10^-(MutCIMin..MutCIMax), quasi decimal change
IndiSiterMax=2
                                      -- Maximum iterations for shake
IndiWiterMax=12
                                      -- Minimum iterations for shake
UseRecentBest=false
                                    -- If true, load recent best state for each generation
                                      -- not recommended, you can stuck on local maximum
                                      -- Use only if you want to squeeze out what is possible
                                    -- If false, load initial puzzle state for each Indi

RNDoffset=0
                                     -- Random offset, float value >=0 to <1
                                       -- As we can't randomize random seed with a timer, use this to try other values
                                       -- when you have loaded the same puzzle state

Genetic_Fuse()    -- Launch script with parameters"
 "type" : "script"
 "uses" : "10"
 "ver" : "0.3"
}
"
 "_recipe_2583" : "{
 "desc" : "Creates a band between two random segments and shakes out. Keeps trying different segments. Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local minimum and cannot find points anywhere else."
 "hidden" : "1"
 "mid" : "5719"
 "mrid" : "13583"
 "name" : "tlaloc Repeat Random Tug 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts

-- You must keep the following attribution and notice in any republication of
-- this script:

--=======================================
-- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- This script is licensed by the 
-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/
-- Except for parts that are specifically excluded in the comments
-- which came from other sources.
--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

------------------------------------------------------------------------
-- The original random script this was ported from has the following notices:
-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007
-- You have a royalty-free right to use, modify, reproduce, and
-- distribute this script file in any way you find useful, provided that
-- you agree that the copyright owner above has no warranty, obligations,
-- or liability for such use.

-- This function is not covered by the Creative Commons license given
-- at the start of the script, and is instead covered by the comment
-- given here.
------------------------------------------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl library

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDelete(...)
    fsl.Print('Deleting bands')
    foldit._BandDelete(...)
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse
    -- This function is not covered by the Creative Commons license given
    -- at the start of the script since it a port of Vertex's BlueFuse
    -- algorithm, with some enhancements.
    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local countTries = fsl.SelectMultiStart()
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        foldit.Quickload(i)
        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- FindCenterSegment
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    for i=1, foldit.GetSegmentCount() - 5 do
        fsl.BandAddBetweenSegments(i, i+5)
    end
    for i=1, foldit.GetBandCount() do
        foldit.BandSetLength(i, 20.0)
        foldit.BandSetStrength(i, 2.0)
    end
    fsl.WiggleBackbone(5)
    fsl.BandDelete()
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score
    --        which modifies quicksave slots 9 and 10

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time
    -- the puzzle is reset. Since alignment tool applies structure
    -- after that time, this will not recover that structure. 
    -- Furthermore, this works randomly on
    -- puzzles that are multistart, where it always takes the
    -- reset structure, which is random.
    -- If the original structure is all loops, then it refuses
    -- to do anything, and will keep the current structure.
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Current best score=', scoreRecentBest)
    fsl.Print('Current overall improvement=', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
    end
    return delta
end

local function _ScriptFinalize()
    fsl.Print('Final overall improvement=', foldit.GetScore(true) - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    fsl.ResetRecentBest()
    fsl.Print('Score start=', _scoreStart)
    return _scoreStart
end

local function _SelectMultiStart(start)
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return count
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        fsl.BandDelete()
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDelete = _BandDelete,
    BandDisable = _BandDisable,
    BandEnable = _BandEnable,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportScoreIncrease = _ReportScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl library
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDelete()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDelete()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDelete()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- Repeat BlueFuse
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Cataclysm
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc contract
-- Partly based on some ideas in 'Bands from center' by srssmith92
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc contract', repeating)

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnable()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = _SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisable()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat tlaloc contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)

    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDisable)
end

-------------------------------------------------
-- tlaloc Hydrophobe
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc hydrophobe')

    local countSegments = foldit.GetSegmentCount()
    fsl.BandDelete()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDisable()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDisable()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-----------------------------------------
-- tlaloc random tug
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDisable()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('Random Tug')
    local x,y = fsl.BandAddRandom()

    _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    return fsl.ScriptEnd(functionName, scoreStart, noRestore)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- Settle
-- Based on CoLapses Settle
-- This function is not covered by the Creative Commons license given
-- at the start of the script since it a port of CoLapse's
-- algorithm, with some enhancements.
local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat Co lapses Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc MutateAll
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                fsl.WiggleAll(iterations)
                fsl.WiggleSidechains(iterations)
                fsl.ReportScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc MutateFreeze
local function _MutateFreeze()
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateFreeze')
    local changeableSegments = fsl.FindMutatableSegments()
    
    foldit.SelectAll()
    for i=1, #changeableSegments do
        foldit.DeselectIndex(changeableSegments[i])
    end
    foldit.Freeze(true, true)
    
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    MutateFreeze = _MutateFreeze,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.RepeatRandomTug(100, .5, 10, .10)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2592" : "{
 "desc" : "Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the clashing  importance to different values, wiggles, then sets the clashing importance to 1 and shakes out."
 "hidden" : "1"
 "mid" : "2950"
 "mrid" : "13582"
 "name" : "tlaloc Repeat Blue Fuse 3.00"
 "parent" : "2052"
 "parent_mrid" : "409"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- Repeat BlueFuse
local function _RepeatBlueFuse(iterations, sigma, ...)
    -- Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
    -- clashing  importance to different values, wiggles, then sets the clashing importance to 1
    -- and shakes out.
    local functionName, scoreStart = fsl.ScriptBegin('Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Cataclysm
-- Works the same as tlaloc contract, but uses random bands instead of bands to center.
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc contract
-- Partly based on some ideas in 'Bands from center' by srssmith92
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc contract', repeating)

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat tlaloc contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
local function _Hydrophobe(expand, percentBands)
    -- Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
    -- stabilize. Also good when stuck.
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Push
local function _Push(expand, percentBands)
    -- Uses bands to "inflate" the protein, moving everything away from everything else, then
    -- shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
    -- segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
    -- this one does not restore to the starting score if it does not exceed it, letting you try
    -- other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
    -- to the best score since it started.
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-----------------------------------------
-- tlaloc random tug
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- Settle
-- Based on CoLapses Settle

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('Repeat Co lapses Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc MutateAll
local function _MutateAll(iterations)
    -- Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
    -- shakes out.  Do not stop the script during the first part of the run (see output) as it
    -- will leave the segments in a bad state. Time to run is proportional to the number of
    -- mutatable segments.
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2612" : "{
 "desc" : "Works the same as tlaloc contract, but uses random bands instead of bands to center."
 "hidden" : "1"
 "mid" : "3642"
 "mrid" : "13579"
 "name" : "tlaloc Cataclysm 3.00"
 "parent" : "2690"
 "parent_mrid" : "2202"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.Cataclysm(4)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2619" : "{
 "desc" : "Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse until no points are found. Very good to run any time you find points elsewhere."
 "hidden" : "1"
 "mid" : "8074"
 "mrid" : "13558"
 "name" : "tlaloc Shakeout 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randomtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.Shakeout(1, .01, .05, .07, .03)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2628" : "{
 "desc" : "This script figures out how many different starts there are,  and saves them into the quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after running this script. You can also change the parameter to SelectMultiStart to select ones that appear beyond the first 3."
 "hidden" : "1"
 "mid" : "2714"
 "mrid" : "13557"
 "name" : "tlaloc SelectMultiStart 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randomtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
fsl.SelectMultiStart(1)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2664" : "{
 "desc" : "Derived from co lapses settle.  Repeats the settle algorithm until no points are found. Settle does local wiggles in different patterns across the entire protein."
 "hidden" : "1"
 "mid" : "3643"
 "mrid" : "13556"
 "name" : "tlaloc Repeat Settle 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randomtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.RepeatSettle(.1, .1, 1, 1, 2, 2, 4, 1, 2, 2, 2, 2, 3)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2671" : "{
 "desc" : "Creates a random band, then tugs. Then releases until stable.  For bands that are close enough, it may also push  out.  This is the same as tlaloc random tug, except it doesn't repeat and doesn't restore to the best score."
 "hidden" : "1"
 "mid" : "2925"
 "mrid" : "13555"
 "name" : "tlaloc Random One Tug 3.00"
 "parent" : "2711"
 "parent_mrid" : "1364"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randomtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.RandomTug(.01, .5, .03, 10, .10, true)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2681" : "{
 "desc" : "Uses bands to "inflate" the protein, moving everything away from everything else, then shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts, this one does not restore to the starting score if it does not exceed it, letting you try other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get to the best score since it started."
 "hidden" : "1"
 "mid" : "8073"
 "mrid" : "13553"
 "name" : "tlaloc Push 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.Push(1, .1)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2703" : "{
 "desc" : "Takes a protein and completely straightens it out. You will lose your entire structure. You may need to hit the 'home' key to recenter after it is done. Saves the previous protein to quicksave slot 1. Ctrl+1 will get it back, but recommend saving before running this."
 "hidden" : "1"
 "mid" : "3658"
 "mrid" : "13552"
 "name" : "tlaloc Make Denovo 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(1.0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
fsl.MakeDeNovo()
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2717" : "{
 "desc" : "Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to stabilize. Also good when stuck."
 "hidden" : "1"
 "mid" : "4063"
 "mrid" : "13549"
 "name" : "tlaloc Hydrophobe 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.Hydrophobe(1, .1)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2733" : "{
 "desc" : "Converts the entire protein into loops, if it wasn't already all loops. It saves the original structure so that it can be retrieved pressing Ctrl+9."
 "hidden" : "1"
 "mid" : "9867"
 "mrid" : "13548"
 "name" : "tlaloc Convert To Loops 3.00"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
fsl.ConvertToLoops()
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_2746" : "{
 "desc" : "Contracts bands and releases finding points. Works iteritively until there is no improvment. This script bands to center the hydrophobic bands, attempting to pull them in."
 "hidden" : "1"
 "mid" : "2690"
 "mrid" : "13547"
 "name" : "tlaloc Contract 3.00"
 "parent" : "2630"
 "parent_mrid" : "0"
 "player_id" : "57765"
 "script" : "-- tlaloc scripts
--=================================================================================================|

-- You must keep the following attribution and notice in any republication of this script. Please
-- remove the word 'tlaloc' from the script name on the fold.it web site recipe page if you
-- publicly release a modification of the script.

--=======================================
--- Author: tlaloc (aka Greg Reddick)
-- Copyright 2010 by Greg Reddick

-- Except for parts that are specifically excluded in the comments, which came from other sources,
-- this script is licensed as follows:

-- Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- http://creativecommons.org/licenses/by-nc-sa/3.0/

--=======================================

--=======================================
-- tlaloc standard library

math = {}
fsl = {}
recipe = {}
group = {}
banding = {}

foldit =
{
    _BandAddSegmentSegment = band_add_segment_segment,
    _BandDelete = band_delete,
    _BandDisable = band_disable,
    _BandEnable = band_enable,
    BandSetLength = band_set_length,
    BandSetStrength = band_set_strength,
    DeselectAll = deselect_all,
    DeselectIndex = deselect_index,
    Freeze = do_freeze,
    GetAA = get_aa,
    GetBandCount = get_band_count,
    GetScore = get_score,
    GetSegmentCount = get_segment_count,
    GetSegmentDistance = get_segment_distance,
    GetSegmentScore = get_segment_score,
    GetSegmentScorePart = get_segment_score_part,
    GetSidechainSnapCount = get_sidechain_snap_count,
    GetSS = get_ss,
    IsHydrophobic = is_hydrophobic,
    LoadStructure = load_structure,
    _LocalRebuild = do_local_rebuild,
    LocalWiggle = do_local_wiggle,
    _Mutate = do_mutate,
    Quickload = quickload,
    Quicksave = quicksave,
    ReplaceAA = replace_aa,
    ReplaceSS = replace_ss,
    _ResetPuzzle = reset_puzzle,
    _ResetRecentBest = reset_recent_best,
    RestoreAbsBest = restore_abs_best,
    _RestoreRecentBest = restore_recent_best,
    SaveStructure = save_structure,
    SelectAll = select_all,
    SelectIndex = select_index,
    SelectIndexRange = select_index_range,
    _SetBehaviorClashImportance = set_behavior_clash_importance,
    _Shake = do_shake,
    SidechainSnap = do_sidechain_snap,
    _UnfreezeAll = do_unfreeze_all,
    _WiggleAll = do_global_wiggle_all,
    _WiggleBackbone = do_global_wiggle_backbone,
    _WiggleSidechains = do_global_wiggle_sidechains,
}

band_add_segment_segment = nil
band_delete = nil
band_disable = nil
band_enable = nil
band_set_length = nil
band_set_strength = nil
deselect_all = nil
deselect_index = nil
do_freeze = nil
do_local_rebuild = nil
get_band_count = nil
get_score = nil
get_segment_count = nil
get_segment_distance = nil
get_segment_score = nil
get_segment_score_part = nil
get_sidechain_snap_count = nil
get_ss = nil
load_structure = nil
do_local_wiggle = nil
do_mutate = nil
quickload = nil
quicksave = nil
replace_aa = nil
replace_ss = nil
reset_puzzle = nil
reset_recent_best = nil
restore_abs_best = nil
restore_recent_best = nil
save_structure = nil
select_all = nil
select_index = nil
select_index_range = nil
set_behavior_clash_importance = nil
do_shake = nil
unfreeze_all = nil
do_global_wiggle_all = nil
do_global_wiggle_backbone = nil
do_global_wiggle_sidechains = nil

_print = print
print = nil

-----------------------------------------
-- standard functions

local function assert(v, message)
   if not v then
       _print('Assertion failure: ', message)
       failure() -- intentionally an undefined function
   end
end

-----------------------------------------
-- math library

-----------------------------------------
-- The original random script this was ported from has the following notices:

-- Copyright (c) 2007 Richard L. Mueller
-- Hilltop Lab web site - http://www.rlmueller.net
-- Version 1.0 - January 2, 2007

-- You have a royalty-free right to use, modify, reproduce, and distribute this script file in any
-- way you find useful, provided that you agree that the copyright owner above has no warranty,
-- obligations, or liability for such use.

-- This function is not covered by the Creative Commons license given at the start of the script,
-- and is instead covered by the comment given here.
-----------------------------------------

local lngX = 1000
local lngC = 48313

local function _MWC()
    local S_Hi
    local S_Lo
    local C_Hi
    local C_Lo
    local F1
    local F2
    local F3
    local T1
    local T2
    local T3

    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296

    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local C_Lo = lngC - (C_Hi * H)

    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
    local F3 = (A_Lo * S_Lo) + C_Lo

    local T1 = math.floor(F2 / H)
    local T2 = F2 - (T1 * H)
    lngX = (T2 * H) + F3
    local T3 = math.floor(lngX / M)
    lngX = lngX - (T3 * M)

    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        value = -value
    end
    return value
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(x)
    lngX = x
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

-- End math library
-----------------------------------------
-- fsl (Foldit Standard Library)

local _scoreRecentBest = -999999.9
local _initialized = false
local _scoreStart = -999999.9
local _saveSlots = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
local _printStatus = true
local _bandsAtStart = 0

local amino = {'a', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'y' }

local function _BandAddBetweenSegments(segmentIndex1, segmentIndex2)
    fsl.Print('Adding band between segment ', segmentIndex1, ' and ', segmentIndex2)
    foldit._BandAddSegmentSegment(segmentIndex1, segmentIndex2)
end

local function _BandAddRandom()
    local segmentCount = foldit.GetSegmentCount()
    local x = math.random(1, segmentCount)
    local y
    repeat
        y =  math.random(1, segmentCount)
    until math.abs(x - y) >= 2
    fsl.BandAddBetweenSegments(x, y)
    return x, y
end

local function _BandDeleteScriptStart()
    fsl.Print('Deleting created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDelete()
    else
        for i=foldit.GetBandCount(), fsl.BandsAtStart() + 1, -1 do
            foldit._BandDelete(i)
        end
    end
end

local function _BandDisable()
    fsl.Print('Disabling bands')
    foldit._BandDisable()
end

local function _BandDisableScriptStart()
    fsl.Print('Disabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandDisable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandDisable(i)
        end
    end
end

local function _BandEnable()
    fsl.Print('Enabling bands')
    foldit._BandEnable()
end

local function _BandEnableScriptStart()
    fsl.Print('Enabling created bands')
    if fsl.BandsAtStart() == 0 then
        foldit._BandEnable()
    else
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit._BandEnable(i)
        end
    end
end

local function _BandStrength(strength)
    -- Just modifies all bands strengths. The UI only lets the strength go from 0.5 to 1.5, and
    -- it's tedious to modify a lot of bands. Great when you really, really want the backbone to
    -- move and it's being stubborn.
    fsl.Print('Setting band strength to ', strength)
    for i=1, foldit.GetBandCount() do
        foldit.BandSetStrength(i, strength)
    end
end

local function _BandsAtStart()
    return _bandsAtStart
end

local function _BlueFuse(iterations, sigma, ...)
    -- Based on vertex's BlueFuse

    -- This function is not covered by the Creative Commons license given at the start of the
    -- script since it a port of Vertex's BlueFuse algorithm, with some enhancements.

    local arg = {...}
    local saveSlot = fsl.RequestSaveSlot()
    
    local scoreStart = foldit.GetScore(true)
    local scoreBest = scoreStart
    foldit.Quicksave(saveSlot)
    fsl.SetBehaviorClashImportance(1.0)
    for i=1, #arg do
        fsl.SetBehaviorClashImportance(arg[i])
        local printStatus = fsl.PrintStatus(false)
        fsl.Shake(1)

        fsl.SetBehaviorClashImportance(1.0)
        fsl.WiggleAll(iterations)
 
        fsl.MakeStable(false, sigma, iterations)
        fsl.PrintStatus(printStatus)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            foldit.Quicksave(saveSlot)
            fsl.ReportAndLockScoreIncrease()
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print('Bluefuse complete. Score change=', delta)
    return delta
end

local function _ConvertToLoops()
    -- Converts the entire protein into loops, if it wasn't already all loops. It saves the
    -- original structure so that it can be retrieved pressing Ctrl+9.

    fsl.Print('Converting structure to loops')
    local countSegments = foldit.GetSegmentCount()
    
    -- Only overwrite the saved structure if the current structure isn't all loops
    local nonLoops = false
    for i=1, countSegments do
        if foldit.GetSS(i) ~= 'L' then
            nonLoops = true
            break
        end
    end
    if not nonLoops then
        foldit.SaveStructure()
    end
    
    local structure = {}
    for i=1, countSegments do
        structure[i] = foldit.GetSS(i)
    end
    foldit.SelectAll()
    foldit.ReplaceSS('L')
    return structure
end

local function _FindBestStart()
    -- Performs a Select MultiStart, then shakes out each start to find the best one.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local saveSlot = fsl.RequestSaveSlot()
    local scoreBest = -999999.9
    local indexBest = 0
    local scores = fsl.SelectMultiStart()
    local countTries = #scores
    for i=1, countTries do
        fsl.PrintTries('Find Best Start', i, countTries)
        fsl.Print('Current best is start #', indexBest, ' with score ', scoreBest)
        
        -- find start that has the score score
        while true do
            fsl.ResetPuzzle()
            if foldit.GetScore(true) == scores[i] then
                break
            end
        end

        fsl.ResetRecentBest()
        fsl.MakeStable(nil, .01, 1)
        fsl.BlueFuse(1, .01, .05, .07, .03)
        recipe.Settle(.1, 1, 1, 2, 1, 2, 2, 2)
        local score = foldit.GetScore(true)
        if score > scoreBest then
            scoreBest = score
            indexBest = i
            foldit.Quicksave(saveSlot)
        end
    end
    foldit.Quickload(saveSlot)
    fsl.ResetRecentBest()
    fsl.Print('Best start was #', indexBest)
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _FindCenterSegment()
    -- Finds the segment that is the least distance to all other segments
    -- returns index of the center segment
    fsl.Print('Finding the center segment')
    local segmentCount =  foldit.GetSegmentCount()
    local minDistance = 100000.0
    local distance
    local indexCenter
    for i=1,segmentCount do
        distance = 0
        for j=1,segmentCount do
            distance = distance +  foldit.GetSegmentDistance(i, j)
        end
        if(distance < minDistance) then
             minDistance = distance
             indexCenter =  i
        end
    end
    return indexCenter
end

local function _FindMutatableSegments()
    local saveSlot = fsl.RequestSaveSlot()
    local changeableSegments = {}
    fsl.Print('Do not cancel the script in this section')
    foldit.Quicksave(saveSlot)
    local replace = 'g'
    
    -- BUG: the -1 on the next line is due to a foldit bug
    -- The ligand is considered the last segment
    for i=1, foldit.GetSegmentCount() - 1 do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        local before = foldit.GetAA(i)
        if before == 'g' then
            replace = 'q'
        else
            replace = 'g'
        end
        foldit.ReplaceAA(replace)
        local after = foldit.GetAA(i)
        if after ~= before then
            changeableSegments[#changeableSegments + 1] = i
        end
    end
    foldit.Quickload(saveSlot)
    fsl.Print('You can cancel now')
    fsl.ReleaseSaveSlot(saveSlot)
    return changeableSegments
end

local function _FreezeAll()
    fsl.Print('Freezing all segments')
    foldit.SelectAll()
    foldit.Freeze(true, true)
end

local function _FreezeSegments(interval, start)
    fsl.Print('Freezing every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    foldit.DeselectAll()
    for i=start, foldit.GetSegmentCount(), interval do
        foldit.SelectIndex(i)
    end
    foldit.Freeze(true, true)
end

local function _GetScoreRecentBest()
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)
    foldit._RestoreRecentBest()
    local score = foldit.GetScore(true)
    foldit.Quickload(saveSlot)
    fsl.ReleaseSaveSlot(saveSlot)
    return score
end

local function _GetScoreStart()
    return _scoreStart
end

local function _GetSeed()
    local seed = 0
    local score = foldit.GetScore(true)
    local fraction = (score - math.floor(score)) * 1000
    local least = fraction - math.floor(fraction)
    seed = math.floor(least * 100000)
    return seed
end

local function _GetSegmentScores(segmentFirst, segmentLast)
    local score = 0
    for i=segmentFirst, segmentLast do
        score = score + foldit.GetSegmentScore(i)
    end
    return score
end

local function _LocalRebuild(iterations)
    foldit._LocalRebuild(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _LocalWiggleInterval(interval, start, iterations)
    local saveSlot = fsl.RequestSaveSlot()
    fsl.Print('LocalWiggle every ', interval, ' segments')
    fsl.Print('  starting at segment ', start)
    local first
    local segmentCount = foldit.GetSegmentCount()
    for i=start, segmentCount, interval do
        foldit.DeselectAll()
        local first = i
        if first < 1 then
            first = 1
        end
        local last = i + interval
        if last > segmentCount then
            last = segmentCount
        end
        foldit.SelectIndexRange(first, last)
        local score = foldit.GetScore(true)
        foldit.Quicksave(saveSlot)
        foldit.LocalWiggle(iterations)
        if foldit.GetScore(true) <= score then
            foldit.Quickload(saveSlot)
        end
        fsl.ReportAndLockScoreIncrease()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _MakeDeNovo()
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    foldit.Quicksave(1)
    fsl.SetPristine()
    fsl.ConvertToLoops()
    fsl.SetBehaviorClashImportance(0)
    for distance=5, 3, -1 do
        for i=1, foldit.GetSegmentCount() - distance do
            fsl.BandAddBetweenSegments(i, i + distance)
        end
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetLength(i, 20.0)
            foldit.BandSetStrength(i, 10.0)
        end
        fsl.Shake(1)
        fsl.WiggleAll(1)
        fsl.BandDeleteScriptStart()
    end
    fsl.SetBehaviorClashImportance(0)
end

local _shakesWin = 0
local _wigglesWin = 0
local _tiesWin = 0
local function _MakeStable(shakeFirst, sigmaStableScore, iterations)
    -- shakeFirst
    --    if true shakes before wiggling
    --    if false wiggles before shaking
    --    if nil, tries it both ways and takes the best score

    local saveSlotOriginal = fsl.RequestSaveSlot()
    local saveSlotShake = fsl.RequestSaveSlot()
    local prevScore = 0
    local delta
    local score

    if shakeFirst == nil then
         foldit.Quicksave(saveSlotOriginal)
         fsl.Print('Trying shake first')
         local scoreShakeFirst = fsl.MakeStable(true, sigmaStableScore, iterations)
         foldit.Quicksave(saveSlotShake)
         foldit.Quickload(saveSlotOriginal)
         fsl.Print('Trying wiggle first')
         local scoreWiggleFirst = fsl.MakeStable(false, sigmaStableScore, iterations)
         fsl.Print('Shake=', scoreShakeFirst, ' Wiggle=', scoreWiggleFirst)
         if scoreShakeFirst > scoreWiggleFirst then
             _shakesWin = _shakesWin + 1
             fsl.Print('Restoring shake result')
             foldit.Quickload(saveSlotShake)
         else
             if scoreShakeFirst == scoreWiggleFirst then
                 _tiesWin = _tiesWin + 1
             else
                 _wigglesWin = _wigglesWin + 1
             end
             fsl.Print('Keeping wiggle result')
         end
         fsl.Print('Shakes win=', _shakesWin, ' Wiggles win=', _wigglesWin, ' ties=', _tiesWin)
    else
        repeat
            local printStatus = fsl.PrintStatus(false)
            if shakeFirst then
                fsl.Shake(1)
                fsl.WiggleBackbone(iterations)
            else
                fsl.WiggleBackbone(iterations)
                fsl.Shake(1)
            end
            fsl.PrintStatus(printStatus)
            score = foldit.GetScore(true)
            delta = math.abs(score - prevScore)
            if prevScore ~= 0 then
               fsl.Print('delta=', delta, ' goal=', sigmaStableScore)
            end
            prevScore = score
        until delta <= sigmaStableScore
        fsl.WiggleSidechains(iterations)
    end
    fsl.ReleaseSaveSlot(saveSlotShake)
    fsl.ReleaseSaveSlot(saveSlotOriginal)
    return foldit.GetScore(true)
end

local function _Mutate(iterations)
    fsl.Print('Mutating for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Mutate(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _Print(...)
    if _printStatus then
        _print(...)
    end
end

local function _PrintStatus(status)
    local prevStatus = _printStatus
    _printStatus = status
    return prevStatus
end

local function _PrintLine()
    fsl.Print('--------------------------------------------------')
end

local function _PrintTries(functionName, try, tries, keyword)
    if keyword == nil then
        keyword = 'try'
    end
    if tries == nil then
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' ****')
    else
        fsl.Print('**** ', functionName, ' ', keyword, ' ', try, ' of ', tries, ' ****')
    end
end

local function _ReleaseSaveSlot(slot)
    _saveSlots[#_saveSlots + 1] = slot
end

local function _ReportAndLockScoreIncrease()
    local score = foldit.GetScore(true)
    if score > _scoreRecentBest then
        _print('++++ ', fsl.GetScoreRecentBest(), ' ++++')
        _scoreRecentBest = score
    end
end

local function _RequestSaveSlot()
    assert(#_saveSlots > 0, 'Out of save slots')
    local saveSlot = _saveSlots[#_saveSlots]
    _saveSlots[#_saveSlots] = nil
    return saveSlot
end

local function _ResetPuzzle()
    fsl.Print('Resetting puzzle')
    foldit._ResetPuzzle()
end

local function _ResetRecentBest()
    fsl.Print('Saving recent best')
    foldit._ResetRecentBest()
    _scoreRecentBest = foldit.GetScore(true)
end

local function _RestoreOriginalStructure()
    -- Resets to the structure available at the time the puzzle is reset. Since alignment tool
    -- applies structure after that time, this will not recover that structure. Furthermore, this
    -- works randomly on puzzles that are multistart, where it always takes the reset structure,
    -- which is random. If the original structure is all loops, then it refuses to do anything,
    -- and will keep the current structure.
    
    fsl.Print('Restoring original structure')
    local saveSlot = fsl.RequestSaveSlot()
    foldit.Quicksave(saveSlot)

    fsl.ResetPuzzle()
    local allLoops = true
    for i=1, foldit.GetSegmentCount() do
        if foldit.GetSS(i) ~= "L" then
            allLoops = false
            break
        end
    end
    if allLoops then
        foldit.Quickload(saveSlot)
    else
        foldit.SaveStructure()
        foldit.Quickload(saveSlot)
        foldit.LoadStructure()
    end
    fsl.ReleaseSaveSlot(saveSlot)
end

local function _RestoreRecentBest()
    fsl.Print('Restoring recent best')
    foldit._RestoreRecentBest()
end

local function _RestoreStructure(structure)
    fsl.Print('Restoring structure')
    for i=1, foldit.GetSegmentCount() do
        foldit.DeselectAll()
        foldit.SelectIndex(i)
        foldit.ReplaceSS(structure[i])
    end
end

local function _Round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

local function _ScriptBegin(functionName)
    fsl.PrintLine()
    fsl.Print('Running ', functionName)
    fsl.ReportAndLockScoreIncrease()
    local scoreRecentBest = fsl.GetScoreRecentBest()
    fsl.Print('Overall score: >>>> ', scoreRecentBest, ' <<<<')
    fsl.Print('Overall improvement: ', scoreRecentBest - fsl.GetScoreStart())
    return functionName, foldit.GetScore(true)
end

local function _ScriptEnd(functionName, scoreStart, noRestore, functionExecute, ...)
    if not noRestore then
        fsl.RestoreRecentBest()
    end
    local delta = foldit.GetScore(true) - scoreStart
    fsl.Print(functionName, ' complete. Score change=', delta)
    if functionExecute ~= nil then
        functionExecute(...)
        fsl.ResetRecentBest()
    end
    return delta
end

local function _ScriptFinalize()
    local score = foldit.GetScore(true)
    fsl.Print('Final score: >>>> ', score, ' <<<<')
    fsl.Print('Final improvement: ', score - fsl.GetScoreStart())
    fsl.Print('**** Script complete ****')
    assert(#_saveSlots == 10, 'One or more save slots not released')
end

local function _ScriptInitialize()
    fsl.Print('Initializing script')
    assert(not _initialized, 'Initialized more than once')
    _initialized = true
    math.randomseed(fsl.GetSeed())
    _scoreStart = foldit.GetScore(true)
    _bandsAtStart = foldit.GetBandCount()
    fsl.ResetRecentBest()
    fsl.Print('Start score: >>>> ', _scoreStart, ' <<<<')
    return _scoreStart
end

local function _SelectMultiStart(start)
    -- This script figures out how many different starts there are,  and saves them into the
    -- quickload save spots. You can use ctrl+1, ctrl+2, or ctrl+3 to load the first 3 after 
    -- running this script. You can also change the parameter to SelectMultiStart to select ones
    -- that appear beyond the first 3.
    assert(foldit.GetBandCount() == 0, 'Must delete existing bands\\
before running this code.')
    local puzzle = {}
    local scores = {}
    local count = 0
    fsl.SetPristine()
    fsl.ResetRecentBest()

    -- Find the unique starting scores
    for i=1,100 do
        fsl.ResetPuzzle()

        local score = foldit.GetScore(true)
        if puzzle[score] == nil then
            count = count + 1
            puzzle[score] = count
            scores[count] = score
        end
    end

    -- Bubble sort to sort by score. Inefficient, but
    -- I don't care because the number will always be
    -- small.
    for i=1,count - 1 do
        for j = count, i + 1, -1 do
            if scores[i] < scores[j] then
                scores[j], scores[i] = scores[i], scores[j]
                puzzle[scores[j]] = i
                puzzle[scores[i]] = j
            end
        end
    end

    for i=1, count do
        fsl.Print('puzzle #', i, ' has score ', scores[i])
        if i < 10 then
            while true do
                fsl.ResetPuzzle()
                if foldit.GetScore(true) == scores[i] then
                    foldit.Quicksave(i)
                    break
                end
            end
        end
    end

    fsl.Print('There are ', count, ' starts')
    if start ~= nil then
        fsl.Print('Loading start #', start)
        foldit.Quickload(start)
    else
        fsl.RestoreRecentBest()
    end
    return scores
end

local function _SetBehaviorClashImportance(importance)
    fsl.Print('Setting clash importance to ', importance)
    foldit._SetBehaviorClashImportance(importance)
end

local function _SetPristine(noClash, noUnfreeze, noDeleteBands, noSelectAll)
    -- Clean up the environment
    local printStatus = fsl.PrintStatus(false)
    if not noClash then
        fsl.SetBehaviorClashImportance(1.0)
    end
    if not noUnfreeze then
        fsl.UnfreezeAll()
    end
    if not noDeleteBands then
        foldit._BandDelete()
        _bandsAtStart = 0
    end
    if not noSelectAll then
        foldit.DeselectAll()
        foldit.SelectAll()
    end
    fsl.PrintStatus(printStatus)
end

local function _Shake(iterations)
    fsl.Print('Shaking sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._Shake(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _UnfreezeAll()
    fsl.Print('Unfreezing all segments')
    foldit.SelectAll()
    foldit._UnfreezeAll()
end

local function _WiggleAll(iterations)
    fsl.Print('Wiggle all for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleAll(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleBackbone(iterations)
    fsl.Print('Wiggle backbone for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleBackbone(iterations)
    fsl.ReportAndLockScoreIncrease()
end

local function _WiggleSidechains(iterations)
    fsl.Print('Wiggle sidechains for ', iterations, ' iterations')
    foldit.SelectAll()
    foldit._WiggleSidechains(iterations)
    fsl.ReportAndLockScoreIncrease()
end

fsl =
{
    BandAddBetweenSegments = _BandAddBetweenSegments,
    BandAddRandom = _BandAddRandom,
    BandDeleteScriptStart = _BandDeleteScriptStart,
    BandDisable = _BandDisable,
    BandDisableScriptStart = _BandDisableScriptStart,
    BandEnable = _BandEnable,
    BandEnableScriptStart = _BandEnableScriptStart,
    BandStrength = _BandStrength,
    BandsAtStart = _BandsAtStart,
    BlueFuse = _BlueFuse,
    ConvertToLoops = _ConvertToLoops,
    FindBestStart = _FindBestStart,
    FindCenterSegment = _FindCenterSegment,
    FindMutatableSegments = _FindMutatableSegments,
    FreezeAll = _FreezeAll,
    FreezeSegments = _FreezeSegments,
    GetScoreRecentBest = _GetScoreRecentBest,
    GetScoreStart = _GetScoreStart,
    GetSeed = _GetSeed,
    GetSegmentScores = _GetSegmentScores,
    LocalRebuild = _LocalRebuild,
    LocalWiggleInterval = _LocalWiggleInterval,
    MakeDeNovo = _MakeDeNovo,
    MakeStable = _MakeStable,
    Mutate = _Mutate,
    Print = _Print,
    PrintLine = _PrintLine,
    PrintStatus = _PrintStatus,
    PrintTries = _PrintTries,
    ReleaseSaveSlot = _ReleaseSaveSlot,
    RequestSaveSlot = _RequestSaveSlot,
    ReportAndLockScoreIncrease = _ReportAndLockScoreIncrease,
    ResetPuzzle = _ResetPuzzle,
    ResetRecentBest = _ResetRecentBest,
    RestoreOriginalStructure = _RestoreOriginalStructure,
    RestoreRecentBest = _RestoreRecentBest,
    RestoreStructure = _RestoreStructure,
    Round = _Round,
    ScriptBegin = _ScriptBegin,
    ScriptEnd = _ScriptEnd,
    ScriptFinalize = _ScriptFinalize,
    ScriptInitialize = _ScriptInitialize,
    SelectMultiStart = _SelectMultiStart,
    SetBehaviorClashImportance = _SetBehaviorClashImportance,
    SetPristine = _SetPristine,
    Shake = _Shake,
    UnfreezeAll = _UnfreezeAll,
    WiggleAll = _WiggleAll,
    WiggleBackbone = _WiggleBackbone,
    WiggleSidechains = _WiggleSidechains,
}

-- End fsl (Foldit Standard Library)
-------------------------------------------------
-- Banding library
local function _CreateBandsToCenter()
    -- Partly based on some ideas in 'Bands from center' by srssmith92

    fsl.Print('Creating bands to center')
    local indexCenter = fsl.FindCenterSegment()
    fsl.BandDisable()
    for i=1, foldit.GetSegmentCount() do
        if(i ~= indexCenter) then
            -- If hydrophobic
            if foldit.IsHydrophobic(i) then
                fsl.BandAddBetweenSegments(i,indexCenter)
            end
        end
    end
end

local function _CreateRandomBands()
    fsl.Print('Creating random bands')
    fsl.BandDisable()
    for i=1, math.floor(foldit.GetSegmentCount()/4) do
        fsl.BandAddRandom()
    end
end

local function _CreateHydrophobeBands()
    fsl.Print('Creating hydrophobe bands')
    local countSegments = foldit.GetSegmentCount()
    fsl.BandDisable()
    for x=1, countSegments do
        if foldit.IsHydrophobic(x) then
            for y=x+2, countSegments do
                if foldit.IsHydrophobic(y) then
                    fsl.BandAddBetweenSegments(x, y)
                end
            end
        end
    end
end

local banding =
{
    CreateBandsToCenter = _CreateBandsToCenter,
    CreateRandomBands = _CreateRandomBands,
    CreateHydrophobeBands = _CreateHydrophobeBands,
}
-- End banding library
-------------------------------------------------
-- End tlaloc standard library
--===============================================

-------------------------------------------------
-- tlaloc Cataclysm
--[[
Works the same as tlaloc contract, but uses random bands instead of bands to center.
--]]
local function _Cataclysm(tries)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Cataclysm')
    for i=1,tries do
        fsl.PrintTries(functionName, i, tries)
        recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateRandomBands)
        recipe.RepeatBlueFuse(1, .01, .05, .07, .03)
    end
    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Contract
--[[
Contracts bands and releases finding points. Works iteratively until no points are to
be found.
--]]
local function _SetEnableBands(startStrength, changeScore, deltaStrength)
    local strength = startStrength
    local score = nil
    local delta = nil
    local startScore = foldit.GetScore(true)
    repeat
        fsl.Print('Bands strength=', strength)
        for i=fsl.BandsAtStart() + 1, foldit.GetBandCount() do
            foldit.BandSetStrength(i, strength)
        end
        fsl.WiggleBackbone(1)
        score = foldit.GetScore(true)
        delta = math.abs(score - startScore)
        strength = strength + deltaStrength
        if strength > 2.0 then
            -- no amount of strength will get it to move
            strength = 2.0
            break
        end
    until delta >= changeScore
    strength = strength - deltaStrength
    return strength
end

local contractprocs =
{
    SetEnableBands = _SetEnableBands,
}

local strengthContract
local function _Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, shakeFirst, repeating, bandingMethod)
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- shakeFirst is whether it should shake before wiggling
    -- repeating is set to true when this function will be called multiple times without resetting in between
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Contract')

    if not repeating then
        if bandingMethod ~= nil then
            bandingMethod()
        end
        strengthContract = 0
    end

    fsl.BandEnableScriptStart()
    strengthContract = strengthContract - (strengthBackoffMultiplier * deltaStrength)
    if strengthContract < 0 then
        strengthContract = 0
    end
    strengthContract = contractprocs.SetEnableBands(strengthContract, changeScore, deltaStrength)
    fsl.BandDisableScriptStart()
    fsl.MakeStable(shakeFirst, sigmaStableScore, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, repeating)
end

local function _RepeatContract(tries, sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, bandingMethod)
    -- tries is the number of contractions without finding points before it gives up
    -- sigmaStableScore is the maximum amount of score change for the structure to be consider stable.
    -- changeScore is the minimum amount of score change for there to be a significant change in the structure of the protein.
    -- deltaStrength is the amount of strength of bands added on each iteration. Smaller values take longer, larger values may cause too much change.
    -- strengthBackoffMultiplier is the amount that it reduces the strength that it moved on the last pass for the next pass.
    -- iterations is the parameter to the wiggle and shakes
    -- bandingMethod is a reference to the function that establishes the bands

    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Contract')

    if bandingMethod ~= nil then
        bandingMethod()
    end
    strengthContract = 0

    local foundpoints
    local scoreBefore = scoreStart
    repeat
        foundpoints = false
        for try=1, tries do
            fsl.PrintLine()
            fsl.PrintTries(functionName, try, tries)
            recipe.Contract(sigmaStableScore, changeScore, deltaStrength, strengthBackoffMultiplier, iterations, tries % 2 == 0, true, 0)
            local score = foldit.GetScore(true)
            local delta = score - scoreBefore
            if delta > 0 then
                foundpoints = true
                scoreBefore = score
                fsl.Print('Found ', delta, ' points, starting over')
                break
            end
        end
    until not foundpoints

    fsl.WiggleSidechains(20)
    
    return fsl.ScriptEnd(functionName, scoreStart, false, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc Hydrophobe
--[[
Pushes out hydrophyllic segments, pulls in hydrophobic segments. Good after threading to
stabilize. Also good when stuck.
--]]
local function _Hydrophobe(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Hydrophobe')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        for y = x + 2, countSegments do
            local isHydrophobicX = foldit.IsHydrophobic(x)
            local isHydrophobicY = foldit.IsHydrophobic(y)
            if (isHydrophobicX == isHydrophobicY) and (math.random() <= percentBands) then
                local distance = foldit.GetSegmentDistance(x, y)
                if  distance <= (20 - expand) then
                    fsl.BandAddBetweenSegments(x, y)
                    local band = foldit.GetBandCount()
                    if isHydrophobicX then
                        foldit.BandSetLength(band, distance - expand)
                    else
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- tlaloc MutateAll
--[[
Only useful on design puzzles. Mutates every mutatable segment to every possibility, then
shakes out.  Do not stop the script during the first part of the run (see output) as it
will leave the segments in a bad state. Time to run is proportional to the number of
mutatable segments.
--]]
local function _MutateAll(iterations)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc MutateAll')
    local countSegments = foldit.GetSegmentCount() - 1 --BUG in foldit requires the -1
    local changeableSegments = fsl.FindMutatableSegments()
    local originalSegments = {}
    for i=1, countSegments do
        originalSegments[i] = {AA=foldit.GetAA(i), Score=0}
    end
    fsl.WiggleAll(iterations)
    fsl.WiggleSidechains(iterations)
    --[[
    for i=1, #changeableSegments do
        foldit.DeselectAll()
        foldit.SelectIndex(changeableSegments[i])
        foldit.ReplaceAA('g')
    end
    --]]
    local randomSegments = {}
    while #randomSegments < #changeableSegments do
        local i = math.random(1, #changeableSegments)
        if changeableSegments[i] ~= 0 then
            randomSegments[#randomSegments + 1] = changeableSegments[i]
            changeableSegments[i] = 0
        end
    end
    fsl.ResetRecentBest()
    local scorePrevious = foldit.GetScore(true)
    for i=1, #randomSegments do
        local segment = randomSegments[i]
        fsl.PrintTries('Mutating', i, #randomSegments, 'segment')
        local aa = foldit.GetAA(segment)
        fsl.Print('Segment #', segment, ' is ', aa)
        for iAmino=1, #amino do
            if aa ~= amino[iAmino] then
                foldit.DeselectAll()
                foldit.SelectIndex(segment)
                fsl.Print(i, ' Trying amino acid ', iAmino, ' ', amino[iAmino])
                foldit.ReplaceAA(amino[iAmino])
                local printStatus = fsl.PrintStatus(false)
                for iSidechains=1, foldit.GetSidechainSnapCount(i) do
                    foldit.SidechainSnap(segment, iSidechains)
                    fsl.WiggleAll(iterations)
                end
                fsl.ReportAndLockScoreIncrease()
                fsl.RestoreRecentBest()
                fsl.PrintStatus(printStatus)
                local score = foldit.GetScore(true)
                if score > scorePrevious then
                    originalSegments[segment].Score = originalSegments[segment].Score + (score - scorePrevious)
                    scorePrevious = score
                end
            end
        end
        for i=1, countSegments do
            local aa = foldit.GetAA(i)
            if aa ~= originalSegments[i].AA or originalSegments[i].Score ~= 0 then
                fsl.Print('Segment #', i, ' ', originalSegments[i].AA, '->', aa, ' improved ', originalSegments[i].Score)
            end
        end
    end
    return fsl.ScriptEnd(functionName, scoreStart, true)
end

-------------------------------------------------
-- tlaloc Push
--[[
Uses bands to "inflate" the protein, moving everything away from everything else, then
shaking out. Similar to tlaloc hydrophobe, but does not try to manipulate the hydrophobic
segments.  Good in the mid-game when stuck at a local minimum. Unlike most of my scripts,
this one does not restore to the starting score if it does not exceed it, letting you try
other manipulation from where the script finishes. Manually Undo Restore Rcnt Best to get
to the best score since it started.
--]]
local function _Push(expand, percentBands)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Push')

    fsl.BandDisable()
    local countSegments = foldit.GetSegmentCount()
    for x=1, countSegments - 2 do
        if not foldit.IsHydrophobic(x) then
            for y = x + 2, countSegments do
                if (not foldit.IsHydrophobic(y)) and (math.random() <= percentBands) then
                    local distance = foldit.GetSegmentDistance(x, y)
                    if  distance <= (20 - expand) then
                        fsl.BandAddBetweenSegments(x, y)
                        local band = foldit.GetBandCount()
                        foldit.BandSetStrength(band, 2.0)
                        foldit.BandSetLength(band, distance + expand)
                    end
                end
            end
        end
    end

    fsl.WiggleBackbone(1)
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(false, .01, 1)
    fsl.BlueFuse(1, .01, .05, .07, .03)

    return fsl.ScriptEnd(functionName, scoreStart, true, fsl.BandDeleteScriptStart)
end

-------------------------------------------------
-- Repeat BlueFuse
--[[
Repeats vertex's Blue Fuse algorithm until no point are found. BlueFuse alters the
clashing  importance to different values, wiggles, then sets the clashing importance to 1
and shakes out.
--]]
local function _RepeatBlueFuse(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat BlueFuse')

    local try = 0
    repeat
         try = try + 1
         fsl.PrintLine()
         fsl.PrintTries(functionName, try)
    until math.abs(fsl.BlueFuse(iterations, sigma, ...)) <= sigma

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-----------------------------------------
-- tlaloc Random Tug
--[[
Creates a band between two random segments and shakes out. Keeps trying different segments.
Sometimes finds points that tlaloc cataclysm does not. Good script when you are at a local
minimum and cannot find points anywhere else.
--]]
local function _Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, pull)
    local score = foldit.GetScore(true)

    -- either pull or push (for distances less than 20)
    if  pull then
        fsl.Print('Pulling')
        for strength=deltaChange, 2.0, deltaChange do
            assert(strength < 2.0, 'Strength out of bounds')
            if strength < 0 then
                strength = 0
            end
            if strength > 2.0 then
                strength = 2.0
            end
            foldit.BandSetStrength(1, strength)
            fsl.WiggleBackbone(1)
            if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                fsl.Print('Band strength=', strength)
                break
            end
        end
    else
        fsl.Print('Pushing')
        local lengthStart = foldit.GetSegmentDistance(x, y)
        if lengthStart > 20 then
            fsl.Print('Bands too far apart, can\'t push')
        else
            strength = 1.0
            for length=lengthStart, 20, 0.1 do
                foldit.BandSetLength(1, length)
                fsl.WiggleBackbone(1)
                if math.abs(foldit.GetScore(true) - score) >= sigmaMovement then
                    fsl.Print('length=', length)
                    break
                end
                foldit.BandSetStrength(1, strength)
                strength = strength + deltaChange
                if strength > 2.0 then
                    strength = 2.0
                end
            end
        end
    end
    fsl.BandDeleteScriptStart()
    fsl.MakeStable(nil, sigmaStableScore, 1)
end

local randomtugprocs =
{
    Tug = _Tug,
}

local function _RandomTug(sigmaStableScore, sigmaMovement, deltaChange, noRestore)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Random Tug')
    local x,y = fsl.BandAddRandom()

    randtugprocs.Tug(sigmaStableScore, sigmaMovement, deltaChange, x, y, math.random(0, 1) == 0)
    
    return fsl.ScriptEnd(functionName, scoreStart, noRestore, fsl.BandDeleteScriptStart)
end

local function _RepeatRandomTug(tries, sigmaStableScore, sigmaMovement, deltaChange)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Random Tug')

    for try=1, tries do
        fsl.PrintLine()
        fsl.PrintTries(functionName, try, tries)
        if recipe.RandomTug(sigmaStableScore, sigmaMovement, deltaChange) > 0 then
            fsl.BlueFuse(1, .01, .05, .07, .03)
        end
    end

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Settle
-- Based on CoLapses Settle
--[[
Repeats the settle algorithm until no points are found. Settle does local wiggles in different
patterns across the entire protein.
--]]

-- This function is not covered by the Creative Commons license given at the start of the script
-- since it a port of CoLapse's algorithm, with some enhancements.

local function _Settle(sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Settle')
    local arg = {...}
    local start
    local interval

    assert(#arg % 2 == 0)
    for i=1, #arg, 2 do
       start = arg[i]
       interval = arg[i+1]
       fsl.UnfreezeAll()
       fsl.FreezeSegments(interval, start)
       fsl.LocalWiggleInterval(interval, start - interval + 1, iterations)
    end

    fsl.UnfreezeAll()
    fsl.FreezeSegments(finalInterval, finalStart)
    fsl.LocalWiggleInterval(finalInterval, finalStart - finalInterval + 1, iterations)
    fsl.WiggleBackbone(iterations)
    fsl.UnfreezeAll()
    fsl.MakeStable(nil, sigmaStable, iterations)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

local function _RepeatSettle(sigmaImprovement, sigmaStable, iterations, finalStart, finalInterval, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Repeat Settle')

    local i = 0
    repeat
         fsl.PrintLine()
         i = i + 1
         fsl.PrintTries(functionName, i)
    until _Settle(sigmaStable, iterations, finalStart, finalInterval, ...) <= sigmaImprovement

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

-------------------------------------------------
-- tlaloc Shakeout
--[[
Finds the best score between doing a shake/wiggle or a wiggle/shake. Then does a repeat Bluefuse
until no points are found. Very good to run any time you find points elsewhere.
--]]
local function _Shakeout(iterations, sigma, ...)
    local functionName, scoreStart = fsl.ScriptBegin('tlaloc Shakeout')

    fsl.MakeStable(nil, sigma, iterations)
    recipe.RepeatBlueFuse(iterations, sigma, ...)

    return fsl.ScriptEnd(functionName, scoreStart, false)
end

recipe =
{
    RepeatBlueFuse = _RepeatBlueFuse,

    Cataclysm = _Cataclysm,

    Contract = _Contract,
    RepeatContract = _RepeatContract,
    
    Hydrophobe = _Hydrophobe,

    MutateAll = _MutateAll,

    Push = _Push,

    RandomTug = _RandomTug,
    RepeatRandomTug = _RepeatRandomTug,

    Settle = _Settle,
    RepeatSettle = _RepeatSettle,
    
    Shakeout = _Shakeout,
}

-------------------------------------------------
-- Main code
fsl.ScriptInitialize()
recipe.RepeatContract(7, .03, 10, .03, 1, 1, banding.CreateBandsToCenter)
fsl.ScriptFinalize()
"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_29729" : "{
 "desc" : "QuakeR - a randomized Quake.  Options at end."
 "hidden" : "1"
 "mid" : "15698"
 "mrid" : "32528"
 "name" : "QuakeR 2.51"
 "parent" : "6285"
 "parent_mrid" : "16450"
 "player_id" : "174969"
 "script" : "--[[
QuakeR - a randomized Quake
Last update 15-01-2011 rav3n_pl

Based on "Quake" by Grom

Options at end
]]--

--[[
Tlaloc`s math library
------------------------------------------------------------------------
The original random script this was ported from has the following notices:
Copyright (c) 2007 Richard L. Mueller
Hilltop Lab web site - http://www.rlmueller.net
Version 1.0 - January 2, 2007
You have a royalty-free right to use, modify, reproduce, and
distribute this script file in any way you find useful, provided that
you agree that the copyright owner above has no warranty, obligations,
or liability for such use.
------------------------------------------------------------------------
]]--
local lngX = 1000
local lngC = 48313

local function _MWC()
    local A_Hi = 63551
    local A_Lo = 25354
    local M = 4294967296
    local H = 65536

    local S_Hi = math.floor(lngX / H)
    local S_Lo = lngX - (S_Hi * H)
    local C_Hi = math.floor(lngC / H)
    local F1 = A_Hi * S_Hi
    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi
 
    lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)
    lngX = lngX - (math.floor(lngX / M) * M)
    lngC = math.floor((F2 / H) + F1)

    return lngX
end

local function _abs(value)
    if value < 0 then
        return -value
    else
        return value
    end
end

local function _floor(value)
    return value - (value % 1)
end

local function _randomseed(s)
    if s==nil then 
        s=math.abs(get_score(true))
        s=s%0.001
        s=1/s
        while s<10000000 do s=s*10 end
        s=s-s%1
    end
    lngX = s
end

local function _random(m,n)
    if n == nil and m ~= nil then
        n = m
        m = 1
    end
    if (m == nil) and (n == nil) then
        return _MWC() / 4294967296
    else
        if n < m then
            return nil
        end
        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m
    end
end

math=
{
    abs = _abs,
    floor = _floor,
    random = _random,
    randomseed = _randomseed,
}

--[[ End math library ]]--

function Score()
    return get_score(true)
end

function Wiggle(how, iters, minppi) --score conditioned recursive wiggle/shake
    if how==nil then how="wa" end
    if iters==nil then iters=6 end
    if minppi==nil then minppi=0.1 end
    if iters>0 then
        iters=iters-1
        local sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(2)
            elseif how == "ws" then do_global_wiggle_sidechains(2)
            elseif how == "wa" then do_global_wiggle_all(2)
        end
        local ep = Score()
        local ig=ep-sp
        if ig > minppi then return Wiggle(how, iters, minppi) end --to learn recursion you have to learn recursion ;]
    end
end

 -- A random int between [1, high]
function RandomInt(high)
  return math.random(high)
end

P = print --a short

segCount = get_segment_count() --always the same

function FuseEnd()
    set_behavior_clash_importance(1)
    Wiggle()
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    P("Fuzing...")
    quicksave(4)
    Fuze1(0.1,0.7)
    quickload(4)
    Fuze1(0.3,0.6)
    quickload(4)
    Fuze2(0.5,0.7)
    quickload(4)
    Fuze2(0.7,0.5)
end

bestScore=Score()
function SaveBest()
    local s=Score()
    local g=s-bestScore
    if g>0 then
        P("Gained another ",round(g)," pts.")
        bestScore=s
        quicksave(3)
    end
end

function bandstr(str) --set all band strengt
    for i=1, get_band_count() do
        band_set_strength(i, str)
    end
end

function delBands() --delete all bands
    band_delete()
end

function down(x)--cut all after comma
    return x-x%1
end
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function qStab()
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
--    set_behavior_clash_importance(0.4)
   -- Wiggle()
    set_behavior_clash_importance(1)
    --Wiggle("s",1)
    Wiggle()
end
function SaveRB()
    quicksave(4)
    restore_recent_best()
    SaveBest()
    quickload(4)
end

function QuakeR()--a randoom Quake
    lastBS=0.1
    math.randomseed()
    --do_unfreeze_all()
    qsc=Score()
    quicksave(3)
    P("Starting QuakeR. ",qLoops," passes. Start score: ",round(qsc))
    for x=1, qLoops do
        P("Pass ",x," of ",qLoops)
        deselect_all()
        local start=down(RandomInt(segCount/5)) --first band somewhere in first 20% of protein
        local len=down(RandomInt(segCount/2-5))+10
        local step=down(RandomInt(segCount/2-5))+10
        local loss=math.abs(down(Score()*maxLoss/100))
        delBands()
        P("Bands from sgmnt ",start," of len ",len," every ",step," sgmnt.")
        P("Pulling until loss of ",loss," pts.")
        for x=start,segCount, step do
            for y=start+len, segCount, step do
                if y<=segCount then band_add_segment_segment(x,y) end
            end
        end
        select_all()
        set_behavior_clash_importance(pullingCI)
        reset_recent_best()
        for str=lastBS,maxBS,0.07 do--search enough band strenght to move
            restore_recent_best()--because sometimes it makes points during pull :D
            ss=Score()
            bandstr(str)
            do_global_wiggle_backbone(1)
            if ss-Score()>loss then 
                lastBS=str-0.1
                if lastBS<0.1 then lastBS=0.1 end
                break 
            end
        end
        delBands()
        SaveRB() --because sometimes it missing fractions
        P("Stabilizing...")
        set_behavior_clash_importance(1)
        reset_recent_best() --after pulling
        qStab()
--        SaveBest()
        if bestScore-Score()<doFuze then
            PinkFuse()
            restore_recent_best()
   --         SaveBest()
        end
SaveBest()
        quickload(3) --load best state
        P("Current score: ",round(Score())," Total gain: ",round(Score()-qsc))
    end
    P("Total QuakeR gain: ",round(Score()-qsc))
end

--- VVVVVVVVVV OPTIONS

qLoops=50  -- <<<OVER THERE! do more! much more!
maxBS=0.9 --maximum bads str
maxLoss=1 --minimum percentage loss when pulling. ie 5% of 10000 is 500pts
pullingCI=0.9 --clash importance while pulling
doFuze=-1 --run fuze when score after qstabilize is close to best

QuakeR()


"
 "type" : "script"
 "uses" : "0"
 "ver" : "0.3"
}
"
 "_recipe_3476" : "{
 "desc" : "Rebuilds entire protein by  2 to 6 segments at once. options at end."
 "hidden" : "0"
 "mid" : "11953"
 "mrid" : "23656"
 "name" : "Rav3n_pl Walkin Rebuild v5.1"
 "parent" : "0"
 "parent_mrid" : "0"
 "player_id" : "174969"
 "script" : "--[[ 
Walkin Rebuild v5.1
Walks form point to point and rebuilds structure.
Can work in all-loop or structure mode
options at end, can be used as overnight script
]]--

p=print
segCnt = get_segment_count()

function Score()
	return get_score(true)
end 
function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then 
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end
function SelectSphere(sg, radius,nodeselect)
    if nodeselect~=true then deselect_all() end
    for i=1, segCnt do
        if get_segment_distance(sg,i)<radius then select_index(i) end
    end
end
function SelectAround(ss,se,radius)
    for i=ss,se do
        SelectSphere(i, radius,true)
    end
end
function getPartScore(segments)--using partial scoring
    local attr = {'backbone','clashing','sidechain'} --,'hiding','disulfides','other','bonding','reference','packing'}
    local score = 0
    for i=1,#attr do
        score =  score + get_segment_score_part(attr[i], segments)
    end
    return score
end
function getAreaScore(ss,se)
    local s=0
    for i=ss,se do
        s=s+getPartScore(i)
    end
    return s
end

function round(x)--cut all afer 3-rd place
    return x-x%0.001
end
function down(x)
    return x-x%1
end

function Wiggle(how, iters, minppi)
    if how==nil then how="wa" end
    if iters==nil then     iters=6 end
    if minppi==nil then minppi=0.01 end
    
    if iters>0 then
        iters=iters-1
        sp=Score()
        if how == "s" then do_shake(1)
            elseif how == "wb" then do_global_wiggle_backbone(1)
            elseif how == "ws" then do_global_wiggle_sidechains(1)
            elseif how == "wa" then do_global_wiggle_all(1) 
        end
        ep = Score()
        ig=ep-sp
        if how~="s" then
            if ig > minppi then Wiggle(how, iters, minppi) end
        end
    end
end
function AllLoop() --turning entire structure to loops
    local ok=false
    for i=1, segCnt do
        local s=get_ss(i)
        if s~="L" then 
            save_structure()
            ok=true
            break
        end
    end
    if ok then
        select_all()
        replace_ss("L")
    end
end

bestScore=Score()
function SaveBest()
    local g=Score()-bestScore
    if g>0 then
        p("Gained another ",round(g)," pts. Current score: ",round(Score()))
        bestScore=Score()
        quicksave(3)
    end
end
function FuseEnd()
    set_behavior_clash_importance(0.9)
    Wiggle()
    set_behavior_clash_importance(1)
    Wiggle("s",1)
    Wiggle()
end
function Fuze1(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("s",1)
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function Fuze2(ci1,ci2)
    set_behavior_clash_importance(ci1)
    Wiggle("wa",1)
    set_behavior_clash_importance(1)
    Wiggle()
    set_behavior_clash_importance(ci2)
    Wiggle("wa",1)
    FuseEnd()
end
function PinkFuse()
    reset_recent_best()
    p("PinkFuse...")
    quicksave(4) -- store state before fuse
    Fuze1(0.1,0.7)
    quickload(4) -- load state before fuse
    Fuze1(0.3,0.6)
    quickload(4) -- load state before fuse
    Fuze2(0.5,0.7)
    quickload(4) -- load state before fuse
    Fuze2(0.7,0.5)
    restore_recent_best()
    SaveBest()
end

function qStabilize()
    --p("qStab...")
    select_all()
    set_behavior_clash_importance(0.1)
    Wiggle("s",1)
    set_behavior_clash_importance(0.6)
    Wiggle()
    set_behavior_clash_importance(1)
    Wiggle("s",1)
    Wiggle()
    SaveBest()
    if Score()>bestScore-fuzeThreshold then
        PinkFuse()
    end
end

function localRebuild(maxiters)
    if maxiters==nil then maxiters=3 end
    local s=Score()
    local i=0
    set_behavior_clash_importance(0.05)
    repeat
        i=i+1
        if i>maxiters then break end
        do_local_rebuild(i)
    until Score()~=s 
    set_behavior_clash_importance(1)
    if Score()~=s then return false else return true end
end

function Rebuild(ss,se,tries)
    if ss>se then ss,se=se,ss end --switch if needed
    p("Rebuilding area ",ss,"-",se," ",tries," times. Wait... Score: ",round(Score()))
    local sSc=Score()
    local done=false
    deselect_all()
    select_index_range(ss,se)
    local brk=0
    repeat
        done = localRebuild() --searching until score changes
        brk=brk+1
        if brk>5 then break end --break if no can do rebuild
    until done~=true
    if Score()~=sSc then --if rebuild succeed
        reset_recent_best() -- for best total score
        local partial=getPartScore(ss,se)
        quicksave(7) --save best partial score
        for try=1,tries do -- perform loop for number of tries
            deselect_all()
            select_index_range(ss,se)
            local s=Score()
            localRebuild()
            if Score()~=s then
                if doShake then 
                    SelectAround(ss,se,9)
                    Wiggle("ws",1)
                    Wiggle("s",1)
                    Wiggle("ws",1)
                end
                local part2=getPartScore(ss,se)
                if part2>partial then
                    quicksave(7)--save best partial score
                    partial=part2
                end
            end
        end
        restore_recent_best()--restore best total score
        p("Stabilizing best scored rebuild.")
        local bsr=Score()
        qStabilize()        
        quickload(7)
        if Score()~=bsr then
            p("Stabilizing best partal scored rebuild")
            qStabilize()
        else
            p("Same best partial.")
        end
        quickload(3)
    end
end

function WR()
    local ss=Score()
    if startS==nil then startS=1 end
    if endS==nil then endS=segCnt end
    if minL==nil then minL=1 end
    if maxL==nil then maxL=5 end
    if alloop==nil then alloop=true end
    set_behavior_clash_importance(1)
    if alloop then AllLoop() end
    reset_recent_best()
    quicksave(3)
    p("Walkin Rebuild started. From ",startS," to ",endS)
    if reverse==true then --from end
        for j=minL ,maxL  do
            for i=endS, startS+minL,-1  do
                local ss=i-j+1
                if ss>=1 then
                    Rebuild(ss,i,maxiters)
                end
            end
        end
    else --normal
        for j=minL ,maxL  do
            for i=startS,endS-minL  do
                if i+j-1<=segCnt then
                    Rebuild(i, i+j-1,maxiters)
                end
            end
        end
    end    
    if alloop then
        load_structure()
    end
    p("Totoal improved by: ",round(Score()-ss))
end

startS=1 -- start segment
endS=nil -- end segment, if nil - to end
reverse=false --start from end segment

minL=2 -- minimum rebuild lenght
maxL=6 -- maximum rebuild lenght

alloop=true -- work in allloop mode

maxiters=15 -- maximum tries to rebuild area - more=longer rebuild
doShake=false --if true shake area aroud rebuild every rebuild
doPF=true --Pinkfuze after stabilize    
fuzeThreshold=10 --do fuze only if score close to best

--for i=1,15 do --uncomment this and last line to loop it
WR() --go!
--end "
 "type" : "script"
 "uses" : "3"
 "ver" : "0.3"
}
"
}